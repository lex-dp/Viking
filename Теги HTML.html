<html>
<head>
</head>
<body bgcolor=aqua text=blue> <!--bgcolor---Цвет фона в Боди --> <!--text---весь текст будет такого цвета-->
	<h1></h1><!-- от h1 до h6, h1 cамое большое выделение текста, h6 самое маленькое-->
	<h1 align=center ></h1>  <!-- align=center ---Выравнивание текста-->
	<b></b> <!--Жирный-->
	<i></i> <!--Курсив-->
	<u></u> <!--Подчеркивание текста-->
	<font size=5></font> <!--Размер,может быть как увеличенный (size=5),так и уменьшенный (size=-7)-->
	<font size=5 color=red></font><!-- color ---Цвет текста -->
	<center></center> <!--Выравнивание текста по центру,захватывает даже DIV-->
	<ul></ul><!--Не нумированный список--><!--<ul><li></li></ul> -->
	<ol></ol><!--Нумированный список--><!--<ol><li></li></ol> -->
	<li>Тема</li><!--Тег Может идти как парным-->
	<li>Тема<!--Так и не парным-->
	<img src="images/shapka027.jpg" width=10% height=100 border=5 alt="Шапка">
	""<!--Кавычки ставятся только в тех случаях когда пишем русский текст,на англ если пишем то необезательно-->
	alt<!--Если к примеру путь указан неправельно то будет выводится "Шапка"-->
	<tr><tr><!--Строка-->
	<td align=right valign=bottom></td><!--Столбец-->
	align=right --Выравнивание по горизонтале(------)
	valign=(middle,bottom,top)- Выравнивание по вертикале(||||||||)
	<frameset rows="200, *" cols=""></frameset><!--Создает на страничке HTML другую страницу,к примеру 
	меню которое будет везьде и не нужно менять пути-->
	<!--rows="200, *"распологает фреймы горизонтально (------)--><!--200 по ширене и *все остальное место для других фреймов -->
	<!--cols=""=""распологает фреймы по вертикале(||||||||)-->
	

	<!-- -->
</body>
</html>

<html>
<head>
</head>
<body>
	<form action="request.php" method="post">
	<label>Имя:</label><!-- Метка-->
	<input type="text" name="name"><!--input--Определенные данные куда можно что-то ввести -->
	<br>
	<label>Е-мейл:</label>
	<input type="text" name="email">
	<br>
	<label>Пол:</label>
	<input type="radio" name="floor" value="male">Мужской	<!--Сейчас name одинаковое и можно выбрать только одно,Мужской или Женский,если name поменять то можно выбрать сразу 2-->
	<input type="radio" name="floor" value="female">Женский
	<br>
	<label>Виберите тему:</label>
	<select name="subject">	<!--Выпадающий список-->
	<option value="review">Отзыв</option>	<!--Выбор-->
	<option value="suggestion" selected>Предложение</option>	<!--selected по умолчанию будет идти Предложение -->
	<option value="problems">Жалоба</option>
	</select>
	<br>
	<label>Сообщение:</label>
	<br>
	<textarea name="masage" cols="40" rows="10"></textarea>
	<br>
	<input type="submit" value="Подтвердить"><!-- Кнопка,на ней будет написанно "Подтвердить"-->
	</form>
	
																		КЛАССЫ
	class="c c1 "---<!--с и с1 два разный класа пишутся через пробел-->
	
	
													АВТОМАТИЧЕСКИЙ ПЕРЕХОД 
	<li><a href="Урок 2(стили в HTML).html#film">Фильмы</a></li> 
			<!--#film название селектора id, и вставляем id="film" туда ,куда можно перейти на данной странице -->										
	<!-- -->
</body>
</html>
<!--action --- Адресс програмы обработчика,где он находится, то есть какие либо действие 
после того как будет отправлена форма на стороне сервера

 -->
<!-- -->
																Теги CSS
<?php
	!important---подразумевает, что данное свойство всегда будет иметь больший приоритет
	font-weight: bold;//Толщина Шрифта
	font-size: 16pt;//Размер Шрифта
	/*
		Жестко заданные размеры
		16pt   Пункты
		16mm  Милиметры
		16cm   Сантиметры
	*/
	/*
		Относительные размеры
		100%
	*/
	text-align: center;//Выравнивание текста
	color: green//Цвет текста
												ССЫЛКИ
	link //Цвет ссылки которую мы еще не посещяли
	visited /*Цвет посещенной ссылки  (Из-за проблем конфиденциальности браузеры начали накладывать некоторые ограничения на CSS-свойства,
															применяемые к псевдоклассу :visited . Оказалось,что злоумышленники научились с помощью JavaScript
															считывать изменения в стиле :visited ссылок, чтобы определить, какие сайты посещались. Например,
															путем загрузки нового фонового изображения для ссылок на посещенные сайты можно определить,
															был ли посетитель на сайтах Paypal.com, eBay.com,и т. д. Из-за потенциальной воз­
															можности возникновения проблем наложены ограничения на стилевое изменение цвета, фонового цвета и
															цвета рамки ссылок на посещенные сайты)*/
	vlink//Цвет посещенной ссылки аталог visited но только в html  <body vlink="#660066">
	alink//Цвет ссылки по которой мы сейчас переходим
	a:hover { color: red; } /*При наведении цвет будет красным,нужно быть внимательным так как,hover можно натворить дела, к примеру если  увеличиваеть 
										размер шрифта то при наведении указателя текст 	будет увеличиваться, выталкивая другие 
										элементы с их позиций. Результат может оказаться раздражающим*/
	target="_blank" //Открывает ссылку в новом окне
	a:link {
	
	}
	a:visited {  //Посещенные ссылки
	
	}
	a:active {  //Изменим вид гиперссылки на доли миллисекунды, то есть на момент, когда посетитель щелкает кнопкой мыши на ссылке
	
	В большинстве случаев для обеспечения максимальной гибкости дизайна тре-
буется включить в таблицу стилей псевдоклассы :link , :visited: и :hover . Но, что-
бы этот метод работал, вы должны расположить ссылки в определенной последо-
вательности: link , visited , hover и active
Ниже представлен способ добавления всех четырех
стилей ссылок:
a:link { color: #F60; }
a:visited { color: #900; }
a:hover { color: #F33; }
a:active {color: #B2F511; }
	Если вы измените последовательность, то состояния стилей hover и active пере-
станут функционировать. Например, если поместить a:hover перед a:link и  a:visited ,
то при наведении на ссылку указателя мыши ее цвет не изменится.

<a href="http://www.hydroponicsonline.com" class="sponsor">Visit this great
resource</a>
Для стилизации этой ссылки другим способом создадим следующий стиль:
a.sponsor { font-family: Arial, sans-serif; }
a.external:link { color: #F60; }
a.external:visited { color: #900; }
a.external:hover { color: #F33; }
a.external:active {color: #B2F511; }

Определения только имени стилевого класса, без указания названия тега a , будет тоже достаточно:
.sponsor { font-family: Arial, sans-serif; }
.external:link { color: #F60; }
.external:visited { color: #900; }
.external:hover { color: #F33; }
.external:active {color: #B2F511; }
Теперь такое форматирование приобретут лишь ссылки, принадлежащие стилевому классу 'external' .

a {text-decoration: none;} //Полное удаление подчеркивания
a 	 {
	 text-decoration: none;
	 border-bottom: dashed 2px #9F3;  //Можно использовать высоту для точного расположения линии
}														
Добавление для ссылок изображений — один из самых легких и эффективных
способов улучшить внешний вид элементов навигации сайта. Существует мно-
жество методик и вариантов дизайна, но при этом следует заметить, что ни в од-
ном из хороших, грамотных методов не применяется HTML-тег <img> . Вместо
этого используется прием с CSS-свойством background-image , с помощью которо-
го можно добавить привлекательность любой ссылке. Тоисть в тег а запихать background с картинкой и она будет внутри ссылки и на нее можно будет клацать так как она внутри тега а
																		
display:block;/*Параметр отображения block не только выравнивает все кнопки по ширине, но
и делает всю область ссылок активной при щелчке на ней кнопкой мыши, подобно
настоящим кнопкам. Это тот случай, когда посетители щелкают на области кноп-
ки, где нет текста (например, отступы вокруг), но ссылка по-прежнему работает */															
																		
Для ссылок Сначала нужно установить для свойства ссылок display значение inline-block .
Тогда верхние и нижние отступы и поля будут соответствовать требованиям
(как уже упоминалось, обычно линейные элементы игнорируют верхние и ниж-
ние отступы и поля, а также значения ширины и высоты). если поставить Display:inline; то высоту или отступы сверху снизу не зададим	
при использовании inline и inline-block панель навигации можно центри-
ровать, чего нельзя сделать с float .																	

Таким образом, чтобы создать стиль, который воздействует только на ссылки с абсолютным
 URL, можно использовать такой селектор:
a[href^='http://']
Сочетание ^= переводится как «начинается с», так что этот селектор соответс-
твует таким ссылкам, как <a href="http://www.google.com/"> , <a href="http://www.
sawmac.com/missing/css3/"> и т. д.

																		
																		
Псевдоклассы – это селекторы, которые определяют состояние уже существующих элементов, которое может меняться при определенных условиях.
Псевдоэлементы – это селекторы, которые определяют область элементов, которая изначально отсутствует в дереве документа. Эта область создается искусственно с помощью CSS.
Ключевое отличие между ними в том, что псевдоклассы определяют именно состояние элементов, которые уже существуют на странице, 
а псевдоэлементы создают области (искусственные элементы), которых изначально на веб-странице не было. Но и те и другие отсутствуют в исходном коде документа.		
																			ПСЕВДОКЛАССЫ
	a[href^="http"]  --^ если начинается с http то выполняем следующий стиль
	Этот селектор не будет работать в случае защищенного SSL-соединения, то есть когда ссылка на-
чинается с https://. Чтобы создать стиль, учитывающий данную проблему, вам понадобится груп-
повой селектор:			
a[href^="http://"], a[href^="https://"]
a[href$=".pdf"]  ---выбор ссылок с определенным расшерением $ означает «заканчивается на»
Сочетание $= означает «заканчивается на», и, соответственно, данный селек-
тор дает указание выбрать все ссылки, значение атрибута href которых закан-
чивается на .pdf . Вы можете создать аналогичные стили и для других типов
файлов:
a[href$='.zip'] /* ZIP-архив */
a[href$='.doc'] /* Word-документ */	
	
Например, каждую фотографию вы называли, используя при этом слово
headshot , — mcfarland_headshot , mccord_headshot и т. д. В каждом файле встречает-
ся слово headshot , поэтому и атрибут src тега <img> содержит это слово. Вы мо-
жете создать селектор специально для этих изображений:
img[src*="headshot"]

Самым простым выбором является ключевое слово — либо odd (нечетный),
либо even (четный), — позволяющее выбрать чередующиеся нечетные или четные
дочерние элементы. Например, если нужно предоставить один фоновый цвет для
каждой четной строки таблицы и другой фоновый цвет для каждой строки с не-
четным номером, можно создать два следующих стиля:
tr:nth-child(odd) { background-color: #D9F0FF; }
tr:nth-child(even) { background-color: #FFFFFF; }

p:not(.classy) { color: blue; }
Этот стиль задает тексту синий цвет во всех абзацах, к которым не применялся
класс classy .

a[href^="http://"]:not([href^="http://mysite.com"])
Если перевести на нормальный язык, этот селектор говорит: «Нужно выбрать
все ссылки, чей атрибут href начинается с http:// , но не те, которые начинаются
с  http://mysite.com ». Если вспомнить предыдущий материал, в селекторе атрибута
^= означает «начинается с». То же самое можно написать еще короче:
a[href^="http://"]:not([href*="mysite.com"])
В селекторе атрибута *= означает «содержит», тем самым любой абсолютный
URL, содержащий mysite.com , будет исключен. А такие адреса, как http://www.mys­
ite.com и http://mysite.com, будут включены.
Недостатком метода является то, что
Internet Explorer 8 и более ранних версий не понимает селектор :not()

Введите h1+p { .
Этот стиль будет применяться к любому абзацу, следующему за тегом <h1> ,
то есть за главным заголовком на странице. Ко второму и последующим абза-
цам он применяться не будет. Селектор предоставляет легкий способ создать
уникальный внешний вид для вступительного абзаца, его визуального выде-
ления и обозначения начала статьи.		

																ПСЕВДОЕЛЕМЕНТЫ
:first-letter  --Первая буква
:first-line   ---Первая строка
																
																
																РАЗМЕР
	font-size: 100%;
																ШРИФТЫ
	font-family: "Times New Roman" , serif;
	
	Шрифты с засечками (Serif). Шрифты с засечками (маленькими росчерками
на концах основных штрихов) идеальны для больших частей текста. Распростра-
нено мнение, что засечки визуально связывают одну букву с другой, делая текст
более читабельным. Примерами шрифтов с засечками являются Times, Times New
Roman, Georgia.

Шрифты без засечек. Шрифты без засечек часто используются для заголовков
благодаря простому и четкому внешнему виду. Примеры шрифтов без засечек —
Arial, Helvetica и Verdana.

Моноширинные шрифты. Моноширинный шрифт часто используется для ото­
бражения компьютерного кода.
Каждая буква в моноширинном шрифте имеет одинаковую ширину (как буквы в ме-
ханических печатных машинках).
 Courier — самый распространенный моноширинный шрифт, но ограничиваться только им не обя-
зательно. Lucida Console очень популярен в Windows и Macintosh
																ТОЛЩИНА
В Google обычные ключевые слова normal или bold для
обозначения плотности шрифтов не используются. Вместо них применяется чис-
ловая шкала от 100 до 900. Значение 700 соответствует варианту bold , 400 — вари-
анту normal , а остальные числа обозначают другие варианты толщины.
	font-weight: bold;
	
	по умолчанию размер текста 16px
	в % это 100% соотвецтвенно 200% это 32px
	начение размера шрифта 1em означает то же самое, что и 100 %, как описано в предыдущем разделе. Процентное значение экви-
валентно em, умноженному на 100: .5em  — 50 % и т. д.
rem ---Это название означает Root EM, то есть его значение основано
на размере текста корневого (root) элемента. Этот стиль задает размер шрифта от базового размера текста
																	Полезные теги
		input[type="submit"] {  //из всех инпутов в типе=сабмит будет примененно следующее
			border: 4px double black;  //двойная рамка
		}		

white-space: nowrap; --- запрет на перенос текста(если к примеру есть рамка,часть текста переносится и рамка разрывается на 2 части выглядит некрасиво) 	

																
																		Выравниваение по центру
	 width: 980px; margin: auto;---Свойство margin со значением auto выравнивает слой по центру только в комбинации со свойством width. 																
																		ТЕКСТ
	text-transform: uppercase;  --- весь текст с большой буквы
	text-transform: lowercase;  --- весь текст с маленькой буквы
	text-transform: capitalize; -- первая буква с большой будет
	text-transform: none;  --- не изменять текст или отмена изменений
	font-variant: small-caps;  ---все буквы будут малыми прописными
	
	По какой-то странной причине браузеры Chrome и Safari не распознают свойство text-transform,
когда оно используется с псевдоэлементом :first-line. Другими словами, вы не можете применять
в Chrome и Safari CSS для преобразования букв первой строки абзаца в прописные.
	
	text-decoration: underline;  ---подчеркивание нижнее
	text-decoration: underline overline; ---одновременно нижнее и верхнее подчеркивание
	text-decoration:line-through; ---Зачеркивание
	
	letter-spacing: -1px;   Сдвигает и раздвигает межсловные интервалы
	letter-spacing: .7em;  Положительные значения свойства делают промежуток между буквами больше:
	word-spacing: 2px;  ---интервалы между словами(например между разными словами будут такие отступы)

	Свойство text-shadow требует задания трех параметров: горизонтального сме-
щения (насколько левее или правее текста должна появиться тень), вертикаль-
ного смещения (насколько выше или ниже текста будет тень), степень размыто­
сти тени и цвет отбрасываемой тени. Например, свойство text-shadow , создающее
эффект, который показан в верхней части рис. 6.14, задается следующим обра-
зом:
text-shadow: -4px 4px 3px #999999;
text-shadow: 4px 60px 1px #D44B4D, 1px 80px 2px #000, 3px 90px 2px blue;

Стандартный размер межстрочного интервала браузера составляет 120 %
line-height: 120%;
line-height: 1.5;  ---Умножает,к примеру font-size: 16px; это будет 16*1.5

text-align:justify; ---Выравнивание текста по ширине

font: italic bold small-caps 18px/150%
Arial, Helvetica, sans-serif;
Оно приводит к созданию полужирного, курсивного
шрифта с малыми прописными буквами размером
18 пикселов, семейства Arial (или Helvetica, или sans-
serif) с межстрочным интервалом 150 %. 
Значения в пикселах — абсолютные значения, точное число, в то время как em
определяет размер отступа в количестве символов (базируется на текущем разме-
ре шрифта).
text-indent: 5em;
																СПИСКИ
Чтобы изменить списки(маркированные или нумерованные):
list-style-type: square; ---слева будет черный квадрат(а не нумерация или черная точка)
list-style-type:decimal-leading-zero;  --будет идти отчет(нумерация) с 01,02,03...
list-style-type: upper-alpha; ---нумерация будет большими буквами A,B,C...
list-style-type: lower-alpha;  ---нумерация будет маленькими буквами a,b,c...
list-style-type: upper-roman;  ---нумерация будет большими Римскими 
list-style-type: lower-roman;  ---нумерация будет маленькими Римскими 
list-style-type: lower-greek;  ---нумерация Греческими буквами
list-style-type: circle;  ---Белые круги(вместо стандартный черных)
list-style-type: decimal;  ---нумерованые 1,2,3,4,5....
											Позиционирование списков
list-style-position: outside;  ---список будет снаружи(по умолчанию стоит)
list-style-position:inside;     ---Список будет внутри

	list-style-image: url(images/look.jpg); ---позволяет загружать вместо стандартных маркеров квадратной и круглой формы,свои собственные загрузив,просто указав путь к файлу
Свойство list-style-image позволяет применять графические символы в каче­
стве маркеров. Однако оно не обеспечивает управления его размещением. Маркер
может оказаться слишком высоко или низко расположенным относительно пунк-
та списка. Придется переделывать сам графический символ маркера, пока он не
будет сочетаться. О более грамотном подходе вы узнаете в гл. 8. Он основан на
использовании свойства background-image . Это свойство позволяет точно позицио-
нировать графические элементы, в том числе маркеры в списках.																
																Пример изменения фона для списков
ol li {
	list-style:none;
	counter-increment:item;  //Задаем отчет item можно заменить любым другим например r или red...
}	
ol li:before {
	content: counter(item) "";Можно менять скажем вместо цыфр поставить круглую точкуcontent: counter(item, circle) "";
	color: red;
}В результате будет маркированный список(цыфры) красного цвета

Как в случае с Font можно делать сокращения и с List-style 
ol li {
	list-style: square url(images/look.jpg) inside;
}


													Поля и Отступы(Margin and Padding)
Предположим, значение нижнего поля маркированного списка установлено равным 30 пикселам, а значение верхнего поля
следующего за ним абзаца составляет 20 пикселов. Вместо того чтобы сложить два
значения, получив общий промежуток в размере 50 пикселов между списком и аб-
зацем, браузер применяет наибольшее из двух значений — в данном случае 30 пик-
селов. Если вас это не устраивает, используйте вместо полей верхний или нижний
отступ

Если вы хотите, чтобы верхние и нижние поля работали для линейного элемента, 
используйте инструкцию display:inline-block. Она оставит элемент линейным, но он
будет восприниматься как блочный,поэтому отступы, поля, границы, ширина и высота
будут к нему применяться.Кроме того,вам следует добавить инструкцию vertical-align:middle , 
чтобы Internet Explorer 7 отображал линейный блок таким же образом, как и остальные браузеры.
	
display . С его помощью можно заставить блочный элемент работать как линейный:
display: inline;
Или, наоборот, вы можете сделать так, чтобы линейные элементы, например
изображение или ссылка, вели себя как блочные:
display: block;
display: none; ---	Это значение выполняет одну простую функцию — полностью скрывает стилизуемый
элемент, чтобы он не отображался в окне браузера.

																Border
можно переписать определение border: 2px double #FFCC33; в следующем виде:
border-width: 2px;
border-style: double;
border-color: #FFCC33;
Однако каждая сторона имеет свой собственный набор из трех свойств, которые 
удобно использовать для отмены одного.
Правая граница: border-right-width , border-right-style и border-right-color . Левая,
верхняя и нижняя границы имеют похожие свойства: border-left-width , border-left-
style и т. д.
Кроме того, вы можете задать собственные значения для каждой стороны гра-
ницы, используя свойства border-width , border-style и border-color . Например,
border-width: 10px 5px 15px 13px;
border-style: double dashed solid dashed;
border-color: green yellow red blue;

border-radius:	105px 2px 139px 20px; --Сначала задается числовое значение для левого верхнего угла блока, а затем по
часовой стрелке — для всех остальных углов.
border-radius: 40px/20px;  --40 -это по горизонтали(левого или правого края), 20 по вертикали (верхнего или нижнего края) ,Слеш между ними оповещает браузер о создании эллиптического угла.
border-top-left-radius: 1em;
border-top-right-radius: 2em;
border-bottom-right-radius: 1.5em;
border-bottom-left-radius: .75em;
																		Тень для Блока
box-shadow: 3px 30px 3px black; ---система точно такая как и для text-shadow
У свойства box-shadow есть два дополнительных значения: ключевое слово inset
и значение расширения (spread). Ключевое слово inset заставляет браузер рисовать
тень внутри блока. Для создания внутренней тени нужно просто добавить inset в 
качестве первого значения свойства box-shadow :

box-shadow: inset 4px 4px 8px rgba(0,0,0,.75);

В качестве четвертого значения (между радиусом размытия тени и ее цветом)
можно также добавить значение расширения. Это приведет к расширению тени на
указанное значение. Иначе говоря, если добавить значение расширения, равное
10px , браузер расширит тень на 10 пикселов в каждом направлении (тень получа-
ется на 20 пикселов шире и на 20 пикселов выше). Это значение также задает то
место, где применяется радиус размытия. То есть, когда добавляется значение рас-
ширения, размытие тени не начинается до тех пор, пока не будет применено зна-
чение расширения. В частности, это пригодится в том случае, когда нужно добавить
тень вокруг всего элемента для создания эффекта, который во многих программах
редактирования изображений называется свечением (glow).
(Грубо говоря это РАСШИРЕНИЕ, линию внутри блока двигает по вертикали(вверх вниз),и может влиять на ее размер,чем больше значение тем больше размер)
box-shadow: inset 4px 4px 8px 10px rgba(0,0,0,.75);

Можно также использовать такую интересную комбинацию:
		border: 10px solid rgb(100,255,30);
		box-shadow: 0 0 0 10px blue;
К примеру вокруг како-го либо div-а будет рамка (в данном случае зеленного цвета)
а вокруг это рамки будет другая которую мы создаем с помощью box-shadow,рамка будет 10px синего цвета
box-shadow: 0 0 0 10px blue,0 0 0 20px red, 0 0 0 30px black; можно и больше

															Width and Height
Допустим, выустанавливаете размер шрифта 24 пиксела; единица em для этого стилизуемого
элемента будет равна 24 пиксела, а если вы установите ширину равной 2 em, она
составит 2 * 24, или 48 пикселов.


															Box-sizing
padding-box сообщает браузеру, что при установке для стиля свойства ширины
или высоты они должны включать отступы как часть своего значения. Например,
предположим, что есть элемент с отступами слева и справа, равными 20 пиксе-
лам, ширина которого установлена равной 100 пикселам. Браузер будет рассмат-
ривать часть, приходящуюся на отступы, частью этого 100-пиксельного значе-
ния. То есть ширина области содержимого будет равна всего лишь 60 пикселам
(100 – 20 [левый отступ] – 20 [правый отступ]).
border-box сообщает браузеру о необходимости включения в качестве состав-
ляющей части значений свойств ширины и высоты толщину как отступа, так
и рамки. Эта настройка решает проблему использования значений, выражен-
ных в процентном отношении, о которой говорилось выше. То есть, когда для
свойства box-sizing установлено значение border-box , при задании ширины эле-
мента, равной 50 %, этот элемент будет занимать до 50 % пространства, даже
если к нему будут добавлены отступы и рамки.
Если вам не нравится стандартный способ вычисления браузером элементов
ширины и высоты, воспользуйтесь значением border-box . (Если, конечно, у вас нет
какой-нибудь особой причины, по которой вы хотите включить в расчеты отступ,
но не желаете включать туда еще и рамку.) Чтобы воспользоваться свойством box-
sizing , просто предоставьте ему одно из трех значений из списка. Например:
box-sizing: border-box;
Этим инструкциям не будут следовать только Internet Explorer 7 и более ранние версии
Некоторые веб-разработчики предлагают устанавливать для всех элементов значение
 border-box , чтобы все теги измерялись одинаково. Для этого используется селектор * , 
 выбирающий каждый элемент на странице, который нужно поместить в верхней части 
 таблицы стилей вместе с перезапуском CSS:
* {
-moz-box-sizing: border-box;
box-sizing: border-box;
}
border-box
    Свойства width и height включают в себя значения полей и границ, но не отступов (margin). Эта модель используется браузером Internet Exporer в режиме несовместимости.
padding-box
    Свойства width и height включают в себя значения полей, но не отступов (margin) и границ (border). 
Лучше использовать border-box ,так он включает padding и border,     padding-box только padding    																
																OVERFLOW
Scroll  — позволяет добавить полосы прокрутки. Па-
раметр создает своего рода окно мини-браузера внутри веб-страницы, которое
выглядит подобно HTML-рамкам (фреймам). Вы можете использовать ключевое
слово scroll , чтобы вместить объемное содержимое в ограниченной области. К со-
жалению, при таком варианте полосы прокрутки отображаются всегда, даже если
содержимое по размерам помещается внутри блока.
Auto  — чтобы сделать полосы прокрутки необязательными, пользуйтесь данным
значением. Оно выполняет ту же функцию, что и scroll , с одним исключением —
полосы прокрутки добавляются только при необходимости.
Hidden  — скрывает любое содержимое, выходящее за пределы блочного элемен-
та. Это значение небезопасно, поскольку может привести
к тому, что часть содержимого будет не видна. Но иногда оно применяется при
создании плавающих разметок.

overflow:hidden; --- FLOAT не действует на Фон и границы,Добавление свойства overflow: hidden; устраняет эту проблему
Если элементы имеют различную высоту	лучше использовать 	display:inline-block; Float переместит обьекты с разной высотой вместо левого края,по центру или справа,с display:inline-block такой проблемы нет
	display:inline-block;  
	vertical-align:top; 		
	
Да и когда к примеру есть галерея фоток,НУЖНО СТАВИТЬ ЗНАЧЕНИЯ В PX,если поставить в % то результата не будет,они просто будут наезжать друг на друга	
																CLEAR(ОТМЕНА ОБТЕКАНИЯ)
Свойство clear говорит браузеру о том, что стилизуемый элемент не должен
обтекать плавающий элемент. Очищение параметра приводит к тому, что элемент
смещается вниз по тексту веб-страницы, располагаясь ниже плавающего элемента.
Кроме того, вы можете управлять очисткой с любой стороны элемента (слева или
справа) или просто полностью удалить все параметры обтекания.
Свойство clear допускает следующие значения:
 left  — стилизуемый элемент смещается вниз относительно плавающего с уста-
новленным левым обтеканием, но правое обтекание остается в силе;
 right  — стилизуемый элемент смещается вниз относительно плавающего с уста-
новленным правым обтеканием, параметр левого обтекания остается в силе;
both  — вызывает перемещение стилизуемого элемента вниз относительно пла-
вающего с установленными левым и правым обтеканием;
 none  — полностью отменяет очистку обтекания: говорит браузеру, что стилизу­
емый элемент должен вести себя стандартным образом, как предусмотрено, то есть
он может обтекать плавающие элементы как с левой, так и с правой стороны.

																	ФОРМАТ
формат PNG (Portable Network Grap­hics) включает в себя лучшие черты GIF-и JPEG-
форматов, но вы должны узнать, какую именно версию PNG использовать в конкретной ситуации. PNG8 в основ­
ном заменяет GIF. Как и GIF, он предлагает 256 цветов и базовую возможность сделать один цвет прозрачным.
Тем не менее, PNG8 обычно сжимает изображения и делает их размер несколько меньшим, чем GIF. По этой
причине изображения PNG8 загружаются чуть быстрее,чем такие же изображения, сохраненные в формате GIF.
То есть лучше использовать PNG8, а не GIF.PNG24 и PNG32 (также известный как PNG24 с альфа-
прозрачностью ) предлагают расширенную цветовую палитру JPEG-изображений без потери качества.
Это означает, что фотографии сохраняются в форматах PNG24 или PNG32 и, как правило, имеют более высокое
качества, чем JPEG. Но прежде, чем перейти к формату PNG, следует помнить, что изображения JPEG предлага­
ют очень хорошее качество и гораздо меньший размер файла, чем PNG24 либо PNG32. В общем, JPEG является
лучшим выбором для фотографий и других изображений, которые состоят из множества цветов.
Однако PNG32 имеет одну особенность, которой нет у других форматов: это 256 уровней прозрачности (также
называемой альфа-прозрачностью ). Она позволяетоформить фон веб-страницы как тень или задать для
графики прозрачность 50 %, чтобы можно было видеть что-либо сквозь нее, создавая эффект полупрозрачности.

																	BACKGROUND
Свойство background-image добавляет рисунок в качестве фона элемента. Чтобы
поместить его на заднем плане всей веб-страницы, можно создать стиль для тега
body {
background-image: url(images/bg.gif);
url(http://www.cosmofarmer.com/image/bg.gif);  ---или Абсолютный путь
}
background-repeat: no-repeat; ---Свойство может принимать четыре значения. Рассмотрим их по порядку:
	repeat  — параметр по умолчанию, обеспечивает повторное отображение фоново-
го рисунка слева направо и сверху вниз, до полного заполнения всего простран­
ства веб-страницы
	no-repeat  — отображает фоновый рисунок один раз, без повторения и перекрытия.
	repeat-x  — вызывает повторение фонового изображения горизонтально вдоль
оси Х (по всей ширине веб-страницы)
Можно работать с двумя наборами ключевых слов: один из них имеет три парамет-
ра управления горизонтальным позиционированием: left , center , right , а другой —
три параметра вертикального позиционирования: top , center , bottom
(К примеру чтобы указать нижний левый угол background-position:left bottom; нужно указать высоту,скажем к html:100%; в Firefox) 
background-position укажет, с какой позиции нужно начать повторное отображение
	background-position: 50% 100%;  --Можно также в % указывать

																background-attachment
background-attachment ---которое может принимать два значения: scroll и fixed . Значение по умолчанию scroll
определяет такое поведение браузера, при котором фоновое изображение прокручи-
вается вместе с текстом и другим содержимым. Значение fixed предотвращает пере-
мещение, жестко фиксируя его на заднем плане. Так, если вы хотите поместить логотип 
компании в левом верхнем углу веб-страницы и зафиксировать его
там даже в случае прокрутки посетителями содержимого вниз

																	background-origin
Возможность , которая позволяет сообщить браузеру, где фоновое изображение должно
 начаться по отношению к рамке, отступу и содержимому элемента
Свойство background-origin определяет область позиционирования фонового рисунка.
 Это свойство не применяется, когда значение background-attachment задано как fixed
    padding-box 	Фон позиционируется относительно края элемента с учетом толщины границы.
	border-box    Фон позиционируется относительно границы, при этом линия границы может перекрывать изображение.
	content-box   Фон позиционируется относительно содержимого элемента.
 background-origin: content-box;
 
																		background-clip
Определяет, как цвет фона или фоновая картинка должна выводиться под границами. 
Эффект заметен при прозрачных или пунктирных границах.
padding-box    Фон отображается внутри границ.
border-box    Фон выводится под границами.
content-box    Фон отображается только внутри контента. 	
background-clip: border-box; /* Фон под рамкой */ 	

	background-origin зприменяется для фоновой картинка,куда и где ее расположить,а 	
	background-clip для фона(background-color:blue;) к примеру	
background-origin: content-box; --будет вставленная фоновая картинка идти по контенту(все что применяется к контенту padding...)
background-clip: border-box;  --фон скажем синий будет виходить пд рамку(работает только с пунктирными рамками,под сплошной не будет вижно фона)

Чтобы установить размер изображения, нужно задать его высоту и ширину.
Для этого можно воспользоваться абсолютными значениями, выраженными
в пикселах:
	 background-size: 100px 200px; ---
Этот код устанавливает для фонового изображения ширину 100 пикселов и вы-
соту 200 пикселов. Можно также указать только значения ширины или высоты,
задав для оставшегося значения режим определения auto :
	 background-size: 100px auto;
	 В таком случае фоновое изображения будет иметь ширину 100 пикселов, а браузер
автоматически установит его высоту, сохраняя пропорции изображения (чтобы
не возникло искажений)
Можно в % или просто указывать одно значение высоти или ширины
	 background-size: contain;---Масштабирует изображение с сохранением пропорций таким образом, чтобы картинка целиком поместилась внутрь блока
	 background-size: cover;  ---Ключевое слово cover заставляет ширину изображения соответствовать ширине
элемента, а высоту изображения соответствовать высоте элемента. Обычно этоприводит к 
искажению изображения путем либо сжатия, либо растяжения с тем,чтобы оно поместилось в размеры элемента

Просто набирайте свойство background , за которым должны следовать значения
для background-image , background-position , background-repeat , background-attachment
и background-color . Следующий стиль устанавливает фон белого цвета с едва замет-
ным неповторяющимся отпечатком, закрепленным по центру веб-страницы:
body {
background: url(bullseye.gif) center center no-repeat fixed #FFF;
Вовсе не обязательно указывать абсолютно все параметры свойства. Вы може-
те использовать один из них или любое сочетание. Например, background: yellow
равнозначно background-color: yellow . Все те параметры свойства, которые вы не
определите сами, будут иметь стандартные значения по умолчанию. Допустим, вы
задали только само фоновое изображение:
background: url(image/bullseye.gif)
Это эквивалентно следующему стилю:
background: url(image/bullseye.gif) scroll left top repeat transparent;  ---transparent (невидимый)

background-color: yellow;
background: url(image/bullseye.gif) no-repeat;
Возможно, вы ожидали увидеть изображение бычьего глаза на желтом фоне.
Но вы его не увидите, потому что при встрече свойства background без указания
цвета, браузер переключает значение background-color на transparent (невидимый).
Чтобы выйти из этой сложной ситуации нужно указать свойство background-color
вторым:
background: url(image/bullseye.gif) no-repeat;
background-color: yellow;
Кроме того, когда к одному и тому же элементу применяется сразу несколько
свойств, можно в конечном итоге случайно уничтожить фоновые изображения.
Предположим, например, что нужно добавить фоновое изображение к каждому
абзацу страницы, для чего создается следующий стиль:
p {
background: url(icon.png) left top no-repeat rgb(0,30,0);
}
Затем принимается решение, что после заголовка второго уровня каждый пер-
вый абзац должен иметь синий фон, и создается следующий стиль:
h2 + p {
background: blue;
}
В этом втором стиле используется сокращенная запись, сбрасывающая все
остальные свойства фона к их значениям по умолчанию. Что касается изображе-
ния, то по умолчанию оно вообще не используется, поэтому вместо простого до-
бавления к абзацу синего фона с оставлением изображения на месте, этот стиль
вообще удаляет изображение!
То есть сокращенная запись свойства background может сэкономить время на
написании кода, но также может и принести проблемы, о чем не нужно забывать.
}

background: url(images/scroll_top.jpg) top  no-repeat ,
					url(images/scroll_bottom.jpg) bottom no-repeat ,
					url(images/scroll_middle.jpg)  center repeat-y;
Несколько фоновых изображений выкладываются друг на друга, как слои в программе редактиро-
вания изображений. Какое из изображений появится в верхнем слое, определяется порядком пе-
речисления фоновых изображений. Изображение, указанное первым, появляется в верхнем слое
элемента, второе — во втором слое, и последнее появляется в нижнем слое.
При создании нескольких фоновых изображений в Internet Explorer 8 не работает.Можно обходится div-ами или :before, :after

																			ГРАДИЕНТ
background-image: linear-gradient(to left, black,white); ---Линейній градиент,от левого белого угла к правому черному будет переход 
Углы записываются в диапазоне от 0 до 360 0deg означает, что градиент начинается в левой
части и перемещается в правую часть, а при указании 45deg он начинается в нижнем левом 
углу и перемещается под углом 45° в верхний правый угол. 0 градусов это середина
background-image: linear-gradient(to left, black,white,blue,black);  ---можно использовать несколько цветов(скажем rgba с прозрачностью)
в этом примере цвет будет начинатся с лева,черный,голубой,белый,черный все это плавно переходит из одного цвета в другой
Веб-браузеры распределяют цвета равномерно,Но можно разместить разные цветовые опорные
точки и в более конкретно указанных местах фона, добавив после цвета второе значение
background-image: linear-gradient(to left, red,white,black 5%); ---СТРАННО но в Градиентах все наоборот, слева будет не 5% а 95%черного(background-position)
Для указания позиций цветовых опорных точек не обязательно задавать проценты. Можно также
использовать пикселы или em. Но указание процентных значений является более гибким решением,
приспосабливающимся к изменениям ширины и высоты элемента
Для того к примеру чтобы убрать размитость скажем для заполнения пространсва одной половины на 80% другой на 20% можно воспользоватся Градиентом

Градиенты не поддерживаются в Internet Explorer 9 и более ранних версиях
для обхода нужно подставить примерный фон а далее вести градиенты
    background: #fefcea; /* Для старых браузров */
    background: linear-gradient(to top, #fefcea, #f1da36);
	Internet Explorer 9 применит фоновый цвет и пропустит все остальные, непонят-
ные ему объявления.

раузер рисует
градиент, а затем повторяет этот шаблон, распространяя его в виде плиток по фону
элемента
background-image: repeating-linear-gradient( to bottom left, #900 20px, #FC0 30px,
#900 40px)
background-image: repeating-linear-gradient(45deg, #900 0, #900 10px, #FC0
10px, #FC0 20px);  --полосы, к градсам (45deg) не нужно применять to
																Радиальные градиенты
											В линейный было ключевое слово "to" в радиальный "at"	
Синтаксис похож на тот, который применяется для линейных градиентов, нужно только
 предоставить начальный цвет (цвет в середине градиента) и конечный цвет (цвет в кон-
це градиента)	background-image: radial-gradient(red, blue);  --в середине будет крассный цвет а вокруг него синий
Можно указать background-position; Для позиционирования внутренего цвета и background-size; для размножения,управлять размером одного внутренего цвета можно в % просто указав radial-gradient(red 10%, blue 40%);
background-image: radial-gradient(circle closest-side at 20px 50px, red, blue); ---closest-side  — предписывает браузеру создать градиент, распространяющийся
из центра только до ближайшей к центру стороне элемента,circle --означает создать круг,также есть ellipse,создает елипс
НУ ВООБЩЕМ ВОТ ССЫЛКА НА рАДИАЛЬНЫЕ ГРАДИЕНТЫ http://htmlbook.ru/css3-na-primerakh/radialnyi-gradient

background-image: repeating-radial-gradient(circle, red 20px, orange 30px,yellow 40px, red 50px); --Как и в линейный здесь тоже есть повторения
Учтите, что для создания повторяющихся радиальных градиентов без резких пе-
реходов, градиент нужно завершать тем же цветом, с которого он начинался (в данном
примере это красный цвет). Тем самым будет обеспечено плавное возвращение цвета
к начальному. Если этого не сделать (например, если последним цветом в показанном
выше коде сделать желтый), то получится резкая граница там, где заканчивается по­
следний цвет и в повторяющемся градиенте начинается первый цвет.

Сложность градиентов и их ограниченная поддержка браузерами могут скло-
нить вас к решению не использовать их в своих таблицах CSS. К счастью, есть
интерактивное средство, позволяющее создавать большинство типов градиентов
(за исключением повторяющихся) буквально одним щелчком. Это средство на-
зывается Ultimate CSS Gradient Generator ( www.colorzilla.com/gradient-editor/ )

Чтобы заставить Internet Explorer 8 и более ранние версии распознавать теги <figure> и <figcaption>,
нужно включить JavaScript-файл HTML5shiv(ГЛАВА 08)). См. врезку «Обходной прием. Как заставить Internet
Explorer 8 понимать HTML5» в разделе «Дополнительные теги в HTML5» гл. 1.

																АНИМАЦИЯ
Основным CSS-свойством для получения любого из этих изменений является transform . 
Оно используется с предоставлением типа желаемого преобразования и добавлением значения, 
указывающего на степень преобразования элемента. Например, для вращения элемента 
предоставляется ключевое слово rotate , за которым следует количество градусов поворота:
transform: rotate(10deg);
Показанное выше объявление приведет к вращению элемента на 10° по часовой
стрелке.Разобраться в работе функции rotate свойства transform довольно просто: ей предо-
ставляется угол от 0 до 360°, а браузер вращает указанный элемент по кругу														
																	Масштабирование
Элемент можно также увеличить или уменьшить в размерах, воспользовавшись
для этого функцией scale. Например, чтобы увеличить элемент вдвое,
нужно добавить следующее объявление:
transform: scale(2);
Число, представляемое в скобках, является коэффициентом масштабирова-
ния — числом, на которое умножаются текущие размеры элемента. Например,
1 говорит об отсутствии масштабирования, .5 указывает на половину текущего
размера, а 4  — на учетверение текущего размера. То есть числа между 0 и 1 приво-
дят к уменьшению, а числа больше 1 — к увеличению элемента (значение 0 факти-
чески делает элемент невидимым на странице).На это число происходит масштабирование 
элемента и всего, что в нем находится. Например, если масштабировать <div> -контейнер 
с коэффициентом 2, то вдвое шире и выше станет не только сам контейнер, но также 
и текст внутри него.Это же касается и находящихся внутри изображений.																
ЧТО БЫ ПРИ НАВЕДЕНИИ УВЕЛИЧИТЬ РАЗМЕР ССЫЛКИ С ПОМОЩЬЮ SCALE НУЖНО ПОСТАВТЬ DISPLAY:BLOCK;											

Первое число будет относиться к горизонтальному, а второе — к вертикальному 
масштабированию. Например, чтобы сделать элемент вдвое меньше по ширине, 
но вдвое выше, используется следующее объявление: transform: scale(.5,2);																
В CSS3 также предоставлены отдельные функции для горизонтального и вертикального 
масштабирования: scaleX проводит масштабирование по горизонтальной оси,
 а scaleY  — по вертикальной. Например, чтобы элемент стал вдвое выше без  изменения 
 его ширины, можно воспользоваться следующим объявлением:transform: scaleY(2);	
Однако чтобы элемент стал в три с половиной раза шире, а не выше или ниже,
следует воспользоваться объявлением: transform: scaleX(3.5); 
чтобы перевернуть элемент вокруг его обеих центральных осей, нужноприменить 
следующее объявление:  transform: scale(-1);

transform: translate(2px, 5px); --Перемещает обьект,но когда с использованием функции
translate перемещается div или другой тег, браузер оставляет пустое пространство там, 
где этот тег появился бы при обычных обстоятельствах,а затем рисует элемент в его новой позиции
transform: translateY(-.5em);						
transform: translateX(-.5em);//Есть как по горизонтале так и по вертикале 													
																	Наклон
transform: skew(10deg,45deg);//наклон(Функция skew является одним из способов имитации трехмерного отображения)
											//По горизонтали10deg и по вертикали45deg
Как и в случае с translate и scale , в CSS3 предлагаются отдельные функции для
осей X и Y: skewX и skewY
transform: skew(45deg,0deg) scale(.5) translate(400px,500px) rotate(90deg); //Сокращенный вариант
Браузер будет применять все эффекты в порядке следования функций. элемент сначала будет наклонен, 
затем масштабирован, после чего будет перемещен и, наконец, подвергнется вращению

Обычно, когда к элементу применяется преобразование, в качестве точки начала преобразования 
браузер использует центр элемента. Например, при вращении элемента браузер поворачивает 
его вокруг центральной точки .Но в CSS3 разрешается изменять точку преобразования, 
используя свойство transform-origin . Это свойство работает точно так же, как и ранее
 рассмотренное свойство background-position . Для него можно указывать ключевые слова, 
 абсолютные значения и относительные значения в em и процентах.Например, чтобы повернуть 
 div -контейнер вокруг его левой верхней точки, можно воспользоваться ключевыми словами
 left и top : transform-origin: left top;//Другими словами будет вид какбудто блок держится за левый верхний угол,вместо изначального центра
Проценты,пиксели,em все это тоже работает

Веб-браузер не может анимировать каждое отдельно взятое свойство CSS, но у вас в 
распоряжении остается все же весьма длинный список свойств, на которых можно остановить 
свой выбор. Кроме таких преобразований, как rotate , scale ,translate и skew , о которых только 
что шла речь, можно также анимировать такие свойства, как color , background-color , border-color , 
border-width , font-size , height ,width , letter-spacing , line-height , margin , opacity , padding , 
word-spacing , свойства позиционирования top , left , right и bottom , которые будут рассмотрены
 в гл. 15, а также многие другие свойства. Их полный список можно найти по адресу 
 www.w3.org/TR/css3-transitions/#animatable-properties .

 Первое свойство — transition-property  — указывает на анимируемое свойство.Можно указать 
 одно свойство (как в показанном выше примере), воспользоваться ключевым словом all для 
 анимирования всех изменяемых CSS-свойств или применить списком с запятой в качестве
 разделителя для указания более чем одного свойства (но не всех свойств). Предположим, 
 например, что вы создаете стиль :hover , чтобы изменялись сразу цвет текста, фоновый цвет 
 и цвет границы. Все эти три свойства указываются в виде следующего списка:
//transition-property: color, background-color, border-color;
или, чтобы упростить код, указывается ключевое слово all :
//transition-property: all;
Чтобы указать продолжительность анимации, используется свойство transition-
duration . Ему передается или значение в секундах, или значение в миллисекундах
(тысячных долях секунды). Например, чтобы переход занимал полсекунды, можно
использовать либо:
//transition-duration: .5s;
либо
//transition-duration: 500ms;

Можно даже указать отдельную продолжительность для каждого анимируемого свойства. 
Например, когда посетитель проводит указатель мыши над кнопкой, может потребоваться, 
чтобы цвет текста изменялся быстрее, цвет фона изменялся немного медленнее, а цвет границы 
изменялся заметно медленнее. Для этого нужно перечислить анимируемые свойства, используя 
cвойство transition ,а затем перечислить показатели продолжительности с помощью свойства
 transition-duration :
transition-property: color, background-color, border-color;
transition-duration: .25s, .75s, 2s;  Порядок перечисления показателей продолжительности 
должен соответствовать порядку перечисления свойств.

Чтобы анимированный переход заработал, нужно только установить значения для свойств 
transition-property и transition-duration . Но с помощью свойства transition-timing-function можно 
также контролировать и скорость хода анимации. В предназначении этого свойства нетрудно
 и запутаться: оно управляет не продолжительностью анимации (для этого есть свойство
 transition-duration ), а скоростью хода анимации.Например, можно начать анимацию медленно, 
 а затем быстро ее завершить, создавая эффект незаметного в начале и быстрого в конце 
 изменения фонового цвета.Свойство transition-timing-function может получать одно из пяти
 ключевых слов: linear , ease , ease-in , ease-out и ease-in-out . Если функцию регулирования
скорости не задавать, браузер будет использовать метод ease , при котором анимация начинается
 медленно, ускоряется к середине и замедляется к концу, предоставляя более естественное 
 изменение. Вариант linear дает равномерное изменение на протяжении всего периода анимации.
 Ни один из вариантов не имеет заметных преимуществ перед другими, они просто предлагают 
 различную общую картину,и для определения своих предпочтений нужно просмотреть все
 варианты.Чтобы воспользоваться этим свойством, нужно просто добавить свойство 
 transition-timing-function и метод, который вам хочется использовать:
 transition-timing-function: ease-in-out;

 К ПРИМЕРУ ЕСЛИ СОЗДАТЬ 4 БЛОКА И СДЕЛАТЬ ТАК ЧТО ПРИ HOVER НУЖНО ЧТОБЫ ОНИ ВСПЛЫВАЛИ
 НО НУЖНО ДЕРЖАТЬ МИШКУ НА БЛОКЕ ИНАЧЕ ОН ПАДАЕТ ВНИЗ,ОБОЙТИ МОЖНО С ПОМОЩЬЮ
 .MAIN:HOVER .A1(после HOVER ЗАДАЕМ ИМЯ КЛАСА КОТОРЫЙ БУДЕТ ВСПЛЫВАТЬ)ПРИ ЭТОМ
 МИШКУ МОЖНО НАВЕСТИ ОДИН РАЗ НА БЛОК.ДАЖЕ ПОСЛЕ ТОГО КАК БЛОК ПОДНИМЕТСЯ ВВЕРХ
 А МИШКА БУДЕТ ВНИЗУ ВСЕ БУДЕТ РАБОТАТЬ(БЛОК БУДЕТ ТЯНУТСЯ К ВЕРХУ)
												
И наконец, можно задержать время начала анимации перехода, воспользовавшись свойством
 transition delay . Например, если вы хотите подождать полсекунды, прежде чем начать анимацию,
 можно добавить следующий код:                //transition-delay: .5s;
Разумеется, это свойство требует наличия префиксов производителей, поэтому,чтобы заставить 
его работать в большинстве браузеров, нужно написать следу­ющий код:
-webkit-transition-delay: .5s;
-moz-transition-delay: .5s;
-o-transition-delay: .5s;
transition-delay: .5s;
 или так 
transition-property: color, background-color, border-color;
transition-duration: 1s, 1s, .5s;
transition-delay: 0, 2s, 4s;
Как и в случае применения свойства transition-duration , для каждого свойства можно указать 
свое время задержки. Порядок перечисления показателей времени должен соответствовать 
порядку перечисления этих свойств для transition-property .

Обычно свойства перехода помещаются в начальный (.navButtonon в предыдущем примере), а не
в конечный стиль (.navButton:hover). Но при использовании раскрывающегося меню CSS возникают
некоторые сложности. Проблема в том, что при задании раскрывающихся меню с помощью CSS они
слишком быстро пропадают при случайном выходе указателя мыши за их пределы. Но с помощью
свойства transition-delay можно заставить меню быстро появляться и медленно исчезать. Для этого
добавьте в исходный стиль следующий код:
transition-delay: 5s;
Затем добавьте задержку к стилю :hover:
transition-delay: 0;
Каким бы странным этот код ни показался, он заставляет переход по :hover происходить немедлен-
но, без задержки. А вот возвращение к обычному стилю (при котором меню исчезает) занимает
5 секунд. За это время посетитель успеет вернуть свою непослушную мышь обратно на меню,
пока оно не исчезло.												
														Краткая запись свойства transition
Нужно просто перечислить через запятую свойство, продолжительность, функцию
 распределения скорости по времени и задержку. Например, для анимации всех CSS-свойств 
 на 1 секунду,используя функцию ease-in и полусекундную задержку, нужно написать с
 ледующий код: //transition: all 1s ease-in .5s;												
или такой пример 	transition: all 1s 4s; //1s-duration ,4s-delay		
timing-function(ease-in)-можно не указывать оно будет тогда по умолчанию 										
transition: border 1s 2s,background 2s 4s; если property нужно указывать для отжельный значений												
												
	@keyframes имяАнимации {
from {
/* Здесь перечисляются CSS-свойства */
}
to {
/* Здесь перечисляются CSS-свойства */
}
}
Процентное значение указывает место на общей продолжительности анимации, где
должно произойти изменение.
@keyframes backgroundGlow {
from {
background-color: yellow;
}
50% {
background-color: blue; //В данном случае синий фон появится в середине анимации
}
to {
background-color: red;
}
}
//Ключевое слово from можно заменить значением 0 %, а ключевое слово to — значением 100 %.

@keyframes glow {
from {
background-color: yellow;
}
25%, 75% {
background-color: blue;
}
to {
background-color: red;
}
}
25%,75%--Они означают,что на 25 % от всего хода анимации фоновый цвет элемента станет 
синим. Но он будет оставаться синим до 75 %, то есть 25 % от всего хода анимации. 
От отметки 25 % до отметки 75 % фон будет сохранять чисто-синий цвет, перед тем как к 
окончанию анимации превратиться в красный. Если продолжительность этой анимации 
будет 4 секунды, то в средние 2-й секунды фон элемента будет иметь чисто-синий цвет.	
												
@keyframes glow {
from {
background-color: yellow;
}
20%, 60% {
background-color: blue;
}
40%, 80% {
background-color: orange;
}
to {
background-color: red;
}
}												
В данном случае фоновый цвет превратится в синий на отметке 20 %, в оранжевый — 
на отметке 40 %, затем опять в синий на отметке 60 %, и перед тем как стать в конце анимации 
красным, он еще один последний раз на отметке 80 % превратится в оранжевый												
												
Один из недостатков анимации CSS3 состоит в том, что ей требуются префиксы производителей 
(как и большинству других свойств CSS3). То есть вам нужно повторить определения ключевых 
кадров для каждого браузера. Поэтому для запуска следующей анимации постепенного появления
 элемента на как можно большем количестве браузеров, придется написать следующий код:
@-webkit-keyframes fadeIn {
from {
opacity: 0;
}
to {
opacity: 1;
}
}
@-moz-keyframes fadeIn{
from {
opacity: 0;
}
to {
opacity: 1;
}
}
@-o-keyframes fadeIn{
from {
opacity: 0;
}
to {
opacity: 1;
}
}
@keyframes fadeIn{
from {
opacity: 0;
}
to {
opacity: 1;
}
}
Обратите внимание на два дефиса: один между символом @ и префиксом производителя 
и второй между префиксом производителя и словом keyframes.												
	
@keyframes fadein { //fedein название анимации
	from {
		opacity:0;
		background-color:yellow;//С чего начинаем
		width:300px;
		height:200px;
	}
	to {
		opacity:1;//Куда идем
		width:500px;
		height:600px;
	}
}
.announcement {                                                                                    
	animation-name:fadein; //Нужно вести название анимации                     
	animation-duration:1s;//И минимум для анимации,это время
}
/*Как и в случае использования правила @keyframes , каждое из свойств анимации требует 
префиксов, определяющих производителя, поэтому показанный вышестиль .announcement для 
работы на как можно большем количестве браузеров нужно переписать следующим образом:
.announcement {
animation-name: fadeIn;
animation-duration: 1s;
-webkit-animation-name: fadeIn;
-webkit-animation-duration: 1s;
-moz-animation-name: fadeIn;
-moz-animation-duration: 1s;
-o-animation-name: fadeIn;
-o-animation-duration: 1s;
animation-name: fadeIn;
animation-duration: 1s;
}*/
Кроме того, к одному и тому же элементу можно применить более одной анимации. Предположим, 
что вы создаете одну анимацию с именем fadeIn , чтобы анимировать появление элемента, 
и еще одну анимацию с именем blink , чтобы получить мигающий цвет фона. Чтобы применить 
к элементу обе анимации, нужно указать список имен с запятой в качестве разделителя:
animation-name: fadeIn, blink;
Чтобы задать этим анимациям разные параметры времени, нужно указать список этих параметров
 с запятой в качестве разделителя:
animation-name: fadeIn, blink;
animation-duration: 1s, 3s;

Есть animation-timing-function: ease-out;//Точно такое как и transition-timing-function
animation-delay: 1s; //Точно такое как и transition-delay
animation-iteration-count:10; //Запускает повторение анимации 10 раз
Если же необходимо, чтобы анимация повторялась непрерывно, для этого свойству animation-
iteration-count передается одно ключевое слово: infinite;
animation-iteration-count:infinite;
animation-direction: alternate; //Анимация сначала идет как обично,а потом идет в обратном направлении

animation-iteration-count: 2; //1я волна анимации идет как обычно,а вторая
animation-direction: alternate;//Идет в обратном направлении
animation-fill-mode:forwards;//Оставляет вид который у него был по завершении анимации
													Краткая запись Animation
.fade {
animation-name: fadeOut;
animation-duration: 2s;
animation-timing-function: ease-in-out;//Анимация Будет происходить равномерно по времени
animation-iteration-count: 2;
animation-direction: alternate;
animation-delay: 5s;
animation-fill-mode: forwards;
}
и придать ему следующий вид:
.fade {
animation: fadeOut 2s ease-in-out 2 alternate 5s forwards;
}
Обязательными являются только имя и продолжительность. Все остальные значения являются необязательными													
.fade {
-webkit-animation: fadeOut 2s ease-in-out 2 alternate 5s forwards,
								 glow 5s;
-moz-animation: fadeOut 2s ease-in-out 2 alternate 5s forwards,
							 glow 5s;
-o-animation: fadeOut 2s ease-in-out 2 alternate 5s forwards,
						 glow 5s;
animation: fadeOut 2s ease-in-out 2 alternate 5s forwards,
					 glow 5s;
}

animation-play-state:paused; //Приостановка анимации(одно из двух ключевых слов — running или paused)
Но фактически применить это свойство к CSS можно только с помощью псевдокласса.
 Как и в случае с переходами, для приостановки анимации нужен инициатор.
	
Transform-Просто преобразование(наклон,изгиб..но не создает анимацию)его приминять для неподвижности или в @keyframes
Transition-Это уже анимация без (@keyframes) самая простая,и работает на background-color,width...(transform работает с rotate,skew);
@keyframes-это уже серьйозная анимация,в ней есть transform	
												
												Таблици и Формы
vertical-align(top ,baseline,middle или bottom) не унаследовано, поэтому вы можете задействовать его
только в стилях, которые применяются прямо в тегах <th> и <td>
baseline -точно также как и top,но выравнивает первую строку на ровне с соседней ячейкой												
												
Когда мы задаем ( td { border: 1px solid black; } )	образуется видимый интервал между ячейками	около 2 пикселов									
Чтобы убрать или добавить пространцтво:
 table {
border-spacing: 0;
}												
Но это приведет к удвоению границ,Это происходит потому, что нижняя граница одной ячейки 
добавляется к верхней границе лежащей внизу ячейки.Лучший способ избавиться от этого 
(а также от промежутков между ячейками) — использовать свойство border-collapse . Оно может
 принимать два значения —separate и collapse . Значение separate эквивалентно тому, как обычно 
 и отображаются таблицы: с промежутками между ячейками и двойными границами. Задавая 
 окаймление границ таблицы, можно избавиться от интервалов и двойных границ.							
table { border-collapse: collapse; }											
Если установить для свойства border-collapse значение collapse, свойство border-spacing работать
не будет.Выбрать последнее и все дела												
Учтите, что при установке для свойства border-collapse значения collapse браузеры 
проигнорируют установку для ячеек таблицы свойства border-radius и просто нарисуют 
обычные прямые углы.												

tr:nth-of-type(odd) { background-color: red; }//Используется для виделение одной строки(четной и нечетной)
tr:nth-of-type(even) { background-color: blue; }//разными цветами чтобы удобно читать было												
Селектор nth-of-type в Internet Explorer 8 и более ранних версиях не поддерживается												
												
Текстовые поля ввода. Теги <input type="text"> , <input type="password"> и <textarea> создают текстовые поля в форме. 
Эти теги лучше всего поддерживаются браузерами. Вы можете изменить размер шрифта, 
тип шрифта, цвет и другие свойства текста в полях ввода, а также добавить границы, фоновые 
цвета и изображения. Можно задать ширину этих полей с помощью CSS-свойства width . Однако 
свойство height поддерживает только тег <textarea>												

Кнопки в форме, такие как <input type="submit"> , позволяют вашим пользователям передавать 
данные в форму, очищать содержимое формы или предпринимать какие-либо другие действия.												
												
Раскрывающиеся списки. Списки, созданные с помощью тега <select> , также можно форматировать, используя стили												
												
Флажки и переключатели. Большинство браузеров не позволяют применять форматирование 
к этим элементам. Opera тем не менее дает возможность увидеть фоновый цвет внутри флажка 
или переключателя. Internet Explorer добавляет фоновый цвет вокруг этих элементов. Поскольку
 браузеры сильно различаются в способе представления этих элементов страницы, лучше оста-
вить флажки в покое.												

Поместите каждую надпись в тег. Очевидным выбором для этого будет тег <label> , так как он и был разработан для надписей
Обычно теги <label> и <span> являются линейными элементами, игнорирующими многие 
настройки, доступные блочным элементам, включая width ,height и text-align . Но если превратить 
надпись ( label ) в линейный блок ( inline-block ), она по-прежнему будет располагаться рядом с
 полем формы (оправдывая свою линейную — inline  — часть свойства)

 <colgroup>
			<col id="product">  
			<col id="price">
			<col id="rating">
		</colgroup>
 //Я так понял это управляет td,к примеру есть куча tr и 3 td(в одной строке 3 столбца)и если задать ширину для id="price"  ,то ширина задастца для всего 2го столбца                        

 Псевдокласс :checked применяется к элементам интерфейса, таким как переключатели (checkbox)
и флажки (radio), когда они находятся в положение «включено». Переключение элементов в такое 
состояние происходит с помощью атрибута checked тега <input> или пользователем (ccылка для примера: http://htmlbook.ru/css/checked)

Псевдокласс :focus определяет стиль для элемента получающего фокус. Например, им может 
быть текстовое поле формы, в которое устанавливается курсор.

															Проблемы с Float
Если один столбец короче другого(содержимое) то нижний колонтитул может передвинуться
 вверх, оказавшись рядом с каким-то плавающим блоком, нужно использовать clear:both;
.clear:after {
	 content: " ";
	 display: table;
	 clear: both;
}
. 	 clear {
	 zoom:1;
}
//Будет работать и для IE 6,7, Cтавим для блока и после него обтекание отменятеся
/*спользование свойства zoom приводит к тому, что страница не проходит проверку CSS-кода на
корректность. Чтобы решить эту проблему, вы можете поместить данное выражение (наряду с лю-
быми другими специальными стилями для Internet Explorer) во внешнюю таблицу стилей и присо-
единить ее к вашим веб-страницам, используя любую методику*/
																						
												
												
																Internet Explorer
Если вы не назначите свойству border тега <img> значение 0, Internet Explorer добавит границу-
рамку вокруг изображения, выступающего ссылкой. Чтобы этого не произошло, добавьте в таблицу
стилей следующее: img { border: none;}.
Internet Explorer 9 не понимает свойство transform, поэтому для работы данного свойства 
в этом браузере нужно воспользоваться свойством -ms-transform
-ms-transform: rotate(10deg);
												По поводу Анимации с помощью CSS3
Появившиеся в CSS3 переходы работают в большинстве браузеров. Но когда речь заходит об Internet
Explorer, с сожалением приходится заметить, что переходы этот браузер понимает, только начиная
с версии 10. Поэтому лучше использовать переходы только как средство придания выразительности.
При этом в большинстве случаев все будет выглядеть вполне приемлемо: Internet Explorer 9 и более
ранние версии смогут обеспечить переключение между двумя стилями (например, показать стиль
для hove) без анимации данного изменения.Префикс производителя -ms- применять не нужно, 
поскольку Internet Explorer 9 и более ранние версии свойства transition не понимают,
 а Internet Explorer 10 понимает версию этого свойства без указания префикса.
 В процессе написания книги текущие версии Firefox и Opera перестали нуждаться в указании пре-
фиксов производителей для свойства transition. Но чтобы гарантировать работу анимации в более
ранних версиях этих браузеров, лучше пока продолжить использование префиксов -moz- и -o- 
 -webkit-transition-property: background-color;
-moz-transition-property: background-color;
-o-transition-property: background-color;
transition-property: background-color;
-webkit-transition-duration: 1s;
-moz-transition-duration: 1s;
-o-transition-duration: 1s;

Медиазапросы понятны большинству браузеров мобильных и настольных устройств, но непонятны
Internet Explorer 8 и более ранним версиям. Устаревшие версии Internet Explorer можно заставить
понимать ваши медиазапросы, если добавить к тегу <head> документа немного кода JavaScript.
Нужно загрузить файл respond.js с адреса http://tinyurl.com/7w49a6z, поместить этот файл в ваш
сайт, а затем дать на него ссылку на странице, воспользовавшись тегом <script>. Например:
<!--[if lte IE 8]>
<script src="respond.min.js"></script>
<![endif]-->
Этот небольшой маневр заставит Internet Explorer 8, 7 и 6 понимать медиазапросы.

											Подключение Internet Explorer
Скажем, мы хотим загрузить специфическую таблицу стилей только для Internet Explorer 7
<!--[if IE 7]>
<link href="IE7_styles.css" rel="stylesheet" >
<![endif]-->
Или, используя правило @import :  
<!--[if IE 7]>
<style>
@import url(IE7_styles.css)
</style>
<![endif]-->
Этот код нацелен конкретно на Internet Explorer 7 и не будет применяться к любой другой 
более ранней версии.Но иногда нужно включить и другие версии.Например, можно создать 
таблицу стилей, применяемую к Internet Explorer 6, 7 и 8.В таком случае можно воспользоваться
ключевым словом lte , которое означает «less than or equal — меньше чем или равно», 
следовательно, lte IE 8 означает «если это Internet Explorer 8 или более ранняя версия»:
<!--[if lte IE 8]>
<link href="IE_styles.css" rel="stylesheet">
<![endif]-->
Условные комментарии нужно добавлять после любых ссылок на таблицы стилей.
Так код выглядит и должен идти
<link href="global_styles.css" rel="stylesheet" type="text/css" />
<!--[if IE 8]>
<link href="IE8_styles.css" rel="stylesheet" type="text/css" />
<![endif]-->
<!--[if lte IE 7]>
<link href="IE_old_styles.css" rel="stylesheet" type="text/css" />
<![endif]-->







															Таблици и Формы
Internet Explorer 9 -не понимает скругленные углы,градиенты,тени

														Примечания
Есть минусы использования фотографий в качестве фонов тегов <div> (или других тегов HTML).
Браузеры обычно не печатают фон, так что если у вас есть страница с картой, содержащей какие-
то важные маршруты, вставьте ее с помощью тега <img>, а не в качестве фонового изображения.
Кроме того, поисковые системы обходят стороной CSS, поэтому, если вы думаете, что изображение
может привлечь дополнительный трафик на ваш сайт, используйте тег <img> и добавьте описа-
тельный атрибут alt.

															Адаптивный дизайн
Нужно просто к разделу <head> веб-страницы добавить следующий код (самое подходящее
 место для этого — непосредственно перед тегом <title> ):
 
<meta name="viewport" content="width=device-width">

Метатеги HTML предоставляют дополнительную информацию о содержимом страницы и
 могут дать браузерам дополнительные инструкции о способах отображения страницы на 
 дисплее. В данном случае viewport обозначает экран браузера,а для атрибута content 
 устанавливается ширина экрана браузера, равная ширине экрана смартфона. То есть 
 браузерам мобильных устройств, склонным к уменьшению масштаба, предписывается 
 этого не делать, настроив ширину экрана на текущую ширину дисплея смартфона.

Кроме использования метатега viewport, есть еще один способ заставить смартфон не предприни-
мать попыток сжатия вашей страницы, а вывести вместо этого ее в 100%-ном размере. Разработ-
чики из CSS Working Group добавили к CSS правило @viewport, которое позволяет делать все то
же самое, что и с метатегом viewport, но в вашей таблице стилей. Благодаря этому можно отка-
заться от добавления тега <meta> к каждому HTML-файлу сайта и просто добавить одно правило
@viewport к своей таблице стилей:
@viewport { width: device-width; }
Это правило нужно добавить в самом начале таблицы стилей до объявления самих стилей. К сожа-
лению, в настоящее время правило @viewport еще не работает на всех браузерах и требует для тех
браузеров, которые его не понимают, добавлять префикс производителя.

<link href="css/small.css" rel="stylesheet" media="(width: 480px)">
К этой стандартной ссылке на таблицу стилей добавился только еще один атрибут media , 
устанавливающий условия, при которых браузер использует указанную таблицу. В показанном выше 
примере браузер загружает внешнюю таблицу стилей small.css , когда кто-нибудь просматривает
ваш сайт с помощью браузера, ширина окна которого составляет 480 пикселов. Скобки вокруг
запроса — (width: 480px)  — являются обязательным элементом. Если их не поставить, 
браузер проигнорирует запрос.
480 пикселов — слишком точное значение. А что, если кто-нибудь пользуется телефонами с 
менее широким экраном, скажем, с шириной 300 пикселов? Лучше все же применять в медиазапросе
диапазон значений. Например, может понадобиться задействовать конкретный стиль для экранов, 
ширина которых меньше или равна 480 пикселам. Это можно сделать с помощью следующего кода:
<link href="css/small.css" rel="stylesheet" media="(max-width:480px)">
Запись "(max-width:480px)" эквивалентна высказыванию «для экранов, име­ющих ширину до 480 
пикселов». Поэтому стили внутри файла small.css применяются,например, 
к экранам шириной 480, 320 и 200 пикселов.

Есть также и вариант min-width , определяющий, имеет ли браузер как минимум указанную ширину 
экрана. Этот вариант применяется при нацеливании на устройство, которое больше мобильного
 телефона или планшетного компьютера. Например, чтобы применить стили к экрану шире 768 
 пикселов, что превосходит ширину экрана многих планшетных компьютеров, нужно использовать 
 следующий код:
<link href="css/large.css" rel="stylesheet" media="(min-width:769px)">

И наконец, можно установить как максимальное, так и минимальное значения ширины экрана
 целевых устройств, чтобы в них попадали браузеры устройств между телефонами и настольными
 компьютерами. Например, чтобы создать набор стилей для планшетного компьютера, имеющего
 экран шириной 768 пикселов, можно воспользоваться следующим кодом CSS:
<link href="css/medium.css" rel="stylesheet" media="(min-width:481px) and (max-width:768px)">
Иными словами, экран браузера должен быть шириной как минимум 481 и как
максимум 768 пикселов. Этот файл medium.css не будет применяться к смартфонам
с шириной экрана 320 пикселов, а также к браузерам настольных систем с шириной
экрана 1024 пиксела.

@import url(css/small.css) (max-width:320px);//Во внешнюю таблицу стилей можно подключать другие стили(small.css) и медиа запрос
директивы @import должны помещаться в начало таблицы стилей. Они не могут идти после
 каких-либо стилей. В результате могут возникать проблемы с каскадностью!

													С Фиксированной в Адаптивный дизайн
1)Установить блок с контентом,с какой-то фиксированной шириной(к примеру 960px) в %,
width:auto;//Тоже самое что и 100% 
2)Затем нужно преобразовать параметры ширины колонок со значения в пикселах в значение
в процентах.
Рассмотрим пример. Предположим, что внутри этой страницы шириной 960 пикселов есть две 
колонки: боковая панель шириной 180 пикселов и основная колонка шириной 780 пикселов. 
В CSS-файле имеется следующий код:
.sidebar {
float: left;
width: 180px;
}
.main {
float: left;
width: 780px;
}
Конечно, в нем присутствует множество другого кода CSS, задающего границы,фоновые цвета и т. д.,
но в данном случае нас интересуют только параметры ширины.Приступая к преобразованию боковой
панели, нужно взять ее ширину, равную 180 пикселам, и разделить ее на ширину контейнера этой 
боковой панели, равную 960 пикселам. Получившийся результат 0,1875 нужно умножить на 100 и 
получитьпроцентное значение: 18,75 %. Точно так же для основной колонки 780 делится на 960,
и получается 0,8125. При умножении этого результата на 100 получаем 81,25 %.То есть изменения 
параметров ширины этих стилей придают им следующий вид:
.sidebar {
float: left;
width: 18.75%;
} 
 .main {
float: left;
width: 81.25%;
}
 Эти новые значения не нужно округлять. То есть не превращайте 18,75 % в 19 %,поскольку это, 
 скорее всего, приведет к тому, что колонки больше не будут стоять рядом и мы столкнемся с 
 выпадением плавающего элемента. Браузеры хорошо справляются с десятичными значениями,
 и вы спокойно можете использовать любые значения, возвращаемые калькулятором. Вполне 
 допустима, скажем, ширина,заданная значением 25.48488% .
 
					Картинка больше контейнера в котором находится нужно сделать Адпаптивно
Сначала нужно добавить в таблицу стилей следующий стиль:
img { max-width: 100%; }
То есть изображение не сможет стать больше колонки, div -контейнера или любого HTML-элемента, 
внутри которого оно находится.				
Но когда указывается и ширина и высота нужно:
Найдите на странице все теги <img> и удалите из них атрибуты height и width . То есть превратите 
этот код HTML:
<img src="bunny.jpg" width="320" height="200" alt="bunny">
в этот:
<img src="bunny.jpg" alt="bunny">				
								
Можно также делать так:								
.imgSmallLeft {
float: left;
max-width: 40%;
}
<img src="bunny.jpg" alt="bunny" class="imgSmallLeft">								
Таким образом, создание адаптивных изображений не составляет особого труда.Нужно просто убрать 
из HTML атрибуты высоты и ширины и установить значения max-width . Если изображениям нужны 
другие размеры, следует создать селекторы классов с требуемыми значениями свойств max-width 
и применить эти классы к тегам <img> . 
 
															Позиционирование
Обычно порядок наложения элементов следует их порядку в HTML-коде страницы. На странице с
 двумя абсолютно позиционированными тегами <div> второй тег из HTML появится выше другого 
 тега <div> . Однако вы можете управлять порядком, в котором накладываются элементы, используя
 CSS-свойство z-index .Свойство получает числовое значение:
																			z-index: 3;
Чем больше значение, тем ближе к вершине набора появится элемент. Скажем,у вас есть три 
абсолютно позиционированных изображения и части каждого из них в некоторой степени
перекрываются. Изображение, имеющее больший индекс позиционного уровня, появится над другими
Для z-index можно даже использовать отрицательные числа, которые могут пригодиться, если нужно
позиционировать элемент ниже его родительского элемента или любого из его предков.																
Отрицательные значения z-index поддерживаются большинством браузеров, кроме Internet Explorer 7 
и более ранних версий, поэтому, если нужна поддержка Internet Explorer 7, то отрицательные
 значения для z-index лучше вообще не использовать.
Если нужно обеспечить,чтобы над размещаемым элементом больше ничего не появлялось, задайте 
ему очень большой индекс позиционного уровня, например z-index: 10 000;. Но не переусердствуйте,
поскольку максимальное значение, которое обрабатывают некоторые браузеры, равно 2 147 483 647. 
 
														Скрытие частей страницы
visibility:hidden;//Cкрывает
visibility:visible;//Показывает
display:none;//Скрывает														
Значение hidden свойства visibility подобно значению none свойства display ,но между ними есть 
существенное различие. Когда вы устанавливаете свойству display элемента значение none , он 
буквально исчезает со страницы, не оставляя следов.Однако задание свойству visibility значения
 hidden предотвращает показ браузером содержимого элемента, но оставляет пустое пространство 
 в том месте, где должен был быть элемент.
 Есть и другой способ скрытия элемента — установка для его свойства непрозрачности   opacity
нулевого значения:
															opacity: 0;
Чтобы элемент снова появился на экране, его свойству opacity можно вернуть значение 1 :
															opacity: 1;
Преимущество использования свойства opacity заключается в том, что это свойство является одним 
из CSS-свойств, которые браузер может анимировать.Это означает, что вы можете использовать
 CSS-переходы,для анимации изменений непрозрачности. Например, элемент можно сделать 
 постепенно появляющимся в поле зрения, изменяя его непрозрачность от 0 до 1 и добавляя
переход.Самый распространенный способ переключать режим элемента от скрытого
к видимому и наоборот — через JavaScript.
 
 
														Распечатываемые сайты
Типы устройств: три типа: all , screen и print(их больше но большинство не подержывается)
all  — относится к каждому типу устройства.Стоит по умолчанию поэтому его не нужно указывать

screen— отображается только на мониторе. Когда вы определяете этот тип, брау­
зер игнорирует такие стили при печати страницы. Этот тип устройства позво-
ляет вам отделить те стили, которые выглядят замечательно на экране, но ужас-
но — на бумаге, например задание белого текста на черном фоне.

print  — применяется только при печати страницы. Тип устройства print позво-
ляет создать стили, которые используют подходящие для печати размеры шриф-
та, цвета, графику и т. д.

					Как добавлять аппаратно-зависимые таблицы стилей?
они могут быть или внутренними, или внешними. Однако если вы хотите, чтобы браузер применил 
стили только для определенного устройства, например для экрана или принтера, то должны 
добавить таблицу стилей к своей странице немного другим способом.
Чтобы присоединить внешнюю таблицу стилей при определении конкретного типа устройства,
используйте тег <link> с атрибутом media . Чтобы присоединить таблицу стилей, которая должна 
использоваться только при печати, добавьте такой HTML-код к своей веб-странице:
<link rel="stylesheet" media="print" href="print.css"/>

Формально CSS также позволяет определить тип устройства, когда вы используете правило 
@import для присоединения внешней таблицы стилей  таким образом:
@import url(print.css) print;. 
Но, поскольку Internet Explorer 8 и более ранние версии не понимает этот код, его лучше не использовать.

Кроме того, вы можете задать множество типов устройств, разделяя их запятыми.Присоединенная
 внешняя таблица стилей, предназначенная для нескольких устройств, могла бы быть такой:
<link rel="stylesheet" media="screen, projection, handheld" href="screen.css"/>

Решите хранить все стили в отдельной внешней таблице и просто добавить несколько стилей, 
предназначенных только для принтера. Вы можете сделать это, используя инструкцию @media 
следующего вида:
@media print {
/* описывайте стили для печати здесь */
}
Не забудьте указать закрывающую фигурную скобку (на последней строке),иначе инструкция 
не будет работать. Вот пример использования @media для включения двух стилей, 
предназначенных только для принтера:
@media print {
h1 {
font-size: 24pt;
}
p {
font-size: 12pt;
}
}

Браузеры не печатают фоновые изображения, только если им не указать делать это!!!
Чтобы просмотреть до печати, как будет выглядеть страница на бумаге, можно использовать ко-
манду Print Preview (Предварительный просмотр) браузера.
ля печати лучше использовать пункты. Это единицы, в которых Word и другие программы 
обработки текста измеряют высоту шрифта.Для большинства браузеров — 16 пикселов — 
печатается как 12 пунктов.
p {
font-size: 12pt;
}
Лучше изменить цвет текста на черный,для принтера(черно-белого) будет лучше смотрется

Поскольку цветные фоны съедают чернила и порошок принтера, большинство браузеров обычно 
не отправляют их на печать, а многие посетители Сети не включают фоны при печати, даже если
их браузеры имеют такую возможность.Вдобавок, даже если фон на самом деле напечатается, 
он может конкурировать с любым текстом, наложенным на него.
Белый текст на черном фоне обычно вызывает самую большую проблему — у вашего посетителя
после печати получится чистый белый лист. К счастью, в современных браузерах есть возможность
изменять белый текст на черный (или серый), когда идет печать без фона.
Просто делает фону белый цвет,а тексту черный

Вы читаете и сталкиваетесь с таким переходом: «И вотя нашел секрет вечной жизни здесь»
Чтобы отобразить ссылки нужно написать
a[href^="http://"]:after {
content: " (" attr(href) ") "; /* Выводим адрес ссылки в скобках */
}

										Добавление разрывов страницы для печати
Два широко признанных свойства -это page-break-before:always и page-break-after:always .Первое свойство 
указывает браузеру вставить разрыв страницы перед данным(на верху страници),а второе в конце страницы 
При печати страницы браузер разделяет ее содержимое на множество страниц,чтобы вместить
на каждой как можно больше текста. Если же вы хотите, чтобы разрывы страниц находились 
в более логичных местах, используйте свойство page-break-before

Рассмотрим быстрый способ использования этих свойств в своих интересах.Создайте два класса
 стилей, названных, например, .break_after и .break_before :
.break_before { page-break-before: always; }
.break_after { page-break-after: always; }
Теперь вы можете выборочно применять эти стили к элементам, которые должны печататься 
наверху или внизу страницы. Если вы хотите, чтобы определенный заголовок был напечатан 
наверху страницы, используйте такой стиль: <h1 class="break_before"> .

Если свойства из двух стилей с одинаковым названием конфликтуют, то побеждают свойства 
последней присоединенной к странице таблицы стилей, так что этот тег <link> должен идти 
после другого тега <link> . Таким образом, если у файла main.css есть класс, названный 
.copyright , который создает белый 10-пиксельный текст на черном фоне, вы можете создать
другой стиль, названный .copyright ,в таблице стилей для печати, с черным текстом размером 
12 пунктов на белом фоне. Хотя два стиля имеют одно название, свойства из таблицы стилей 
для печати победят, потому что она присоединена последней.

Последовательность для печатной версии:
1)Создать файл для внешней таблици стилей(к примеру print.css)
2)Присоединить таблицу(она должна идти после всех стилей css) <link href="print.css" rel="stylesheet" media="print" />
3)Поскольку вы не знаете, на бумаге какого размера будет распечатана эта страница, нужно
избавиться от всех заданных значений ширины и удалить все поля.
. 	 banner, .mainWrapper, .footer, .main {
	 width: auto;
	 margin: 0;
	 padding: 0;
}
Значение auto просто позволяет тегу <div> заполнить всю доступную ширину, поэтому за 
размер бумаги можно не беспокоиться. Два других объявления — margin и padding  — 
устраняют пространство вокруг этих разделов div .
При печати плавающих разметок могут проявиться различные проблемы.Плавающие элементы
могут внезапно выскочить за пределы их блока-контейнера, не позволяя фонам и границам 
отображаться корректно.Решение заключается в следующем: добавьте объявление 
overflow: hidden;к стилю блока-контейнера. Тем не менее скрытие переполняющегося содержи-
мого иногда приводит к тому, что печатный материал не отображается. Поэтому
вы должны выключить это: overflow: visible;
4)Выравнять высоту и местоположение логотипа
.banner {
	height:auto;
	text-align:center;
	border-bottom: 2pt solid #000;
	border-top: 2pt solid #000;
	padding: 10pt 0;
	margin-bottom: 15pt;
} 
5)Убрать фон
html,body .banner, .footerWrapper {
	background:#fff;
}
6)Установить черный цвет текста
* {
	 color: #000000 !important;
}
7)Добавить URL адресса(название сайтов)типа кликни сюда чтобы перейти
a:after {
	content: "("attr(href)")";
}
8)Дальше по усмотрению,Убираем Float для правой части...,Margin...,Увеличить h1 скажем к 30pt,
h2 16pt, p 11pt,

                                        Совершенствуем  навыки работы с CSS
1)Добавление комментариев.В СSS  они добавляются так:   /*Коментарий*/
2)Не использовать названия, основанные на месте расположения элемента,лучше использовать
sidebar , .copyright и .banner не потребуют много времени для набора, но их назначение сразу
 очевидно,а .left к примеру удобен но если поменять мустоположение блока становится неудобным! 
3)Использование @import,к примеру нужно разбить стили на 30 внешних таблиц,но серверу легче и по скорости
загрузки будет быстрее сделать один большорй запрос нежели 30 маленьких,тогда делаем так:
создаем таблицу стилей скажем global.css, и в ней присоединяем все остальные страницы стилей,
@import 	url(main.css);
@import	url(layout.css);
@import	url(color.css);
@import	url(forms.css);
Это весь код который будет в файле,можно коментариеми пометить
и присоединяем через тег link, 	<link rel="stylesheet" href="global.css" />

4)Проблемы с кэшем,кэш гарантирует, что частым посетителям вашего сайта не придется 
загружать один и тот же файл снова и снова, что замедлило бы открытие страниц и повысило
оплату за хостинг.Тем не менее кэш может стать головной болью, когда вам необходимо обновить
внешний вид сайта. Например, если все его страницы ссылаются на внешнюю таблицу стиля под 
названием main.css ,у посетителей этот файл будет кэширован. Но при обновлении файла и, 
соответственно, изменении внешнего вида сайта предыдущие посетители могут по-прежнему
иметь доступ к старой таблице стилей, сохраненной на их жестком диске, вместо нового файла main.css .
Со временем кэш посетителей все же очистится и они получат новые CSS-файлы. Однако у вас есть один
простой способ победить кэш — обновить тег <link> на каждой HTML-странице. Обычно тег
<link> для внешней таблицы стилей выглядит следующим образом:
<link rel="stylesheet" href="main.css">
Однако если добавить строку запроса после имени CSS-файла (например, main.css?v=1 ), то 
браузер будет видеть файл как main.css?v=1 , а не как main.css
Предположим, что, когда вы запускаете ваш сайт, файл main.css является первой версией
стилей CSS сайта.Вы можете использовать этот тег <link> :
<link rel="stylesheet" href="main.css?v=1">
Затем, когда вы обновите файл main.css , можно изменить тег <link> на следующий:
<link rel="stylesheet" href="main.css?v=2">
На самом деле ?v=1 ничего не делает и не влияет на то, как работает веб-сервер. Это просто 
способ заставить браузер перезагрузить файл.
Недостатком этого метода является необходимость обновлять теги <link> для каждого HTML-файла сайта.









?>
																	ПОЛЕЗНЫЕ ССЫЛКИ
http://hellohappy.org/beautiful-web-type/  ---красивые шрифтыч
www.co­lourlovers.com  ---Цвета
https://developer.mozilla.org/en-US/docs/Web/CSS/color_value  ---Цвета
http://www.fontsquirrel.com/tools/webfont-generator   ---Генератор Шрифтов,там собственно можно и грифты скачать а потом сгенерировать
https://developer.mozilla.org/en-US/docs/Web/CSS/list-style-type   ---Выбор различный list-style-type для списков 
http://www.colorhexa.com/  ---Преобразование цвета онлайн,к примеру из шестнадцатеричной модели в rgb
www.morguefile.com   ---Бесплатные коллекций изображений
http://openphoto.net/gallery/browse.html	---Бесплатные коллекций изображений	
http://search.creativecommons.org  	---Бесплатные коллекций изображений но тут есть аудио и видео					
https://www.flickr.com/creativecommons ---Бесплатные коллекций изображений (но тут есть лицензия Creative Commons)
http://fontello.com/   ---Иконки для списков
http://lea.verou.me/css3patterns/#  ---Фон с помощью градиентов
http://www.standardista.com/CSS3gradients/flags.html  --Флаги нарисованные Градиентами
http://www.colorzilla.com/gradient-editor/ ---Генератор Градиентов
http://css3button.net/  --Генератор кнопок(создать кнопку)
http://purecssmenu.com/  --Генератор всплывающих окон,можно сделать быстро с нуля
http://red-team-design.com/css3-animated-dropdown-menu/  --!!!НУЖНО РАЗОБРАТСЯ ПОСЛЕ ПРОЧТЕНИЯ КНИЖКИ,ПРО ПОДСПИСКИ
http://spritepad.wearekiss.com/  --Сайт для СПРАЙТОВ
https://learn.javascript.ru/css-sprite  --смысл(как научится) СПРАЙТОВ
www.the-art-of-web.com/css/timing-function/  ---Очень красивые примеры анимации и значения,свойства tansition-timing-function
http://matthewlein.com/ceaser/  --Создания графиков для регулирования скорости анимации(для свойства tansition-timing-function)
http://devdocs.io/css/--- вся документация разработчика(AngularJs,Javasrcipt,CSS...)
fitvidsjs.com --Jquery,что бы видео было адаптивным








																			BOOTSTRAP
Собственно это просто набор классов CSS,нужно только разобраться что дает тот или иной класс. Итак:
.container-Просто блок максимальная ширина 1170px,будет по центру(он адаптивен,как собствеено все в Bootstrap)
.container-fluid---Резиновый блок,растагивается на всю ширину экрана
.col-md-offset-2 ---offset(для любого .col) отступ,тоисть в данном примере 2 колонки(из 12 всего) будет отступа
.col-md-5 hidden-md -при расшерении экрана (@media (max-width:992px) and (min-width:768px)) этот промежуток будет прятатся(display:none;)
.col-md-5 hidden-md visible-lg ---При медиуме скрывается при большом экране становится видным
<div class="navbar navbar-default"></div>---default -серый фон,inverse-черный фон
<ul class="nav navbar-menu"></ul>---navbar-menu -это выпадающий список по вертекали(как в мобильной или планшетной версии)и занимает все место по горизонтали
<ul class="nav navbar-nav"></ul>--Список по горизонтали
<div class="navbar navbar-inverse navbar-fixed-top"></div>--разместить сверху фиксированно,есть Так же bottom
<div class="navbar navbar-inverse navbar-static-top"></div>--растягивает на всю ширину и весь блок по центру,но если данный блок находидся в нутри бругого блока он не станет шире него
//nav nav-pills -- Второстепенная навигация,используется если уже есть навигация на сайте,а эта будет второстепенной																
// <span class="badge">22</span>  -Например есть товар Арбузы и этот клас рядом показывает 22,говоря сколько есть тем самым 
<img srс="images/1.png" class="img-responsive"> //Создание отзывчивого изображения: в результате изображение будет растягиваться до ширины родительского элемента

																Позиционирование Навигации
<div class="navbar navbar-inverse navbar-fixed-top">Здесь все остальное</div> //navbar-fixed-top Делает навигацио вверху и растягует на всю ширину,в данном случае черным цветом 							
<div class="navbar navbar-inverse navbar-fixed-bottom">   //Позиционирует внизу 
<div class="navbar navbar-inverse navbar-static-top"> //Растягуется на всю ширину,только не fixed, Не растянется если данный блок назходится в блоке container который не дает ему растянутся выше 1170px

																Выпадающее меню
<a href="#">Пункт 2  <b class="caret"></b></a>  // <b class="caret"></b> - Данный класс создает иконку с треуголником показывающий,что на этой ссылке есть выпадающее меню 																
<li class="divider"></li>  //Разделитель 																
																Пример выпадающего меню при клике
<div class="navbar navbar-inverse navbar-static-top">
	<div class="container">
		<div class="navbar-header">
			<a class="navbar-brand" href="#">Название компании</a>
				<button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#responsive-menu">
					<span class="sr-only">Открыть навигацию</span>
					<span class="icon-bar"></span>
					<span class="icon-bar"></span>
					<span class="icon-bar"></span>
				</button>
		</div>
		<div class="collapse navbar-collapse " id="responsive-menu">
			<ul class="nav navbar-nav">
				<li><a href="#">Пункт 1</a></li>
				<li class="dropdown">
					<a href="#" class="dropdown-toggle" data-toggle="dropdown">Пункт 2  <b class="caret"></b></a>
						<ul class="dropdown-menu"> 
							<li><a href="#">Пункт 1</a></li>
							<li><a href="#">Пункт 2</a></li>
							<li><a href="#">Пункт 3</a></li>
							<li class="divider"></li>
							<li><a href="#">Пункт 4</a></li>
						</ul>
				</li>						
				<li><a href="#">Пункт 3</a></li>
				<li><a href="#">Пункт 4</a></li>
			</ul>
		</div>
	</div>
</div>
//к сожаление нету 3й колонки выпадающего меню только 2

												
																Пример слайдера
/*
<a href="#carousel" class="left carousel-control" data-slide="prev"> #carousel - должен совпадать с id всего слайдера, data-slide="prev" показует куда должен листать при клике   
		<span class="glyphicon glyphicon-chevron-left"></span>
</a>

<li class="active" data-target="#carousel" data-slide-to="0"></li>  class="active" по умолчанию будет активным, data-target="#carousel" при нажатии будет листать слайдер с индекатором #carousel, data-slide-to="0" - направление куда листается начинается с 0 
*/																
																
<div id="carousel" class="carousel slide">
	<!--Индикаторы слайдов-->
	<ol class="carousel-indicators">
		<li class="active" data-target="#carousel" data-slide-to="0"></li>
		<li data-target="#carousel" data-slide-to="1"></li>
		<li data-target="#carousel" data-slide-to="2"></li>
	</ol>
	<!--Слайды-->
	<div class="carousel-inner">
		<div class="item active">
			<img src="images/1.jpg" alt="">
			<div class="carousel-caption">
				<h3>Первый слайд</h3>
				<p>Описание первого слайда</p>
			</div>
		</div>
		<div class="item">
			<img src="images/2.jpg" alt="">
			<div class="carousel-caption">
				<h3>Второй слайд</h3>
				<p>Описание первого слайда</p>
			</div>
		</div>
		<div class="item">
			<img src="images/3.jpg" alt="">
			<div class="carousel-caption">
				<h3>Третий слайд</h3>
				<p>Описание первого слайда</p>
			</div>
		</div>
	</div>
	<!--Стрелки переключения слайдов-->
	<a href="#carousel" class="left carousel-control" data-slide="prev"> 
		<span class="glyphicon glyphicon-chevron-left"></span>
	</a>
	<a href="#carousel" class="right carousel-control" data-slide="next">
		<span class="glyphicon glyphicon-chevron-right"></span>
	</a>
</div>
																	Для автозапуска слайдера
  <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script> 
    <script src="js/bootstrap.js"></script> // в этом файле — JS-плагины Bootstrap (в их числе и carousel.js)
    <script type="text/javascript">
    	!function ($) {
    		$(function(){
    			$('#carousel').carousel()
    		})
    	}(window.jQuery)
    </script>
	
																	Шрифтовые иконки 
//http://getbootstrap.com/components/  где можно посмотреть иконки
//http://www.w3schools.com/bootstrap/bootstrap_ref_comp_glyphs.asp
//https://fortawesome.github.io/Font-Awesome/  Тут очень много иконок,просто тьма 
	
<p><i class=" glyphicon glyphicon-asterisk"></i></p>  //Иконки векторные,то есть их можно увеличить(.glyphicon{font-size: 400px;}) и все будет отлично выглядеть 	
	
	
																	Оформление кнопок 
//Это просто способ оформление кнопок, btn-link выглядит как обычная кнопка только без цвета и немного приближена к другим из списка 
// Данные классы Можно использовать и в элементах формах (input,button...)
<a href="#" class="btn btn-default">Кнопка</a>
<a href="#" class="btn btn-primary">Кнопка</a>
<a href="#" class="btn btn-success">Кнопка</a>
<a href="#" class="btn btn-warning">Кнопка</a>
<a href="#" class="btn btn-info">Кнопка</a>
<a href="#" class="btn btn-danger">Кнопка</a>
<a href="#" class="btn btn-link">Кнопка</a>
	
																	Размеры кнопок 
<p>
	<a href="#" class="btn btn-primary btn-lg">Кнопка</a>
	<a href="#" class="btn btn-primary">Кнопка</a>
	<a href="#" class="btn btn-primary btn-sm">Кнопка</a>
	<a href="#" class="btn btn-primary btn-xs">Кнопка</a>
</p>
	
//	btn-block - Принимает всю ширину родительского блока 
// active можно добавить,и постоянно будет вид кнопки как будто на нее нажали
// disabled - отключает кнопку и делает ее светлее 
<p>
	<a href="#" class="btn btn-primary btn-lg btn-block">Кнопка</a>
</p>	
	
																	Групировка кнопок
<div class="container">
	<div class="row">
		<div class="btn-group">
			<a href="#" class="btn btn-default">Кнопка</a>
			<a href="#" class="btn btn-primary">Кнопка</a>
			<a href="#" class="btn btn-success">Кнопка</a>
		</div>
	</div>
</div>																		

//Или можно например групировать значки нужно подключить https://fortawesome.github.io/Font-Awesome/

<div class="container">
	<div class="row">
		<div class="btn-group">
			<a href="#" class="btn btn-default"><i class="fa fa-spinner"></i></a>
			<a href="#" class="btn btn-primary"><i class="fa fa-file"></i></a>
			<a href="#" class="btn btn-success"><i class="fa fa-download"></i></a>
		</div>
	</div>
</div>																	
//Они все разного цвета,можно поменять скажим все 3 ссылки на btn-success и будет одним цветом 
	
																	Чтобы каждая группа кнопок была с новой строки 
//Так как при добавлении новых групп кнопок они все идут в одну строку,чтобы каждая новая группа начиналась с новой строки нужно добавить клас btn-toolbar 																
																	
<div class="container">
	<div class="row">
		<div class="btn-toolbar">
			<div class="btn-group">
				<a href="#" class="btn btn-default"><i class="fa fa-spinner"></i></a>
				<a href="#" class="btn btn-primary"><i class="fa fa-file"></i></a>
				<a href="#" class="btn btn-success"><i class="fa fa-download"></i></a>
			</div>
			<div class="btn-group">
				<a href="#" class="btn btn-default"><i class="fa fa-spinner"></i></a>
				<a href="#" class="btn btn-primary"><i class="fa fa-file"></i></a>
				<a href="#" class="btn btn-success"><i class="fa fa-download"></i></a>
			</div>
		</div>
		<div class="btn-toolbar">
			<div class="btn-group">
				<a href="#" class="btn btn-default"><i class="fa fa-spinner"></i></a>
				<a href="#" class="btn btn-primary"><i class="fa fa-file"></i></a>
				<a href="#" class="btn btn-success"><i class="fa fa-download"></i></a>
			</div>
			<div class="btn-group">
				<a href="#" class="btn btn-default"><i class="fa fa-spinner"></i></a>
				<a href="#" class="btn btn-primary"><i class="fa fa-file"></i></a>
				<a href="#" class="btn btn-success"><i class="fa fa-download"></i></a>
			</div>
		</div>
	</div>
</div>	

																	Увеличить размер групп кнопок 
																	
<div class="container">
	<div class="row">
		<div class="btn-toolbar">
			<div class="btn-group btn-group-lg">
				<a href="#" class="btn btn-default"><i class="fa fa-spinner"></i></a>
				<a href="#" class="btn btn-primary"><i class="fa fa-file"></i></a>
				<a href="#" class="btn btn-success"><i class="fa fa-download"></i></a>
			</div>
			<div class="btn-group btn-group-lg">
				<a href="#" class="btn btn-default"><i class="fa fa-spinner"></i></a>
				<a href="#" class="btn btn-primary"><i class="fa fa-file"></i></a>
				<a href="#" class="btn btn-success"><i class="fa fa-download"></i></a>
			</div>
		</div>
		<div class="btn-toolbar">
			<div class="btn-group btn-group-lg">
				<a href="#" class="btn btn-default"><i class="fa fa-spinner"></i></a>
				<a href="#" class="btn btn-primary"><i class="fa fa-file"></i></a>
				<a href="#" class="btn btn-success"><i class="fa fa-download"></i></a>
			</div>
			<div class="btn-group btn-group-lg">
				<a href="#" class="btn btn-default"><i class="fa fa-spinner"></i></a>
				<a href="#" class="btn btn-primary"><i class="fa fa-file"></i></a>
				<a href="#" class="btn btn-success"><i class="fa fa-download"></i></a>
			</div>
		</div>
	</div>
</div>	
									
																	Растянуть группу кнопок на всю допустимую ширину 
<div class="btn-group btn-group-justified">
	<a href="#" class="btn btn-default"><i class="fa fa-spinner"></i></a>
	<a href="#" class="btn btn-primary"><i class="fa fa-file"></i></a>
	<a href="#" class="btn btn-success"><i class="fa fa-download"></i></a>
</div>									
									
																	Сгруппировать группу кнопок по вертикали 

<div class="btn-group btn-group-vertical">
	<a href="#" class="btn btn-default"><i class="fa fa-spinner"></i></a>
	<a href="#" class="btn btn-primary"><i class="fa fa-file"></i></a>
	<a href="#" class="btn btn-success"><i class="fa fa-download"></i></a>
</div>
									
									
																	Кнопки с выпадающим меню
<div class="container">	
	<div class="row">
		<div class="col-md-6">
			<div class="btn-group">
				<button class="btn btn-default dropdown-toggle" data-toggle="dropdown">
					Выпадающее меню<span class="caret"></span>
				</button>
				<ul class="dropdown-menu">
					<li><a href="#">Ссылка</a></li>
					<li><a href="#">Ссылка</a></li>
					<li><a href="#">Ссылка</a></li>
					<li><a href="#">Ссылка</a></li>
				</ul>
			</div>
		</div>
		<div class="col-md-6">
		
		</div>
	</div>
</div>

//	<div class="btn-group dropup">	 Выпадающее меню будет выпадать наверх 							
// 	<div class="btn-group pull-right"> Сдвигает группу кнопок вправо, float: right; 								
//	<ul class="dropdown-menu dropdown-menu-left">  Прижимает выпадающий список влево									
//	<ul class="dropdown-menu dropdown-menu-right">  Прижимает выпадающий список вправо									
									
																		Две кнопки с выпадающим меню 

<div class="container">	
	<div class="row">
		<div class="col-md-6">
			
		</div>
		<div class="col-md-6">
			<div class="btn-group pull-right">
				<button class="btn btn-success " >
					Выпадающее меню
				</button>
				<button class="btn btn-success dropdown-toggle" data-toggle="dropdown">
					<span class="caret"></span>
				</button>
				<ul class="dropdown-menu dropdown-menu-left">
					<li><a href="#">Ссылка</a></li>
					<li><a href="#">Ссылка</a></li>
					<li><a href="#">Ссылка</a></li>
					<li><a href="#">Ссылка</a></li>
				</ul>
			</div>
		</div>
	</div>
</div>

																		Создание вкладок (tabs)

<div class="tabs">
	<ul class="nav nav-tabs">
		<li class="active"><a href="#tab-1" data-toggle="tab">Вкладка 1</a></li>
		<li><a href="#tab-2" data-toggle="tab">Вкладка 2</a></li>
		<li><a href="#tab-3" data-toggle="tab">Вкладка 3</a></li>
	</ul>
	<div class="tab-content">
		<div class="tab-pane active fade in" id="tab-1">
			<p>Параграф с текстом 1</p>
		</div>
		<div class="tab-pane fade" id="tab-2">
			<p>Параграф с текстом 2</p>
		</div>
		<div class="tab-pane fade" id="tab-3">
			<p>Параграф с текстом 3</p>
		</div>
	</div>
</div>																		

																		Создание спойлера 
																		
<a href="#spoiler-1" data-toggle="collapse" class="btn btn-primary">Открыть спойлер</a>
<div class="collapse"  id="spoiler-1">
	<div class="well">
		<p>Параграф с текстом</p>
	</div>
</div>

														Создание спойлера с + или - в зависимости от состояния

<a href="#spoiler-1" data-toggle="collapse" class="btn btn-primary spoiler collapsed">Открыть спойлер</a>
<div class="collapse"  id="spoiler-1">
	<div class="well">
		<p>Параграф с текстом</p>
	</div>
</div>													
														
a.spoiler:after{
	content: " [-]";
}

a.spoiler.collapsed:after {
	content: " [+]";
}


																		Аккордион 
//data-parent="#accordion" Ставится для того,чтобы при нажатии на один блок другой закрывался
//	<div class="panel-collapse collapse in" id="collapse-1"> in для того чтобы по умолчанию был открыт																	
//	<div class="panel panel-default"> - можно поставить panel-success, panel-primery ...разница в цвете 
																		
<div id="accordion" class="panel-group">
					<div class="panel panel-default">
						<div class="panel-heading">
							<h4 class="panel-title">
								<a href="#collapse-1" data-toggle="collapse" data-parent="#accordion">Открыть первый Аккордеон</a>
							</h4>
						</div>
						<div class="panel-collapse collapse in" id="collapse-1">
							<div class="panel-body">
								<p>Любой контент Любой контент Любой контент Любой контент Любой контент Любой контент Любой контент Любой контент Любой контент Любой контент </p>
							</div>
						</div>
					</div>
					<div class="panel panel-default">
								<div class="panel-heading">
							<h4 class="panel-title">
								<a href="#collapse-2" data-toggle="collapse" data-parent="#accordion">Открыть второй Аккордеон</a>
							</h4>
						</div>
						<div class="panel-collapse collapse" id="collapse-2">
							<div class="panel-body">
								<p>Любой контент Любой контент Любой контент Любой контент Любой контент Любой контент Любой контент Любой контент Любой контент Любой контент </p>
							</div>
						</div>
					</div>
					<div class="panel panel-default">
								<div class="panel-heading">
							<h4 class="panel-title">
								<a href="#collapse-3" data-toggle="collapse" data-parent="#accordion">Открыть третий Аккордеон</a>
							</h4>
						</div>
						<div class="panel-collapse collapse" id="collapse-3">
							<div class="panel-body">
								<p>Любой контент Любой контент Любой контент Любой контент Любой контент Любой контент Любой контент Любой контент Любой контент Любой контент </p>
							</div>
						</div>
					</div>
				</div>
															
																		
														
																			Модальное окно 
//При клике на кнопку будет открыватся окно
//Чтобы сделать модальное окно больше можно  <div class="modal-dialog modal-lg"> или modal-sm 

																			
<button class="btn btn-success" type="button" data-toggle="modal" data-target="#modal-1">Открыть модальное окно</button>														
														
	<div class="modal fade" id="modal-1">
		<div class="modal-dialog ">
			<div class="modal-content">
				<div class="modal-header">
					<button class="close" type="button" data-dismiss="modal">
						<i class="fa fa-close"></i>
					</button>
					<h4 class="modal-title">Название окна</h4>
				</div>
				<div class="modal-body">
					<p>Модальное окно</p>
				</div>
				<div class="modal-footer">
					<button class="btn btn-danger" type="button" data-dismiss="modal">Закрыть</button>
				</div>
			</div>
		</div>
	</div>														
														
														
																	Форма авторизации в навигации
							
<div class="collapse navbar-collapse " id="responsive-menu">
				<ul class="nav navbar-nav">
					<li><a href="#">Пункт 1</a></li>
					<li class="dropdown">
						<a href="#" class="dropdown-toggle" data-toggle="dropdown">Пункт 2  <b class="caret"></b></a>
						<ul class="dropdown-menu"> 
							<li><a href="#">Пункт 1</a></li>
							<li><a href="#">Пункт 2</a></li>
							<li><a href="#">Пункт 3</a></li>
							<li class="divider"></li>
							<li><a href="#">Пункт 4</a></li>
						</ul>
					</li>						
					<li><a href="#">Пункт 3</a></li>
					<li><a href="#">Пункт 4</a></li>
				</ul>
				<form action="" class="navbar-form navbar-right">
					<div class="form-group">
						<input type="text" placeholder="E-mail" value="" class="form-control">
					</div>
					<div class="form-group">
						<input type="password" placeholder="Password" value="" class="form-control">
					</div>
					<button class="btn btn-primary" type="button">
						<i class="fa fa-sign-in"></i> ВОЙТИ
					</button>
				</form>
			</div>

			
																	Индикаторы прогресса

<div class="container">
		<div class="row">
			<div class="progress">
				<div class="progress-bar progress-bar-primery" style="
					min-width: 2%;
					width: 20%;
				">
					0%
				</div><div class="progress-bar progress-bar-success" style="
					min-width: 2%;
					width: 20%;
				">
					0%
				</div><div class="progress-bar progress-bar-warning" style="
					min-width: 2%;
					width: 20%;
				">
					0%
				</div>
			</div>
			<div class="progress">
				<div class="progress-bar progress-bar-success progress-bar-striped active" style="
					min-width: 2%;
					width: 50%;
				">
					0%
				</div>
			</div>
		</div>
	</div>																

																Создание кнопок для перехода по страницам
																
<nav class="text-center">
			<ul class="pagination">
				<li class="disabled">
					<a href="#">
						<i class="fa fa-chevron-left"></i>
						<i class="fa fa-chevron-left"></i>
					</a>
				</li>
				<li class="disabled">
					<a href="#">
						<i class="fa fa-chevron-left"></i>
					</a>
				</li>
				<li class="active"><a href="#">1</a></li>
				<li><a href="#">2</a></li>
				<li><a href="#">3</a></li>
				<li><a href="#">4</a></li>
				<li><a href="#">5</a></li>
				<li><a href="#">6</a></li>
				<li>
					<a href="#">
						<i class="fa fa-chevron-right"></i>
					</a>
				</li>
				<li>
					<a href="#">
						<i class="fa fa-chevron-right"></i>
						<i class="fa fa-chevron-right"></i>
					</a>
				</li>
			</ul>
		</nav>
	
	
//class="text-center" - выравнивает по центру(text-align: center;)	
	
																	Cоздание кнопок Вперед Назад
<nav>
	<ul class="pager">
		<li class="previous"><a href="#">&larr; Назад</a></li>
		<li class="next"><a href="#">Вперед &rarr;</a></li>
	</ul>
</nav>

//	&larr; - html код,расшифровуется как & - мы вводим код html, l -left, arr - arrow,точно также и с &rarr; только там правая стрелка
//class="previous" сдвигает влево (float: left;)
//class="next" сдвигает впрвао (float: right;)
														

														
																	Хлебные крошки 
				
<div class="container">
	<ol class="breadcrumb">
		<li>
			<a href="#">
				<i class="fa fa-home"></i>
			</a>
		</li>
		<li><a href="#">Блог</a></li>
		<li><a href="#">Категория</a></li>
		<li сlass="active">Пост</li>
	</ol>
</div>
														
/*
	Чтобы поменять иконку с "/" на скажем микрофон нужно:
1.Установить скажем Font Awesome 
2.Выбрать иконку на этом сайте,и в консоле глянуть что за символ стоит у нее в контенте (:before),например content:content: "\f0a1";
3.В css написать:

.breadcrumb > li + li:before {
	content: "\f0a1";
	font-family: "FontAwesome";
} 
*/														

																	Подсказки

<a href="#" class="btn btn-default" data-toggle="tooltip" title="Подсказка">Кнопка</a>	
																
$(document).ready(function(){
	$("[data-toggle='tooltip']").tooltip();
});

//Нужно указать data-toggle="tooltip" title="Подсказка"	 и написать jQuery запрос

																Управление местополежнием подсказок

<a href="#" class="btn btn-default" data-toggle="tooltip" data-placement="left" title="Подсказка">Кнопка</a>																
//data-placement="left" может быть 4: top,left,right,bottom, по умолчанию стоит top
							
									
									
																	Всплывающие окна 
																	
<a href="#" class="btn btn-primary" data-toggle="popover" title="Заголовок" data-content="Текст окна или какое-нибудь повествование">Кнопка</a>										
										
$(document).ready(function(){
	$("[data-toggle='popover']").popover();
});
									
//Так же можно менять место положение с помощью data-placement=""
//Так же можно управлять состояниям например при наведении data-trigger="hover" будет отображатся всплывающее окно 



																		Футер
																		
<div class="container">
	<hr>
    <div class="row">
            <div class="col-xs-3">
                <ul class="list-unstyled">
                    <li>GitHub<li>
                    <li><a href="#">About us</a></li>
                    <li><a href="#">Blog</a></li>
                    <li><a href="#">Contact & support</a></li>
                    <li><a href="#">Enterprise</a></li>
                    <li><a href="#">Site status</a></li>
                </ul>
            </div>
            <div class="col-xs-3">
                <ul class="list-unstyled">
                    <li>Applications<li>
                    <li><a href="#">Product for Mac</a></li>
                    <li><a href="#">Product for Windows</a></li>
                    <li><a href="#">Product for Eclipse</a></li>
                    <li><a href="#">Product mobile apps</a></li>
                </ul>
            </div>
            <div class="col-xs-3">
                <ul class="list-unstyled">
                    <li>Services<li>
                    <li><a href="#">Web analytics</a></li>
                    <li><a href="#">Presentations</a></li>
                    <li><a href="#">Code snippets</a></li>
                    <li><a href="#">Job board</a></li>
                </ul>
            </div>
            <div class="col-xs-3">
                <ul class="list-unstyled">
                    <li>Documentation<li>
                    <li><a href="#">Product Help</a></li>
                    <li><a href="#">Developer API</a></li>
                    <li><a href="#">Product Markdown</a></li>
                    <li><a href="#">Product Pages</a></li>
                </ul>
            </div>
    </div>
    <hr>
    <div class="row">
            <div class="col-xs-8">
                <ul class="list-unstyled list-inline pull-left">
                    <li><a href="#">Terms of Service</a></li>
                    <li><a href="#">Contact Us</a></li>
                    <li><a href="#">Privacy</a></li>
                </ul>
            </div>
            <div class="col-xs-4">
                <p class="text-muted pull-right">© 2015 Company Name. All rights reserved</p>
            </div>
        </div>
	</div>					
									
	

//bootsnipp.com/	--- Сайт где можно взять кучу готового кода по Bootstrap

											Позиционирование 
<div class="row">
  <div class="col-md-9 col-md-push-3">.col-md-9 .col-md-push-3</div>
  <div class="col-md-3 col-md-pull-9">.col-md-3 .col-md-pull-9</div>
</div>

//.col-md-push-3  -- Двигает на 3 клетки вправо
//col-md-pull-9  -- Двигает на 9 клетки влево 

									Классы и теги и документации:
http://getbootstrap.com/css/
												
											
//http://getbootstrap.com/css/#type

h1 - Данный класс делает текст 36px
h2 -  30px
... каждый раз на 6px меньше 
h6 - 12px

Так же можно уменьшать текст используя тег <small></small> или классом small 


																							
lead  - Данный класс делает размер текст 21px
<mark></mark>  - Данный тег подсвечивает текст,выделяет его желтоватым фоном 
<del></del>  - Зачеркивает текст,(который был удален) 
<s></s>  - Зачеркивает текст,(который больше не актуален)
<ins></ins>  - Подчеркивает текст для документов
<u></u>  - Подчеркивает текст
<em>rendered as italicized text</em>  - тоже самое что и font-style: italic;

											Выравнивание текста 
<p class="text-left">Left aligned text.</p>
<p class="text-center">Center aligned text.</p>
<p class="text-right">Right aligned text.</p>
<p class="text-justify">Justified text.</p>
<p class="text-nowrap">No wrap text.</p>

											Трансформация текста 
<p class="text-lowercase">Lowercased text.</p>
<p class="text-uppercase">Uppercased text.</p>
<p class="text-capitalize">Capitalized text.</p>

											Абревиатуры
<abbr title="This if fantastic!">Gav-gav</abbr>   --- при наведении на "Gav-gav" будет появляться title "This if fantastic!"
<abbr title="This if fantastic!" class="initialism">Gav-gav</abbr>   --- делает uppercase и меняет шрифт

											Адресса
<address>
  <strong>Twitter, Inc.</strong><br>
  1355 Market Street, Suite 900<br>
  San Francisco, CA 94103<br>
  <abbr title="Phone">P:</abbr> (123) 456-7890
</address>

<address>
  <strong>Full Name</strong><br>
  <a href="mailto:#">first.last@example.com</a>
</address>											

										
												Blockquotes	
Для выделения какого-то участка текста,слева будет рамка и отступ от текста,очень красиво смотрится 
<blockquote>
  <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer posuere erat a ante.</p>
</blockquote>

или так 

<blockquote>
  <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer posuere erat a ante.</p>
  <footer>Someone famous in <cite title="Source Title">Source Title</cite></footer>
</blockquote>

<blockquote class="blockquote-reverse"> 
  ...
</blockquote>

//blockquote-reverse  - данный класс сдвигает весь контент вправо 

												Списки 
<ul class="list-unstyled">
		<li>Lorem ipsum dolor sit amet</li>
		<li>Consectetur adipiscing elit</li>
		<li>Integer molestie lorem at massa</li>
		<li>List <ul>
			<li>Music</li>
			<li>Show</li>
			<li>Video</li>
		</ul></li>
		<li>Faucibus porta lacus fringilla vel</li>
		<li>Aenean sit amet erat nunc</li>
		<li>Eget porttitor lorem</li>
	</ul>

list-unstyled  - Данный класс уверает list-style у первого списка (у второго они останутся)


											Правильная вставка кода
<p>For example, <code>&lt;section&gt;</code> should be wrapped as inline.</p>  


To switch directories, type <kbd>cd</kbd> followed by the name of the directory.<br>
To edit settings, press <kbd><kbd>ctrl</kbd> + <kbd>,</kbd></kbd> 

<kbd></kbd>  - Делает как клавишу 

<pre>&lt;p&gt;Sample text here...&lt;/p&gt;</pre>  - Делает очунь крутую подсветку,часто применяется как пример для кода на сайтах 
<var>y</var> = <var>m</var><var>x</var> + <var>b</var> - Для показа переменных 
<samp>This text is meant to be treated as sample output from a computer program.</samp>  //Для описания кода можно использовать 


												Таблици 
<table class="table table-striped">
		<thead>
			<tr>
			<th>#</th>
			<th>First Name</th>
			<th>Last Name</th>
			<th>Username</th>
		</tr>
		</thead>
		<tbody>
			<tr>
				<td>1</td>
				<td>Mark</td>
				<td>Otto</td>
				<td>@Mdo</td>
			</tr>
			<tr>
				<td>2</td>
				<td>Jacodb</td>
				<td>Thornton</td>
				<td>@Fat</td>
			</tr><tr>
				<td>3</td>
				<td>Larry</td>
				<td>the Bird</td>
				<td>@twitter</td>
			</tr>
		</tbody>
	</table>
	
table - Данный класс превращает простую таблицу в крассивую 
table-striped  - Добавляет серый цвет для четных нечетных
table-bordered  - Добавляет рамку 
table-hover - При наведении будет серая подцветка 
table-condensed  - Делает ячейки более компактные,убирая пустые места  

Так же к каждой строке или ячейке можно вставить определенное состояние,например:
tr class="success" или active,info,warning,danger...

											Кнопки 
<a class="btn btn-default" href="#" role="button">Link</a>
<button class="btn btn-default" type="submit">Button</button>
<input class="btn btn-default" type="button" value="Input">
<input class="btn btn-default" type="submit" value="Submit">

Лучше использовать button - это рекомендация от разработчиков Bootstrap



											Картинки 
<p class="text-center"><img src="images/alice.jpg" alt="alice" class="img-responsive center-block"></p>


img-responsive   - Делает картинку адаптивной
center-block  - Делает картинку по центру 
text-center   - Выравнивает текст по центру(Что бы картинка была по центру можно и без него)
img-rounded   - Добавляет border-radius 6px
img-circle    - Добавляет border-radius 50%
img-thumbnail  - Добавляет небольшую серую рамку поверх картинки 



										Вспомогательные классы 
getbootstrap.com/css/#helper-classes

Можно делать текст каким-то цветом:
<p class="text-muted">...</p>
<p class="text-primary">...</p>
<p class="text-success">...</p>
<p class="text-info">...</p>
<p class="text-warning">...</p>
<p class="text-danger">...</p>

Тоже самое можно и с фоном:

<p class="bg-primary">...</p>
<p class="bg-success">...</p>
<p class="bg-info">...</p>
<p class="bg-warning">...</p>
<p class="bg-danger">...</p>


<button type="button" class="close" aria-label="Close"><span aria-hidden="true">&times;</span></button>
//Создает крестик(закрыть окно)

<span class="caret"></span>   //кавычка вниз при раскрывающем списке 

Быстрые float:
<div class="pull-left">...</div>
<div class="pull-right">...</div>

/*
	.pull-left {
	  float: left !important;
	}
	.pull-right {
	  float: right !important;
	}
*/

center-block - центрирует по центру любой блок 

Отмена float:
<div class="clearfix">...</div>

/*
	.clearfix() {
	  &:before,
	  &:after {
		content: " ";
		display: table;
	  }
	  &:after {
		clear: both;
	  }
	}
*/


Скрывать/показывать контент:

<div class="show">...</div>
<div class="hidden">...</div>

/*
	.show {
	  display: block !important;
	}
	.hidden {
	  display: none !important;
	}
*/

или прятать текст : 
<h1 class="text-hide">Custom heading</h1>



Так же можно взависимости от ширины экрана скрывать/показывать контент:
http://getbootstrap.com/css/#responsive-utilities

//Лучше зайти по ссылке и посмотреть таблицу 


									Выделение картинок 
<div class="col-md-3">
	<a href="#" class="thumbnail"><img  src="images/alice.jpg" alt="alice" class="img-responsive "></a>	
</div>

thumbnail  - При наведении на ссылку(картинку) красиво выделяется 

Так же этим классом можнно группировать картинку и весь контент под ней:
<div class="col-md-3 thumbnail">
 	<a href="#" class="thumbnail"><img  src="images/alice.jpg" alt="alice" class="img-responsive "></a>	
	<h3 class="h3">Good name of page</h3>
	<p>nwsoiwi gav Good name of pageGood name of pageGood name of page</p>
	<button type="button " class="button btn btn-primary">Button</button>
	<button type="button " class="button btn btn-default">Button</button>
 </div> 


										Alert 
Используется для показа сообщения 
 
<div class="alert alert-success" role="alert">...</div>
<div class="alert alert-info" role="alert">...</div>
<div class="alert alert-warning" role="alert">...</div>
<div class="alert alert-danger" role="alert">...</div>

Так же можно использовать ссылки в эти сообщения:

<div class="alert alert-success" role="alert">
  <a href="#" class="alert-link">...</a>
</div>


Обьединение ссылок в группы:

<div class="list-group">
  <a href="#" class="list-group-item active">
    Cras justo odio
  </a>
  <a href="#" class="list-group-item">Dapibus ac facilisis in</a>
  <a href="#" class="list-group-item">Morbi leo risus</a>
  <a href="#" class="list-group-item">Porta ac consectetur ac</a>
  <a href="#" class="list-group-item">Vestibulum at eros</a>
</div> 

Так же можно с list-group обьединять кнопки или просто список с текстом или что-то посложнее:

<ul class="list-group">
  <li class="list-group-item list-group-item-success">Dapibus ac facilisis in</li>
  <li class="list-group-item list-group-item-info">Cras sit amet nibh libero</li>
  <li class="list-group-item list-group-item-warning">Porta ac consectetur ac</li>
  <li class="list-group-item list-group-item-danger">Vestibulum at eros</li>
</ul>




											Пример работы плагина ScrollSpy
  <body data-spy="scroll" data-target="#myNavbar" data-offset="70">
        <nav id="myNavbar" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
            <div class="container">
                <!-- Brand and toggle get grouped for better mobile display -->
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbarCollapse"> 
                        <span class="sr-only">Toggle navigation</span> 
                        <span class="icon-bar"></span> 
                        <span class="icon-bar"></span> 
                        <span class="icon-bar"></span> 
                    </button>
                    <a class="navbar-brand" href="#">Scrollspy</a>
                </div>
                <!-- Collection of nav links, forms, and other content for toggling -->
                <div class="collapse navbar-collapse" id="navbarCollapse">
                    <ul class="nav navbar-nav">
                        <li class="active"><a href="#section1">Section 1</a></li>
                        <li><a href="#section2">Section 2</a></li>
                        <li><a href="#section3">Section 3</a></li>
                        <li class="dropdown"><a href="#" class="dropdown-toggle" data-toggle="dropdown">Section 4<b class="caret"></b></a>
                            <ul class="dropdown-menu">
                                <li><a href="#section4dot1">Section 4.1</a></li>
                                <li><a href="#section4dot2">Section 4.2</a></li>
                                <li><a href="#section4dot3">Section 4.3</a></li>
                            </ul>
                        </li>
                        <li><a href="#section5">Section 5</a></li>
                    </ul>
                </div>
            </div>
        </nav>
        <div class="container">
            <div id="section1">
                <h2>Section 1</h2>
                <p>This is section 1 content…</p>
            </div>
            <hr>
            <div id="section2">
                <h2>Section 2</h2>
                <p>This is section 2 content…</p>
            </div>
            <hr>
            <div id="section3">
                <h2>Section 3</h2>
                <p>This is section 3 content…</p>
            </div>
            <hr>
            <h2>Section 4</h2>
            <p>This is section 4 content</p>
            <div id="section4dot1">
                <h3>Section 4.1</h3>
                <p>This is section 4.1 content…</p>
            </div>
			<div id="section4dot2">
                <h3>Section 4.2</h3
                <p>This is section 4.2 content…</p>
            </div>
            <div id="section4dot3">
                <h3>Section 4.3</h3>
                <p>This is section 4.3 content…</p>
            </div>
            <hr>
            <div id="section5">
                <h2>Section 5</h2>
                <p>This is section 5 content…</p>
            </div>
        </div>
    </body>












														JAVASCRIPT-скриптовый язык программирование,написанный на тексте и выполняется Ентерпритатором
clear() --очистить все в консоли																					
4.4 //Дробрые числа через точку
.99 --Это 0.99
"that's good" --Если начинается с одного вида кавычки " то в нутри должна быть другая кавычка '
"that\"s good""--\Екранирование,если используется кавыички одного типа и мы хотим чтобы внутри били теже кавычки нужно их екранировать
"Двухстрочная строка?\nДа это просто"--\n переносит на новую строку, Да это просто перенесется
"Multi \
Line\
string";//Екранировать перенос строки в результате все будет на одной линии,Line и string будут слитно потому, что \ стоит к Line впритык,и если мы поставим пробел после  то будет ошибка
var _1   //var- это обьявление переменной,должно начинатся не с цыфры, _1 cама переменная
Переменные -это контейнеры для хранения значений
										Примеры того как можно записывать	Можно записывать:
															var  personsCount, lastIndex, topNavigation;

															var  personsCount, 
															lastIndex, 
															topNavigation;

															var  personsCount;
															var  lastIndex; 
															var  topNavigation;
operator -это какое-то действие
operand -это то над чем мы проводим действие
Есть оператор =,слева находится операнд "куда" , 
куда = что ,что -это понятие

														К примеру:
var personalsount = 10;--слева куда мы присваивает справа что присваиваем,таким образом работает оператор присваивания

var personalСount;--можно комбинировать с var
personalCount = 10;

	var pi = 3.14; 
			это тоже самое что и 
	var pi; 
	pi= 3.14;
var numbers = 2 + 3 + 1 +1; При вызове numbers; выполнится все сложение и выведится число 7 

К примеру 3 переменных
var person = "Mama";
var action = "mila";
var target = "ramu";
Теперь Делаем функцию визова 3х переменных с пробелами
var actionDescriptionss = person + " " + action + " " + target + " ";
В результате:
actionDescriptionss
"Mama mila ramu "
Это называется "КОНКАТЕНАЦИЕЙ" -обьеденение строк
Если приплюсовать чило к строке получится что-то вроде этого: "90" + 90 = "9090"
Если Ентерпритатор видит хотябы одну строку при + то приводит остальной аперанд к строковому виду
Есть хак вроде +"90" + 90 который даст результат 180 но им лучше не пользоватся


10 % 3 будет равнятся 1 тоисть это 10 от 3х(считается 3*3 = 9,все что осталось 1)
Когда пишем что-то вроде counter +=1 +1 лучше использовать скобки чтобы не запоминать приоритеты аперандов (counter +=1) +1 или counter +=(1 +1)


var a =10
alert(a) --Позволяет посмотреть значение а(вверху екрана выведется,поверх консоли)

var a =10
var b ="10"

console.log(a)  
console.log(b)
Лучше использовать console.log потому что,к примеру она отличает типы данных,число будет синим строка черным,и возможность записывать данные через запятую но это отладочный код и его нужно убирать
console.log("--------",b) просто для удобства виделяет
console.info(a,b); --подсвечивает синим цветом
console.warn(a,b); --подсвечивает желтым цветом
console.clear() ---в начале каждого скрипта очищает в консоле все, кроме того что идет ниже

var a = {}; --Обьектный Тип данных (Обьектом называется)



Как и в случае с HTML и CSS,если браузер обнаруживает ошибки в JavaScript,он старается продолжить чтение JavaScript, HTML и CSS. 
Браузер начинает выполнять код сразу,как только встречает его, и продолжает выполнять на всем протяжении жизненного цикла страницы.

CSS-это набор правил,а JAVASCRIPT -это команды!

var bool = false; --Булевское или логическое значение пишется без ""

Имя переменной должно начинаться с буквы, подчеркивания или знака доллара. 
Потом могут следовать только буквы, цифры, подчеркивания и знаки доллара— в любом количестве.
Не рекомендуется использовать имя переменных кирилицей(русскими буквами) они будет работать неустойчиво

// -однострочный комментарий в Javascript
x      =      2233;Лишние пробелыразрешены(почти везде)

Язык JavaScript, в отличие от разметки HTML,учитывает регистр символов. Другими словами,Counter и counter— разные переменные.
								ОПЕРАТОРЫ
= //оператор присваивания
== //оператор сравнивания, совпадают ли два значения,выясняет равны ли они между собой
//Распостранненая ошибка: if( name = "Вова") --- одинарный знак равенства присваивает значение переменной, в данном случае строка "Вова" будет сохраненна в переменной name,интерпритатор считает этот код истинным и всегда то что идет за условием или в нем будет выполнятся
+  //Оператор сложения
!=  //оператор проверяет что два значение НЕ РАВНЫ
=== //Оператор равенства(строгого),с оператором === два значения считаются равными,только если они относятся к одному типу и содержат одинаковые значения
!== //по аналогии с тем, как === является «строгой» версией ==,оператор !== является «строгой» версией !=. Оператор !== использует те же правила, что и ===, но проверяет неравенство вместо равенства

||  //оператор ИЛИ , объединяет две проверки (quess < 0 || ques > 6)  ,если хотябы 1 из 2х проверок совпала то будет true(будет работать)
if (quess == location1 || quess = location2 || quess = location3){
		hits = hits + 1;
	}
/*Лучше групировать условия в пару скобок для удобства и для лучшего понимания
if ( (quess == location1) || (quess = location2) || (quess = location3)){
		hits = hits + 1;
	}	
*/
	
&& // работает аналогичным образом, но дает истинный результат только в случае истинности обоих условий (тоесть 2 условия должны повпадать)

							Булевские операторы
Булевские операторы используются в логических выражениях, результатом
которых является значение true или false.							
Булевские операторы делятся на два вида: 
операторы сравнения и логические операторы.
						    Операторы сравнения 
Операторы сравнения сопоставляют два значения:
< “меньше”
> “больше”
== “равно”
===  “в точности равно” 
<=  “меньше либо равно”
>=  “больше либо равно”
!=  “не равно

							Логические операторы
Логические операторы объединяют два булевских выражения и создают 
один результат true или false. Два важнейших логических оператора:
||   ИЛИ. Результат будет истинным, если истинно хотя бы одно из двух выражений.
&&   И. Результат будет истинным, если истинны оба выражения.

Еще один логический оператор — НЕ — применяется к одному булевскому 
выражению (вместо двух):

! НЕ. Результат будет истинным, если выражение ложно 







								ЦЫКЛ
бесконечный цикл --работой цикла управляет условие,и цикл выполняется до тех пор, пока 
это условие остается истинным.Если в вашем коде не происходит ничего такого, в
результате чего условие в какой-то момент станет ложным, то цикл никогда не завершится!!!
								
while (scoops > 0) {
	document.write("Another scoop!");
	scoops = scoops - 1;
}
/*
	while - Цикл while начинается с ключевого слова while
	(scoops > 0) - Цикл while содержит логическое выражение,которое называется условием продолжения(или просто условием)
	Если условие цикла истинно,то весь программный блок выполняется.
	Если условие истинно, то после выполнения программного блока происходит возврат к началу цикла, и все повторяется заново. Если же условие ложно, цикл завершается
*/
						
						Теперь более подробнее(живой пример)
						
	var scoops = 5;
	while (scoops > 0) {
	   document.write("Another scoop!<br>");
	   scoops = scoops - 1;
	}
	document.write("Life without ice cream isn't the same");
/*
	document.write("Another scoop!<br>");-----Так как условие истинно, начинается выполнение программного блока. Первая команда в теле цикла выводит в браузер строку “Another scoop!<br>”. 
	scoops = scoops - 1;----Следующая команда уменьшает текущее значение scoops на 1 и присваивает результат (4) все той же переменной scoops
	} --- Это последняя команда в блоке. Цикл возвращается к началу, и все повторяется заново
	Условие проверяется снова; на этот раз переменная scoops равна 4. Но хотя значение scoops уменьшилось, оно по-прежнему больше нуля.
	Когда Переменная scoops равна нулю, а условие оказывается ложным. На этом все кончается; цикл больше выполняться не должен.  На этот раз программа обходит блок и выполняет команду, следующую за ним
*/
								
var scoops = -1;
		if (scoops >= 5) {
		   alert("Eat faster, the ice cream is going to melt!");
		} else if (scoops == 3) {
		   alert("Ice cream is running low!");
		} else if (scoops == 2) {
		   alert("Going once!");
		} else if (scoops == 1) {
		   alert("Going twice!");
		} else if (scoops == 0) {
		   alert("Gone!");
		} else {
			alert("Done");
		}								
Вы можете объединить сколько угодно команд if/else.Также можно добавить завершающую секцию else; если ни одно условие не выполняется			
								
								
var massage = "Ivi" + " " + 30;						
console.log(massage);Выводит то что в переменной							
								
								
					Размещение JAvascript на страницу,способы и какой из них лучший:
1)Код можно встроить в элемент <head>,при поможи <script></script> и вставить весь код в него но он самый плохой,
Потому что во время загрузки браузер загружает все содержимое раздела <head> страницы и только потом переходит 
к разделу <body>. Если ваш код расположен в <head>, пользователю придется немного подождать, чтобы увидеть страницу.

2)Встроить код в <body> в самом конце, Если же код загружается после разметки HTML в <body>, 
пользователь будет видеть содержимое страницы во время загрузки. 								
								
3)Внешний файл,дать ссылку в <head>(разместить код в отдельном файле и включить ссылку на него в элемент <head>. )								
Етот внешний файл можно использовать в других страницах,но проблема таже,сначала загружается <head>,а потом все остаольное								
 								
4)Лучший варант - это внешний файл добавить в конце <head>								
								
Встроенный код JavaScript не может объединяться с внешним.Если вы попытаетесь добавить код между тегами 
<script>, в которых уже используется атрибут src, увас ничего не выйдет. Для этого нужны два отдельных элемента <script>.

if (quess < 0 || ques > 6) {// ||-эта конструкция называется оператором ИЛИ и объединяет две проверки
		alert("Please enter a valid cell number!");
}//Если  quess меньше 0 или больше 6 выводится сообшение

							Упрощение булевский переменных
var da = false;
var net = false;
if (da == false && net == false) {//будет работать только если совпадают два
	alert("Buy buy buy!")
}else {
	alert("Ha-ha-ha");
}
							или такое
if (da == false && (net == true || price > 100)) {
	alert("Cool,cool...");
}
//значение будет истенно если da будет false и что-то из скобок будет истенно,либо net либо price > 100, или обе истенны
//Такое код проще делать и проще читать

var da = true;
if (da) {
	alert("da");	
}
//Скороченная запись,если условие истинное(true),по умолчанию то можно
//не писать if (da == true),а просто if(da),но такая сокращенная запись только для true с false она не работает
										ГЕНЕРАТОР СЛУЧАЙНЫХ ЧИСЕЛ
var randomLog =Math.floor(Math.random() * 5);
/*
	Math.random является частью стандартного инструментария JavaScript и возвращает случайное число
	Единственная проблема заключается в том, что функция возвращает числа  такие, как 0.128, 0.830, 0.9 или 0.42
	Умножая случайное число на 5, мы получаем число в диапазоне от 0 до 5, не включая 5, такие числа, как  0.13983, 4.231, 2.3451 или, допустим, 4.999.

	Остается отсечь дробную часть, чтобы получить целое число. Для этого можно воспользоваться другой встроенной математической функцией Math.floor
*/
var randomLoc = Math.floor(Math.random() * 5);
/*
	Функция Math.floor округляет числа, отбрасывая их дробную часть
	Так, например, 0.13983 превращается в 0, 2.34 превращается в 2, а 4.999 превращается в 4
	
	функция Math.random генерирует число от 0 до 1, не включая 1. Максимальное число, 
которое можно получить от Math.random, равно 0.999... Максимальное число, которое можно получить
при умножении его на 5, равно 4.999...  Функция Math.floor округляет числа в меньшую сторону,
поэтому1.2 округляется до 1, но точно так же округляетсяи  1.9999. Если мы генерируем числа от 0 
до 4.999... то все результаты будут округляться до чисел от 0 до 4. Это не единственный способ, 
и в других языках  данная задача нередко решается иначе, но в коде JavaScript чаще всего встречается именно такое решение.
*/

											ФУНКЦИИ
Функции JavaScript позволяют взять фрагмент кода, присвоить ему имя, а затем ссылаться на его имя везде, где он понадобится.
Если в функции нет параметров то вызываем просто,имя функции и пустие скобки(там где должны быть параметры),а если есть параметры 
то в функции нужно сделать return(по необходимости) и нужно создать переменую куда будет пристаивать возвращенное значения функции(return)
Ключевое слово return должно быть последней инструкцией в функции,потому что интерпритатор Javascript выходит из функции сразу после того как встретит return.Строки кода следующие после return не будут выполненны
Функция может вернуть только одно значение.Если нужно вернуть несколько значений, можно сохранить их в массив и вернуть массив 


function bark(name, weight) {
	//тут будет код,другими словами тело
}

/*
	Определение функции начинается с ключевого слова function
	Далее следует имя функции, например bark
	А теперь указываются два значения,которые должны передаваться для использования функции: имя собаки и ее вес
	Параметры перечисляются в круглых скобках после имени функции.
*/
										Вызов Функции
bark("rover",25);
/*
	имя функции,и его атрибуты(name,weight)	
*/
saveMyProfile("krissy", 1991, 3.81, false);
//В аргументе можно передать любое значение JavaScript
                   
				   Переменные тоже могут передаваться как аргументы
var birthday =1990;
var day = 12;
var month = 11;
function da(colocol,birthday,tello,day) {
	if (colocol > 12) {
		console.log("Right");
	}if (birthday >=1990) {
		console.log("Good age");
	}if (tello == "tello") {
		console.log("tello");
	}if (day == 12) {
		console.log("12");
	}
}
da(13,birthday,"tello",day);
//в результате выведет Right,Good age,tello,12

saveMyProfile(student, year, 381/100, status == "newuser");
//В качестве аргументов могут использоваться даже выражения
							
							Что такое параметры и Аргументы
Параметр -это просто переменная с данными,а агрумент это то что мы передаем

function cook(degrees, mode, duration) {
   // Код функции
}
/*
	Здесь определяются три параметра: degrees, mode и duration
	При вызове функции вы передаете ей аргументы: cook(425.0, "bake", 45);
	Итак, параметры определяются только один раз, но функция будет вызываться с разными аргументами
*/			

В Javascript используется передача по значению,То есть передача посредством копирования
К примеру если создадим переменную age со значением 7 и напишем функцию с названием addOne с
параметром x ,addOne(x) а внутри
function addOne(x) {
    x = x + 1;
}
которая увеличивает значение x на 1,Вызовем функцию addOne и передадим ей в аргументе переменную age. 
Значение age копируется в параметр x,Значение x увеличивается на 1. Однако следует помнить, что x содержит 
копию исходного значения, так что увеличивается только x, но не age
Другими словами все, что происходит с параметром внутри функции, остается в границах функции и не выходит наружу
Просто делается копия


               Что произойдет, если передать слишком мало аргументов?
function makeTea(cups,tea) {
	console.log("Brewing" + " "+ cups + " " +"cups of" + " "+ tea);
}
makeTea(2);
/*
	все ограничивается тем, что параметрам, не получившим аргументов, присваивается значение undefined
	параметр tea содержит значение undefined, потому что мы не передали его значение
*/
					А если аргументов будет слишком много?		   
//Тогда JavaScript просто игнорирует лишние аргументы			   
					Что произойдет, если у функции вообще НЕТ параметров?  
function da() {
	alert("WOOooooo");	
}
da();			   
//Ничего страшного, таких функций очень много


Если переменная объявляется вне функции, ее можно использовать в любой точке кода. Если же переменная объявляется внутри функции, то
она может использоваться только внутри этой же функции!Cуществуют две разные области действия: глобальная и локальная.
Переменная,объявленная за пределами функции,называется ГЛОБАЛЬНОЙ.Если переменная объявлена внутри функции,она называется ЛОКАЛЬНОЙ

function playTurn(player, location) {
    points = 0;  //Если забыть обявить ключевое слово VAR, то Javascript будет думать что это глобальная переменная
    if (location == 1) {
       points = points + 100;
    }
    return points;
}
var total = playTurn("Jai", 1);
alert(points);

/*Так как мы забыли использовать var, JavaScript считает, что переменная points должна быть глобальной, и ведет себя так, словно 
объявление points располагается на глобальном уровне*/

var points = 0;
function playTurn(player, location) {
    points = 0;
    if (location == 1) {
       points = points + 100;
    }
    return points;
}
var total = playTurn("Jai", 1);
alert(points);


Что произойдет, если присвоить локальной переменной такое же имя, как у существующей локальной переменной?

var beanCounter = 10; 
function getNumberOfItems(ordertype) {
    var beanCounter = 0;
    if (ordertype == "order") {
       // Что-то делаем с beanCounter...
    } 
    return beanCounter;

/*Все обращения к beanCounter внутри функции относятся к локальной переменной, а не к глобальной. Мы говорим, что глобальная
переменная «замещается» локальной (то есть она не видна, потому что локальная переменная ее загораживает
Локальная и глобальная переменные никак не влияют друг на друга; если изменить одну, это изменение 
никак не отразится на другой. Эти переменные существуют независимо
*/
Если имя параметра совпадает с именем глобальной переменной, значит ли это, что параметр 
«замещает» глобальную переменную?---Да

								ПРИМЕР МНОГОКРАТНОГО ПРИМЕНЕНИЯ ФУНКЦИИ
var scores = [60, 50, 60, 58, 54, 54,
              58, 50, 52, 54, 48, 69,
              34, 55, 51, 52, 44, 51,
              69, 64, 66, 55, 52, 61,
              46, 31, 57, 52, 44, 18,
              41, 53, 55, 61, 51, 44];
var da = [22,44,44];
var daa = [22,44,88,88];
var daaa = [22,1,22];
//4 МАССИВА
function getHighScore(scores) {
	var highScore = 0;
	for (var i = 0; i < scores.length; i++) {
		if (highScore < scores[i]) {
			highScore = scores[i];
		}	
	}
	return highScore;
}
//Одна функции
var getScore = getHighScore(scores);
var getScor = getHighScore(da);
var getScora = getHighScore(daa);
var getScoraa = getHighScore(daaa);
console.log(getScore);
console.log(getScor);
console.log(getScora);
console.log(getScoraa);
//Мы меняем только аргумент и функции работает с любим масивом


									РАЗМЕЩЕНИЕ
ПЕРЕМЕННЫЕ: переменные следует Всегда записывать вверху(сначала кода),так удобней читать
и если к примеру мы будет обращатся к переменой до ее написания или после оращения будет ощибка

ФУНКЦИИ: функции могут размещаться в любом месте файла JavaScript. JavaScript не обращает 
внимания на то, где объявляется функция— до или после ее использования.Тоисть сначала может
идти вызов функции,а потом сама функция с кодом.
Как такое возможно?JavaScript дважды обрабатывает страницу: при первом проходе читаются 
все определения функций, а при втором начинается выполнение кода. Этот факт и позволяет размещать 
функции в любом месте файла.

							Гигиена и чистота кода
Глобальные переменные— В САМОМ НАЧАЛЕ! ---Так удобнее 
Функции любят общество себе подобных! --- Без разници где размещать в начале или в конце,просто держать все функции в одном месте
Локальные переменные обьявлять в НАЧАЛЕ тела функции! 		


								МАССИВЫ
Массив— это тип JavaScript, способный хранить несколько однотипных значений
Массивы предназначены для хранения нескольких значений (в отличие от переменных, которые хранят только одно значение например строку или число)
Чаще всего массивы используются для группировки сходных данных— температур, количества пузырей, сортов мороженого и даже ответов на вопросы анкеты «да/нет». 
Так что группируем набор значений, создаем массив и обращаемся к значениям по индексу
в JavaScript массив является особой разновидностью объектов.
В элементах массивов могут храниться значения любого типа

var scores = [60, 50, 60, 58, 54, 54, 58, 50, 52, 54];

								Вызов Массива
В Javascript отчет начинается с 0, идет (0,1,2,3,4....)
var scores = [60, 50, 60, 58, 54, 54, 58, 50, 52, 54];
alert(scores[4]);//вызовет 54

var dd = scores[2];//Вызовет 60
alert(dd);

							Как создать Массив
массив для хранения сортов мороженого
var flavors = ["vanilla", "butterscotch", "lavender", "chocolate", "cookie dough"];
/*
	Массив присваивается переменной с именем flavors
	Определение массива начинается с символа [
	затем перечисляются все элементы массива
	после чего массив завершается символом ]
	При создании массива каждый элемент находится в некоторой позиции, которая определяется его индексом. В массиве сортов 
	мороженого flavors первый элемент — vanilla — имеет индекс 0, второй — butterscotch— индекс 1, и так далее
*/
							
							Изменить значение в Массиве
flavors[3] = "vanilla chocolate chip";//изменит chocolate на vanilla chocolate chip
flavors = "vanilla chocolate chip";//А так изменит все значения на один этот

							Как узнать сколько элементов в массиве
ключевое свойство length показывает сколько элементов в масиве

var flavors = ["vanilla", "butterscotch", "lavender", "chocolate", "cookie dough"];
alert(flavors.length);

var da = flavors.length;
alert(da);
//Длина равна 5, потому что массив содержит 5 элементов.
							
						Как узнать значение последнего элемента в массиве
console.log(flavors[flavors.length - 1]);//В результате выведет cookie dough
							
							Пример работы с массивами
function rand() {
	var word1 = ["Alexey", "Eva", "Paris", "Olga", "Sveta", "Nadja"];
	var word2 = [23, 16, "backend", "frontend", "star", "looser"];
	var word3 = ["work", "job", "cloun", "bidlo", "piska", "konuh"];
	//Три переменных для массива
	
	var random1 = Math.floor(Math.random() * word1.length);
	var random2 = Math.floor(Math.random() * word2.length);
	var random3 = Math.floor(Math.random() * word3.length);
	//Генерируем три случайных числа,число в диапазоне от 0 до последнего индекса массива word1,word2,word3
	//Другими словами,мы умножаем на количество строк в масиве,при том оно само высчитывается
	
	var status = word1[random1] + " " + word2[random2] + " " + word3[random3];
	//Переменная для хранения сгенерированной фразы
	alert(status);
}
rand();
//В результате будет вилетать любой индекс из массива

 Что произойдет при попытке обращения к массиву по слишком большому или малому индексу (допустим, меньше 0)?
----------В обоих случаях будет получен результат undefined.
					Как узнать индекс последнего элемента в массиве???
myArray[myArray.length - 1]; или так alert(nameOfvar.length - 1);
JavaScript получает длину массива, уменьшает ее на 1, после чего получает значение по заданному индексу. Если массив 
содержит 10 элементов, то вы получите элемент с индексом 9

							Перебрать Массив
var scores = [60, 50, 60, 58, 54, 54,     
              58, 50, 52, 54, 48, 69,
              34, 55, 51, 52, 44, 51,
              69, 64, 66, 55, 52, 61,
              46, 31, 57, 52, 44, 18,
              41, 53, 55, 61, 51, 44];
var output;
var i = 0;
while (i < scores.length) {//Цикл продолжается, пока индекс остается меньше длины массива
	output = ("Bubbles scores #" + i + "scores" + scores[i]);
	i = i + 1;
	console.log(output);
}
//Будет выводить Bubbles scores #0scores60,Bubbles scores #1scores50.....							
						
						разреженный массив
Разреженный массив содержит значения по небольшому подмножеству индексов,и не содержит значений в других позициях
						
var sparseArray = [ ];
   sparseArray[0] = true;
   spraseArray[100] = true;
/*	В этом примере sparseArray содержит всего два значения с индексами 0 и 100 (true в обоих элементах). 
	Значения по всем остальным индексам остаются неопределенными.Длина массива равна 101, но массив содержит всего два значения						
*/	

Предположим, имеется массив длиной 10.Я добавляю элемент с индексом 10000. Что произойдет с индексами с 10 по 9999?				
/*
	Все эти элементы будут содержать undefined. Если вы еще не забыли, значение undefined присваивается переменной, 
которая еще не была инициализирована.В общем, считайте, что вы создаете 9989 переменных, но не инициализируете их. 
Помните, что все эти переменные занимают память на компьютере, даже если они не содержат полезных данных. Будьте уверены 
в том, что у вас есть веские причины для создания разреженного массива.
*/	

Если я перебираю массив, и некоторые элементы содержат undefined,не нужно ли проверять значения перед использованием?
/*
	Для каких то вычислений попытка использовать undefined приведет к ошибке, или по крайней мере к неожиданному поведению программы
	НУжно просто сделать проверку на undefined
*/
var masiv = [12,12312];
masiv[5] = 2;
masiv[99] = true;
for (var i = 0; i < masiv.length; i++){
	if (masiv[i] == undefined) {
	console.log("da");
	}else {
	console.log("no");
	}
}
//Проверка


								ЦЫКЛ FOR
//Данный цыкл сравнивается с тем что выше(While)
for (var i = 0; i < scores.length; i = i + 1) {
     output = "Bubble solution #" + i + " score: " + scores[i];
     console.log(output);
}							
										
/*
	Цикл начинается с ключевого слова for
	Запись в круглых скобках состоит из трех частей. Первая часть ИНИЦИАЛИЗАЦИЯ переменной цикла.Она выполняется только один раз,до начала цикла for
	Вторая часть— проверка УСЛОВИЯ. Она выполняется при каждой итерации цикла. Если условие оказывается ложным, выполнение цикла прерывается
	Третья часть—УВЕЛИЧЕНИЕ счетчика. Оно происходит один раз за итерацию, после выполнения всех команд в ТЕЛЕ цикла
	Как правило, переменные циклов (например,i) используются только для управления циклами и после завершения уже не нужны. Вы, конечно, можете использовать i в своем коде, 
	но так поступать не рекомендуется. Таким образом, объявление прямо в команде for делает программный код лаконичнее и выразительнее
*/										
							Отличие Цыкла WHILE от FOR
/*
При использовании цикла WHILE необходимы разные команды, чтобы инициализировать счетчик и увеличивать его значение.  
Если после множества изменений в коде одна из этих команд случайно пропадет или переместится... ничем хорошим это 
не кончится. С циклом FOR все управление циклом упаковано прямо в команде FOR, находится на виду и никуда не пропадет
*/
									
			Оператор постфиксного увеличения (инкремента)
myImportantCounter = myImportantCounter + 1;
myImportantCounter++;
//Одно и тоже,просто сокращенная запись			
										
myImportantCounter--;//А это уменьщает на один										
				
					Определение Максимального результата
var masiv = [0, 50, 60, 58, 54, 54,
                  58, 50, 52, 54, 48, 69,
                  34, 55, 51, 52, 44, 51,
                  69, 64, 66, 55, 52, 61,
                  46, 31, 57, 52, 44, 18,
                  41, 53, 55, 61, 51, 44];
var hightScore = 0;
for (var i = 0; i < masiv.length; i++) {
	if (masiv[i] > hightScore) {//Если число в масиве больше чем переменная hightScore,
		hightScore = masiv[i];//то переменная hightScore становится этим максимальным значением
	}
}
console.log(hightScore);//Выведет максимальное число 69
										
var genres = ["80s", "90s", "Electronic", "Folk"];//Этот список называется «литералом массива»— мы перечисляем, какие значения входят в массив								

//Но также можно создать пустой массив без указания начальных элементов:
var proba = []; //Новый массив готов к работе;он не содержит элементов и имеет нулевую длину.Это тоже литерал массива, хотя он и не содержит данных
proba[0] = 22;
proba[1] = 1;
proba[3] = 1;
console.log(proba);


/*При добавлении новых элементов необходимо следить за тем, по какому индексу размещается добавляемое значение. 
В противном случае вы создадите разреженный массив,то есть массив с «дырами» (например, массив со значениями в позициях 0 и 2, но без 
значения в позиции 1). Разреженный массив— это не обязательно плохо, но он требует особого внимания. 
А пока следует сказать, что существует другой способ добавления новых элементов, с которым не нужно беспокоиться об индексе. 
Это метод push, и вот как он работает:*/

var proba = [];
proba.push(22);
proba.push("String");
console.log(proba);

//Метод push добавляет в свободные ячейки массива по порядку ничего не пропуская и не делает разрывов
//Для добавления новых значений в массив можно использовать метод push
//proba[proba.length] = 33; Тоже самое что и метод push
//Однако одно из преимуществ команды push() состоит в том, что она позволяет добавлять в массив более одного элемента: proba.push(true, 45,67,12,"Solo");


 var masiv = [22, 22, 11, 100,100,100];
 var score = 0;
 var pusto = [];
 for (var i = 0; i < masiv.length; i++) {
	 if (score < masiv[i]) {
		 score = masiv[i];
	 }
 }
 for (var i = 0; i < masiv.length; i++) {
	 if (score == masiv[i]){
		 pusto.push(i);
	 }	 
 }
 console.log(pusto);
 //выведет 3,4,5 как индекс повторений

var masiv = [22, 22, 11, 100,100,100];
 var score = 0;
 var pusto = [];
 for (var i = 0; i < masiv.length; i++) {
	 if (score < masiv[i]) {
		 score = masiv[i];
	 }
 }
 for (var i = 0; i < masiv.length; i++) {
	 if (score == masiv[i]){
		 pusto[i] = i;
	 }	 
 }
 console.log(pusto);

//PUSH вставляется вместо pusto[i] 

Вернемся к только что написанному коду и переработаем его в набор функций. Такая переработка 
называется рефакторингом— мы изменим структуру кода, сделаем его более удобочитаемым, но при 
этом не будем менять функциональность. Другими словами, когда все будет сделано, код продолжит 
работать точно так же, как прежде, но при этом окажется гораздо лучше организован


					Пример работы с двумя массивами
					(сравниваем их и выбыраем из одного максимальное значение,а из дгугого минимальное)
var scores = [60, 50, 60, 58, 54, 54,
              58, 50, 52, 54, 48, 69,
              34, 55, 51, 52, 44, 51,
              69, 64, 66, 55, 52, 61,
              46, 31, 57, 52, 44, 18,
              41, 53, 55, 61, 51, 44];
function getHighScore(scores) {
	var highScore = 0;
	for (var i = 0; i < scores.length; i++) {
		if (highScore < scores[i]) {
			highScore = scores[i];
		}	
	}
	return highScore;
}
var getScore = getHighScore(scores);//переменная выводиз из функции максимальное значение
console.log(getScore);
var costs = [.25, .27, .25, .25, .25, .25, 
             .33, .31, .25, .29, .27, .22, 
             .31, .25, .25, .33, .21, .25, 
             .25, .25, .28, .25, .24, .22,
             .20, .25, .30, .25, .24, .25, 
             .25, .25, .27, .25, .26, .29];
function getMore(scores, getScore, costs) {//Вносим параметры которые здесь работают,можно и без них но для видимости и понимания лучше 
	var cost = 100;//Одна переменная для сохранения из масива costs значения
	var index = 0;//а index для хранения индекса в котором находится значение
	for (var i = 0; i < scores.length; i++) {//Цикл пока не переберет всю длину масива не остановится
		if (scores[i] == getScore) {//Если значение в масиве scores равно(или там есть такое значение) максимальному значению,Цикл продолжается потому что там 2 значения которые совпадают
			if (cost > costs[i]) {//и если cost больше любого значения из масива costs 
				index = i;//присваиваем переменной index ,индекс под которым это значение находится
				cost = costs[i];//и меняем переменную costs на это значение
			}
		}
	}
	return index;//Возвращаем индекс под которым значение находится в массиве
}
var more = getMore(scores, getScore, costs);
console.log(more);					

							ОБЬЕКТЫ
Главный секрет объектов JavaScript: они представляют собой набор свойств
/*
	В переменных не хранятся собственно объекты.
	Вместо этого в них хранятся ссылки на объекты.
	Ссылка напоминает указатель или адрес объекта.
	Иначе говоря, переменная содержит не сам объект, а нечто вроде указателя. И в JavaScript мы не знаем, 
что хранится в переменной. Зато мы знаем— что бы это ни было, оно указывает на наш объект. 
	При использовании точечной записи интерпретатор JavaScript берет на себя обращение по ссылке к объекту и последующие операции с его свойствами

	Итак, объект невозможно вместить в переменную, хотя мы часто думаем о происходящем именно так. Но не существует гигантских 
расширяемых переменных, подстраивающихся под любой размер объекта. Просто объектная переменная содержит ссылку на объект. 
	На ситуацию также можно взглянуть немного иначе: примитивная  переменная представляет фактическое значение переменной, тогда 
как объектная переменная представляет способ обращения к объекту. 
	На практике объекты достаточно представлять себе... как объекты: 
собаки, машины и т. д, а не как ссылки. И все же если вы будете знать, что переменные содержат ссылки, это пригодится вам в будущем 

Инициализация примитивной переменной:    var x = 3; сохраняется непосредственно в переменной
Инициализация объектной (ссылочной) переменной: var myCar = {...}; При объявлении и инициализации объекта используется объектная запись, 
но сам объект в переменной не поместится. Вместо объекта в переменной сохраняется ссылка на объект
Другими словами поместится в переменную обьект myCar а все что внутри него будет ссылками
*/

var chevy = { 
    make: "Chevy",
    model: "Bel Air",
    year: 1957, 
    color: "red",
    passengers: 2,
    convertible: false,
    mileage: 1021
};
/*
	var chevy --Это ОБЬЕКТ,у обьекта есть свойства и значения
	make,model,year,color....---Это свойства.Объявление свойства состоит из имени, двоеточия и значения.
	Свойства разделяются запятыми.
	"Chevy","Bel Air",1957,"red" ...-Это значения
	Объявление объекта завершается закрывающей фигурной скобкой. И как в случае объявления
	Любой другой переменной, после него ставится точка с запятой	
	Мы создали настоящий объект с набором свойств. Этот объект был присвоен переменной, 
	через которую сможем обращатьсяк объекту и изменять его свойства
*/
Имя свойства может быть произвольной строкой, но обычно в них используются имена переменных:
var widget = {
     cost$: 3.14,
     "on sale": true  
 }
/*
	Если строка, используемая как имя свойства, содержит пробелы, ее необходимо заключить в кавычки
	Объект не может содержать два свойства с одинаковыми именами
*/

							Как обратиться к свойству 
Чтобы обратиться к свойству объекта,укажите имя объекта, поставьте точку, а затем укажите имя свойства.
Этот синтаксис, часто называемый «точечной записью», выглядит так:
var fiat = { 
    make: "Fiat",
    model: "500",
    year: 1957, 
    color: "Medium Blue",
    passengers: 2,
    convertible: false,
    mileage: 88000
};
//Точечная запись (.) открывает доступ к свойствам объекта

Такое свойство может использоваться в любом выражении:
var miles = fiat.mileage;
if (miles > 2000) {
   alert(miles);
}

					Как изменить свойство
Предположим, мы хотим сбросить пробег нашего «Фиата» до 10000. Это делается так:
fiat.mileage = 10000;
					Как добавить новое свойство
Для этого достаточно указать новое свойство и присвоить ему значение
fiat.needsWashing = true;
					Как выполнять вычисления со свойствами
Все просто: используйте свойство точно так же, как бы вы использовали любую переменную

if (fiat.year > 0) {
	for(var i = 0; i < fiat.passengers; i++) {
		document.write("Ha<br />");
	}
}
//Обращение идет напрямую,не нужно создавать никаких переменых для свойств и их значений

Для удаления свойств используется специальное ключевое слово — delete
//к примеру мы добавляем новое свойство
fido.dogYears = 35;
//Что бы удалить ее нужно вести следующее
 delete fido.dogYears;

Если обратится к несуществующему свойству то результат будет  равен undefined
Что произойдет, если поставить запятую после последнего свойства?
/*
 В большинстве браузеров это не приведет к ошибке. Однако в старых версиях некоторых браузеров выполнение кода JavaScript 
может быть прервано. Итак, если вы хотите, чтобы ваш код работал как можно в большем количестве браузеров, старайтесь избегать лишних запятых
*/

							Пример визова функции другой функцией
    function makeCar() {
        var makes = ["Chevy", "GM", "Fiat", "Webville Motors", "Tucker"];
        var models = ["Cadillac", "500", "Bel-Air", "Taxi", "Torpedo"];
        var years = [1955, 1957, 1948, 1954, 1961];
        var colors = ["red", "blue", "tan", "yellow", "white"];
        var convertible = [true, false];
        var rand1 = Math.floor(Math.random() * makes.length);
        var rand2 = Math.floor(Math.random() * models.length);
        var rand3 = Math.floor(Math.random() * years.length);
        var rand4 = Math.floor(Math.random() * colors.length);
        var rand5 = Math.floor(Math.random() * 5) + 1;
        var rand6 = Math.floor(Math.random() * 2);
        var car = {
            make: makes[rand1],
            model: models[rand2],
            year: years[rand3],
            color: colors[rand4],
            passengers: rand5,
            convertible: convertible[rand6],
            mileage: 0
        };
        return car;//Объекты возвращаются функцией точно так же, как любые другие значения(как я понял из-за того что обьект car имеет ссылки)
    }
    function displayCar(car) {//Очень важно написать параметр car  чтобы функция знала откуда брать данные
        console.log("Your new car is a " + car.year + " " + car.make + " " + car.model);
    }
    var carToSell = makeCar();
    displayCar(carToSell);
/*
	Сначала мы вызываем функцию makeCar и присваиваем возвращаемое ей значение переменной carToSell.  
	Затем объект, возвращенный makeCar, передается функции displayCar, которая просто выводит значения некоторых его свойств на консоль.
Не забывайте: возвращаемое значение (которое присваивается переменной carToSell) представляет собой ссылку на объект car
*/

							Функции в Обьектах
var fiat = { 
    make: "Fiat",
    model: "500",
    year: 1957, 
    color: "Medium Blue",
    passengers: 2,
    convertible: false,
    mileage: 88000,
    drive: function() {
       alert("Zoom zoom!");
    }
};

/*
	Обратите внимание: мы не указываем имя функции, а просто ставим ключевое слово function, за которым следует тело.Имя функции совпадает с именем свойства
	О терминологии: функции, определяемые в объектах, обычно называются методами.Это стандартный объектно-ориентированный термин для обозначения функций, принадлежащих объектам
*/

	fiat.drive();					
//При вызове метода drive тоже используется точечная запись, но на этот раз с именем объекта fiat и именем свойства drive, только за именем свойства следуют круглые скобки (как при вызове любой другой функции)
//Для обращения к функции в объекте fiat используется точечная запись, как и для обращения к любому другому свойству.Такое обращение называется «вызовом метода drive объекта fiat»

									Теперь более сложный пример
var fiat = {
	make: "Fiat",
	model: "500",
	year: 1957,
	color: "Medium Blue",
	passengers: 2,
	convertible: false,
	mileage: 88000,
	started: false,//Свойство для хранения текущего состояния двигателя
	start: function() {//Метод для запуска двигателя.
		started = true;
	},
	stop: function() {//Метод для остановки двигателя.
		started = false;
	},	
	drive: function() {
		if (started) {
			alert("Zoom zoom!");
		}else {
			alert("You need to start the engine first.");
		}
	}
};
/*
	Использование метода для изменения свойства— еще один пример инкапсуляции;часто мы можем упростить 
сопровождение и расширение кода, поручая технические подробности выполнения операций объекту.
	Лучше создать метод start,который знает, как запускать машину,вместо того, чтобы помнить: «чтобы запустить машину, 
нужно взять переменную started и присвоить ей true»
*/
fiat.drive();//вызываем метод drive(он не сработает)
/*
	Почему возникла эта странная ситуация?В методах объекта fiat содержатся ссылки на свойство started,а обычно при разрешении 
переменной в функции эта переменная оказывается локальной, глобальной или параметром функции. Но в методе drive переменная started
не относится ни к одной из этих категорий; она является свойством объекта fiat

	Дело вот в чем: то, что выглядит в методе как переменная, в действительности является свойством объекта,но мы не сообщаем JavaScript,какого именно объекта
	Короче говоря интерпритатор Javascript думает что это переменная,а на самом деле это свойство,нужно указать что мы имее виду именно в этом обьекте fiat находится свойство started
*/
В JavaScript существует ключевое слово this,которое предназначено именно для этой цели: оно обозначает текущий объект, с которым мы работаем

var fiat = {
	make: "Fiat",
	model: "500",
	year: 1957,
	color: "Medium Blue",
	passengers: 2,
	convertible: false,
	mileage: 88000,
	started: false,
	start: function() {
		this.started = true;
	},
	stop: function() {
		this.started = false;
	},	
	drive: function() {
		if (this.started) {
			alert("Zoom zoom!");
		}else {
			alert("You need to start the engine first.");
		}
	}
};
fiat.drive();

/*
	Используйте this в точечной записи перед каждым обращением к свойству started.Тем самым вы сообщаете 
интерпретатору JavaScript,что имеете в виду свойство ЭТОГО конкретного объекта (чтобы интерпретатор JavaScript 
не думал, что вы ссылаетесь на переменную)
	Чтобы по-настоящему понять смысл this,необходимо осознать один важный момент: при вызове любого метода вы можете 
	рассчитывать на то,что this в теле этого метода будет указывать на объект, метод которого был вызван
*/

								ЦЫКЛ FOR IN
К примеру мы можем перебрать все свойства объекта вцикле
Цикл for in перебирает все свойства объекта в произвольном порядке.Перебор свойств 
объекта chevy может происходить так:
var chevy = {
	name: "Alexey",
	age: 23,
	started: false,
	start: function() {
		this.started = true;
	},
	check: function() {
		if(this.started && this.age > 20) {
			alert("Welcome! " + this.name);
		}else {
			alert("No,No,No " + this.name + " You are too young!");
		}
	},
	stop: function() {
		this.started = false;
	}
};

for (var prop in  chevy) {
	console.log(prop + " : " + chevy[prop]);
}

/*
	Цикл for in перебирает свойства объекта, которые последовательно присваиваются переменной prop.
	Очень удобный цыкл,ему не важно количество значений как в for или while цыклах,он перебирает все значения в одну переменую
	Часто используется для парсеров
*/

Оказывается, в JavaScript есть два способа обращения к свойствам объектов. 
Точечная запись вам уже известна:
console.log(chevy.name);

Но существует и другой способ: запись с квадратными скобками:

console.log(chevy["name"]);

//За именем объекта ставятся квадратные скобки,в которые заключается имя свойства в кавычках
//Немного похоже на обращение к элементам массивов

Эти две формы эквивалентны и делают одно и то же. Единственное, чем отличается запись с квадратными скобками
— она обладает чуть большей гибкостью и может использоваться в следующей форме:

console.log(chevy["na" + "me"]);

							Более сложный пример
	//Это точно такой пример как выше обьект fiat,просто я немного переделал названия
var car = {
	name: "Ford",
	age: 1956,
	probeg: 88000,
	started: false,
	fuel: 0,
	
	start: function() {
		this.started = true;
	},
	drive: function() {
		if (this.started) {
			if (this.fuel > 0) {
				alert(this.name + this.age + " Goes zoom, zoom!");
				this.fuel = this.fuel - 1;
			}else {
				alert("Oh, no, you don't have fuel.");
			}
		}else {
			alert("You need to start the engine first.");
		}
	},
	stop: function() {
		this.started = false;
	},
	addFuel: function(amount) {//amount---это параметр  поэтому писать this не нужно
		this.fuel = this.fuel + amount;
	}
};
car.start();
car.addFuel(1);//и сюда мы передаем параметр,в нашем случае топлива хватит только на 1н вызов
car.drive();
car.stop();
car.start();
car.addFuel();
car.drive();
car.stop();

				В Javascript есть множество готовый обьектов например:
//Все эти объекты предоставляет JavaScript
Date --- Объект Date предназначен для работы с датой и временем
Math --- Мы уже видели, как объект Math используется для генерирования случайных чисел.Но этим его возможности не ограничиваются
RegExp --- Этот объект позволяет искать текст в строках по заданному шаблону
JSON --- С помощью объекта JSON вы сможете передавать объекты objects в другие приложения.

//Эти объекты предоставляет браузер.Они играют ключевую роль при написании приложений для браузера
Document --- для записи в веб-страницу из программного кода
Window --- Window представляет свойства,относящиеся к браузеру,и методы,которые могут использоваться в вашем коде
Console --- Метод log объекта console использовался для вывода сообщений на консоль


							МОДЕЛЬ DOM
//Сразу пример и разбор кода
<html lang="en">
  <head>
    <meta charset="utf-8">
     <title>Dr. Evel's Secret Code Page</title>
  </head>
  <body>
	<h1>Buttleship!</h1>
	<p id="code1">The eagle is in the</p>
    <p id="code2">The fox is in the</p>
    <p id="code3">snuck into the garden last night.</p>
    <p id="code4">They said it would rain</p>
    <p id="code5">Does the red robin crow at</p>
    <p id="code6">Where can I find Mr.</p>
    <p id="code7">I told the boys to bring tea and</p>
    <p id="code8">Where's my dough? The cake won't</p>
    <p id="code9">My watch stopped at</p>
    <p id="code10">barking, can't fly without umbrella.</p>
    <p id="code11">The green canary flies at</p>
    <p id="code12">The oyster owns a fine</p>
   	<script>
	var access = document.getElementById("code9"); //Сначала программа присваивает переменной access результат вызова метода getElementById объекта document,с передачей аргумента “code9”.Метод возвращает объект element
	var code = access.innerHTML;//Затем мы берем этот элемент (то есть элемент с идентификатором “code9”) и используем его свойство innerHTML для получения его содержимого,которое присваивается переменной code
	code = code + " midnight";//Код присоединяет строку “ midnight” к строке, содержащейся в code (то есть «My watch stopped at»).Затем страница отображает окно с паролем, хранящимся в переменной code.
	alert(code);</script>
  </body>
</html>

			Как JavaScript на самом деле взаимодействует со страницей
JavaScript и HTML— две разных сущности: HTML— разметка, а JavaScript— код.Как же они взаимодействуют? 
Все происходит через представление страницы,называемое объектной моделью документа, или сокращенно DOM.Откуда берется 
модель DOM? Она создается при загрузке страницы браузером. Вот как это происходит:
1)При загрузке страницы браузер не только разбирает разметку HTML и выводит ее на экран, 
но и создает набор объектов, представляющих разметку. Эти объекты сохраняются в модели DOM.
(Тоесть это просто разметка страници и Эта структура называется объектной моделью документа (Document Object Model))
			
2)Теперь код JavaScript взаимодействует с DOM для получения доступа к элементам и их содержимому.
JavaScript также может использовать DOM для создания или удаления элементов
3)Когда JavaScript изменяет DOM,браузер обновляет страницу динамически, так что новое содержимое сразу появляется на странице

					И вот собственно пример
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>My blog</title>
  <script src="blog.js"></script>
</head>
<body>
  <h1>My blog</h1>
  <div id="entry1">
    <h2>Great day bird watching</h2>
    <p>
      Today I saw three ducks!
      I named them
      Huey, Louie, and Dewey.
    </p>
    <p>
      I took a couple of photos...
    </p>
  </div>
</body>
</html> 				

//Тоисть обычная разметка html и есть обьектом DOM

Корнем каждой модели DOM является объект document, а под ним располагается дерево 
с ветвями и листовыми узлами для всех элементов разметки HTML.
Объект document всегда находится на верхнем уровне.Это особая часть дерева,которая может использоваться 
в JavaScript для получения доступа ко всей модели DOM. 

						
К примеру у нас есть модель DOM(обычная разметка страници) в которой есть 3 абзаца
	<p id="greenplane">All is well</p>
	<p id="redplanet">Nothing to report</p>
	<p id="blueplanet">All systems A-OK</p>
//Всю структуру не будем писать,экономим время и место
//И нужно поменять текст в одном из абзацев	

document.getElementById("greenplane");

/*
	Объект document представляет всю страницу в браузере и содержит полную модель DOM.Этому объекту можно 
	передать запрос на выполнение поиска элемента с заданным идентификатором
	getElementById("greenplanet") --- Здесь мы приказываем объекту document найти элемент с заданным идентификатором.
	getElementById(“greenplanet”) возвращает элемент абзаца, соответствующий идентификатору “greenplanet”.
	после чего код JavaScript может проделывать с ним разные интересные штуки
*/
Получив элемент от getElementById,вы можете выполнить с ним какую-нибудь операцию 
(например,заменить его текст).Для этого элемент обычно присваивается переменной,чтобы на
него можно было ссылаться в коде.

var planet = document.getElementById("greenplanet");
//Элемент присваивается переменной planet.
//Вызов getElementById ищет элемент greenplanet и возвращает его
//Возвращенный элемент присваивается переменной planet
//Теперь переменная planet может использоваться в коде для ссылки на элемент

planet.innerHTML = "Red Alert: hit by phaser fire!";

/*
	Свойство innerHTML элемента planet может использоваться для изменения содержимого элемента
	Содержимое элемента greenplanet заменяется новым текстом...
	Модель DOM (и страница) обновляются, и новый текст появляется в браузере
*/

Теперь если мы обновим страницу,вместо "All is well" появится "Red Alert: hit by phaser fire!" в id greenplanet

/*
	Итоги:Мы используем объект document для получения доступа к DOM из нашего кода. Встроенный объект document
содержит целый набор свойств и методов,в том числе и getElementById,который может использоваться для получения 
элементов из DOM.Метод getElementById получает идентификатор и возвращает соответствующий элемент
*/

Запрашивая элемент из DOM методом getElementById,вы получаете объект element
Несколько операций, которые могут выполняться с объектами element:
Получение содержимого (текст или HTML).
Чтение атрибута.
Изменение содержимого.
Добавление атрибута.
Изменение атрибута.
Удаление атрибута.

								innerHTML
/*	
	Важное свойство innerHTML используется для чтения и замены содержимого элемента.
	В innerHTML возвращается внутреннее содержимое элемента, без тегов элемента HTML
*/
var planet = document.getElementById("greenplanet");
alert(planet.innerHTML);

/*
	Мы просто передаем свойство planet.innerHTML методу console.log,чтобы вывести данные на консоль
	Значение свойства innerHTML представляет собой строку,которая может быть выведена на консоль как любая другая строка
	Другими словами inerHTML помогает прочитать и при необходимости изменить Елемент 
*/
var planet = document.getElementById("greenplanet");
planet.innerHTML = "Red Alert: hit by phaser fire!";
console.log(planet.innerHTML);

/*
	Чтобы изменить содержимое элемента,мы присваиваем его свойству innerHTML строку “Red Alert: hit by phaser fire!” 
*/

Итак, что же именно происходит при изменении содержимого элемента с использованием innerHTML? Фактически вы изменяете 
непосредственное содержимое веб-страницы «находу».Изменения, вносимые в содержимое в DOM, немедленно появляются на веб-странице


При работе с DOM очень важно выполнять код только после полной загрузки страницы.Если это условие 
будет нарушено,существует большая вероятность того,что модель DOM не будет построена к моменту выполнения кода

К примеру если код включен в раздел <head> страницы,поэтому он начинает выполняться до того, как браузер увидит 
остальную часть страницы.И это создает большую проблему,потому что элемент абзаца с идентификатором “greenplanet” еще не существует

Что же именно произошло?Вызов getElementById возвращает null вместо искомого элемента.Браузер добросовестно двигается дальше и все равно выводит страницу, 
но без изменения содержимого абзаца с идентификатором “greenplanet”.

Как решить проблему?Можно переместить код в конец раздела <body>,но существует более надежный способ гарантировать выполнение этого кода в 
правильное время— приказать браузеру: «Выполни этот код только после полной загрузки страницы и построения модели DOM». Давайте посмотрим, как это делается
Вот как это делается: сначала создается функция с кодом, который должен быть выполнен только после полной загрузки страницы. 
Эта функция присваивается свойству onload объекта window
Как это работает?Объект window вызовет любую функцию,связанную со свойством onload,но только после того, как страница будет полностью загружена

function init() {
    var planet = document.getElementById("greenplanet");
    planet.innerHTML = "Red Alert: hit by phaser fire!";
}

window.onload = init;

/*
	Функция может называться как угодно, но по традиции ей часто присваивается имя init
	Функция init задается свойству window.onload.Обратите внимание: после имени функции 
круглые скобки не ставятся!Мы не вызываем функцию,а просто связываем ее со свойством window.onload
После загрузки страницы,Браузер вызывает функцию на  которую ссылается свойство onload в нашем случае init
Браузер, а если говорить точнее— объект window
Когда браузер читает всю разметку по порядку и как только видит script не важно где он стоит если вызывать window.onload,то
в тот момент когда он видит код avascript браузер начинает его читать и обрабатывать,и после этого идет дадльше,
когда браузер закончил чтение всей разметки,css...в самом конце он вызывает JS (котороя к тому времени уже загрузилась и выводит результат или какое-то действие
не тратя времени на его выполнения загрузки..очень удобно) 
*/

			Как задать атрибут методом setAttribute
Объекты element содержат метод setAttribute,который может вызываться для задания атрибутов элементов HTML. 
Метод setAttribute выглядит так:

planet.setAttribute("class", "redtext");

/*
	planet -- это наш объект element
	Используем метод setAttribute для добавления нового или изменения существующего атрибута
	Метод получает два аргумента: имя атрибута, который нужно задать или изменить,и значение, присваиваемое атрибуту
	Если атрибут не существует, то он создается в элементе
*/
Вызов setAttribute для любого объекта element изменяет значение существующего атрибута, 
а если атрибут не существует— добавляет новый атрибут в элемент
Для примера давайте посмотрим, как выполнение приведенного выше кода отражается на модели DOM:

							ДО
Элемент до вызова метода setAttribute.Обратите внимание: элемент уже содержит один атрибут, id (greenplanet)
							
							ПОСЛЕ
Элемент после вызова setAttribute— теперь с двумя атрибутами, id и class


						Узнать значение атрибута элемента
Воспользуйтесь методом getAttribute,который вызывается для получения значения атрибута элемента HTML

	var planet = document.getElementById("greenplanet");
	var alt = planet.getAttribute("id");
	alert(alt);

/*
	Сначала мы Получаем ссылку на элемент методом getElementById, после чего 
используем метод getAttribute элемента для получения атрибута
	В данном случае мы получим значение атрибута ID это "greenplanet",
	К примеру это может быть атрибуты вроде : alt,href,class...
*/
Что произойдет, если мой атрибут не существует в элементе?

Помните, что происходит при вызове getElementById,если идентификатор не существует в DOM? 
Вы получаете null. То же происходит и с getAttribute.Если атрибут не существует, вы получите null.
getElementById тоже может вернуть nul
Проверка выполняется так:

	var planet = document.getElementById("greenplanet");
	var alt = planet.getAttribute("id");
	if (alt == null) {
		alert("Oh, I guess there isn't an alt attribute.")
	}else {
	alert(alt);
	}

							Итак
function add() {
	var planet = document.getElementById("greenplanet");//Вызываем id и сохраняем в переменую planet
	if(planet == null) {//Простая проверка на null
		alert("this is null")
	}
	planet.innerHTML = "Go Go Go";//Изменяем на данный текст
	planet.setAttribute("class", "redtext");
	/*
		для обьекта planet создаем класс redtext
		соотвецтвенно в CSS есть данный класс который меняет цвет текста на крассный
	*/
}
window.onload = add;//функция будет вызванна после загрузки всех страници DOM
	
								ТИПЫ
В JavaScript существуют две категории типов: примитивы и объекты. Любое значение, которое не относится к примитивному типу, является объектом.
?Примитивы: числа, строки, булевские значения,null и undefined. Все остальное— объекты								
								
undefined — это значение, которое присваивается тому, что еще не 
имеет значения (другими словами, не было инициализировано)	
Какая польза от undefined? Оно позволяет проверить, было ли присвоено значение переменной (или свойству, или элементу массива)	
	
var x;
if (x == undefined) {
	alert("Переменная x не инициализирована! Принять меры!");
}
//Мы можем проверить, была ли инициализирована переменная.Просто сравните ее с undefined	

var header = document.getElementById("header");
if (header == null) {
     // Заголовка нет— какая-то серьезная проблема!
}
//Та же проверка только на null(убедиться в том, что вы получаете полноценный объект)
//Следует учитывать, что получение null не всегда означает, что что-то пошло нетак.Это может означать, что объект еще не существует и
//его нужно создать или его нужно пропустить при обработке
	
При помощи null можно проверить, существует объект или нет	
	
var weather = document.getElementById("weatherDiv");
if (weather != null) {
     // Создание содержимого для погодного виджета
}
//если он не null то он существует

	
	
Оператор typeof встроен в JavaScript. Он используется для проверки 
типа операнда (того, к чему применяется оператор). Пример:	
	
var x = "Alex";
var y = 22;
var checkX = typeof(x);
var checkY = typeof(y);
console.log(checkX);//В данном случае выводится тип string
console.log(checkY);//В данном случае выводится тип number	
	
//Оператор typeof получает операнд и определяет его тип

							Или ПРОЩЕ вызов
var x = 22;
var y = false;
console.log(typeof x);
console.log(typeof y);
						Разница между undefined и null 
null ---показуетяся когда объект еще не создан или не найден(К примеру  возьмем хотя бы метод 
document.getElementById Он ведь должен возвращать объект, верно? А что произойдет, если он не сможет вернуть объект? 
Тогда он должен вернуть какой-то признак, означающий: «Здесь мог бы быть объект, но, к сожалению, его нет». 
Именно этот смысл заложен в null)

undefined  ---значение для переменных, которые еще не были инициализированы(для неинициализированных переменных,
отсутствующих свойств объектов или отсутствующих значений в массивах,грубо говоря которые мы еше не задали)
	
var x = null;
console.log(typeof x);//Вернет Тип object ,а к примеру undefined вернет undefined(это его тип так как undefined значение,а у значения есть тип)
	
	
							NaN
В JavaScript используется значение NaN (сокращение от “Not a Number”,то есть «не число») для представления 
числовых результатов... не имеющих представления.Для примера возьмем 0/0. Результат 0/0 не имеет собственного 
представления на компьютере, поэтому в JavaScript он представляется специальным значением NaN
	
ВОЗМОЖНО, NaN— САМОЕ СТРАННОЕ ЗНАЧЕНИЕ В МИРЕ.Оно не только представляет все числовые 
значения, не имеющие собственного представления; это единственное значение в JavaScript, не равное самому себе!
Да, вы поняли правильно. Если сравнитьNaN сNaN, они не будут равны!	
	
Несколько примеров:
	
var a = 0/0; ---При вызове будет NaN	
var b = "food" * 1000; ---При вызове будет NaN
							
							Проверка
if (myNum == NaN) {
    myNum = 0; //Вроде бы должно работать... Но не работает
}
Почему? 
Потому что значение NaN не равно ничему, даже самому себе, значит, любые проверки равенства с NaN исключаются.
Вместо этого приходится использовать специальную функцию isNaN. Это делается так:
if (isNaN(myNum)) {
    myNum = 0;
}	
//Функция isNaN возвращает true, если переданное ей значение не является числом	

var b = "food" * 1000;
console.log(typeof b);

//Если проверить то нам выдаст числовой тип
/*
	Считайте, что имя NaN просто выбрано неудачно. Вероятно, вместо «не число» 
стоило использовать что-то вроде «число, не имеющее представления» 
Лучше всего рассматривать NaN именно так— как число, которое невозможно представить
*/	
	
var b = "food";
if (isNaN(b)) {
	b = 0;
}
console.log(b);

//Вернет true(if сработает и b будет 0), как и следовало ожидать
//Для переменной,содержащей значение NaN или любое другое значение, не являющееся числом, функция isNaN вернет true	
	
Значение The Infinity (или Infinity) в JavaScript представляет все значения, выходящие за границы представления чисел с 
плавающей точкой, то есть 1.7976931348623157E+10308 (или 1.7976931348623157E+10308 для Infinity). Значение Infinity имеет 
числовой тип. Используйте проверку на Infinity, если подозреваете,что ваше значение оказалось слишком большим:
if (tamale == Infinity) {
      alert("That's a big tamale!");
  }	
Infinity минус Infinity равно... вы не поверите... NaN. Чтобы понять это, вам лучше обратиться к хорошему математику	
	
		
			Оператор проверки равенства (также известный как ==)
if (99 == "99") {
    console.log("A number equals a string!");//Выдаст этот вариант
} else {
    console.log("No way a number equals a string");
}	
	
Оказывается, оператор == при сравнении учитывает типы своих операндов 
(то есть двух значений, которые вы сравниваете).Возможны два варианта:	
1)Если два значения относятся к одному типу, просто сравниваем их	
/*
	Если два сравниваемых значения имеют одинаковый тип (скажем, два числа или две строки), то сравнение работает как обычно: два значения 
просто сравниваются друг с другом. Если значения одинаковые, то результат равен true. Все просто
*/	
2)Если значения относятся к разным типам, пытаемся преобразовать их к одному типу, а потом сравниваем
/*
	Это более интересный случай.Допустим,сравниваются два значения с разными типами, например число и строка. 
	JavaScript пытается преобразовать строку в число, после чего сравнивает два значения:	

	99 == "99" --- Когда вы сравниваете число со строкой, JavaScript преобразует строку в число (если это возможно)
	
	99 == 99 --- а затем пытается выполнить сравнение повторно.Теперь,если значения равны, то результат будет true, а если нет— falsе
*/	
	
					Как происходит преобразование операндов
СЛУЧАЙ No1: Сравнение числа со строкой
При сравнении строки с числом всегда происходит одно и то же: строка преобразуется в число, после чего сравниваются два числа
	
СЛУЧАЙ No2: Сравнение булевского значения с любым другим типом	
/*
	В этом случае булевское значение преобразуется в число и два числа сравниваются. Выглядит 
немного странно, но происходящее становится более понятным, если просто запомнить, что 
true преобразуется в 1, а false преобразуется в 0. Также стоит помнить, что данная ситуация 
не всегда ограничивается одним преобразованием типа. Рассмотрим несколько примеров:
		
	1 == true ---Сравниваем число с булевским значением.Значение true преобразуется в число 1
	0 == false 
	
	Порядок такой:
	"1" == true ---Строка сравнивается с булевским значением.true преобразуется в число 1
	"1" == 1 ---Затем строка “1" сравнивается с 1
	1 == 1 ---строка преобразуется в число
	true ---Наконец, мы можем сравнить число с числом.Результат равен true
*/	
	
СЛУЧАЙ No3: Сравнение null с undefined	
/*
Сравнение этих значений дает результат true.Выглядит немного странно,но таковы правила.
Чтобы происходящее стало более понятным, эти значения фактически представляют «отсутствие значения» 
(то есть переменная или объект, не имеющие значения),поэтому они считаются равными

		undefined == null---Undefined и null всегда равны
*/	
	
некоторые преобразования могут застать вас врасплох. Один из примеров:
1 == "" ---Число сравнивается со строкой
1 == 0  ---Пустая строка преобразуется в число 0
false ---К сожалению, 1 и 0 не равны.Получаем false
	
	
Вероятно, вы уже поняли, что с числами оператор + выполняет сложение, а со строками— конкатенацию. 
Но что произойдет, если операнды + относятся к разным типам?
При попытке сложения числа со строкой JavaScript преобразует число в строку и 
выполняет конкатенацию (поведение противоположно тому, что происходит при проверке равенства):	
	
var x = 2 + "string"; //в результате "2string"	
	
Что касается других арифметических операторов— умножения, деления и вычитания,
— JavaScript рассматривает их как арифметические, а не строковые операции
	
var multi = 3 * "4"; //	Здесь JavaScript преобразует строку “4” в число 4, и умножает его на 3, получается 12

var divi = 80 / "10"; //Строка “10” преобразуется в число 10. Затем 80 делится на число 10, получается 8	
	
var mini = "10" — 5; //С вычитанием “10” преобразуется в число 10; получается 10 минус 5, то есть 5	
	

оператор + обладает так называемой левосторонней ассоциативностью, в следующей ситуации	
var order = 1 + 2 + " pizzas";	
	
/*
	вы получите строку “3 pizzas”, а не "12 pizzas", потому что при обработке выражения слева направо сначала  1 прибавляется к 2 
получается 3. Затем число 3 суммируется со строкой, поэтому 3 преобразуется в строку и объединяется с "pizza" посредством конкатенации. 
Чтобы избежать всякой неоднозначности, вы всегда можете использовать круглые скобки для обеспечения нужного порядка выполнения операторов
*/	
	
var order = 1 + (2 + " pizzas");
результатом будет строка “12 pizzas”	
	
			Если проверить два объекта на равенство
Две ссылки равны только в том случае, если они ссылаются на один объект	
Другими словами если создать обьект var1 и сравнить его с var2 (даже если у них все одинаковое )проверка пройдена не будет
А если создать обьект var3 и присвоить ему var1 и проверить их то проверка будет пройдена
	
	
Существуют значения,которые не являются ни true, ни false, но при этом интерпретируются 
как true или false в условных выражениях. Мы называем эти выражения «псевдоистиной» и «псевдоложью», 
потому что с технической точки зрения они не являются булевскими значениями, но ведут себя как 
булевские значения (опять же — в условных выражениях)
Еще раз: чтобы запомнить, какие значения считаются псевдоистинными, а какие псевдоложными, следует запомнить псевдоложные. 
Остальные значения относятся к псевдоистинным. Итак, псевдоложные значения: 

undefined
null
0
пустая строка
NaN

Просто запомните пять псевдоложных значений— undefined, null, 0, "" и NaN. Все остальное JavaScript рассматривает как псевдоистину
								К примеру
var testThis;
if (testThis) {
   // Не сработает undefined
}
var element = document.getElementById("elementThatDoesntExist");
if (element) {
   // Будет false так как этого обьекта нету,неправилный id
}
if (0) {
   // Не сработает 0 нельзя ставить
}
if ("") {
   // Не сработает пустую строку нельзя ставить будет false
}
if (NaN) {
   // Не сработает NaN ы
}

						Все остальное сработает 
						К Примеру:
if ([]) {
   // Будет выполняться,Это массив. Он не является undefined,null, zero, “” или NaN.А значит,интерпретируется как true!
}
var element = document.getElementById("elementThatDoesExist");
if (element) {
   // Будет выполняться, id написан правильно соотвецтвенно елемент будет доставатся
}
if (1) {
   // Будет выполняться, только 0 не работает
}
var string = "mercy me";
if (string) {
   //Будет выполняться,Псевдоложна только пустая строка, все остальные строки псевдоистинны
}
var testThis;
if(" ") {
	alert("GG"); //Сработает,Любая непустая строка псевдоистинна, даже если она состоит только из одного пробела
}



							Строки
Свойство length содержит количество символов в строке.Его удобно использовать при переборе символов строки

							Метод charAt
							
var input = "jenny@wickedlysmart.com";
for(var i = 0; i < input.length; i++) { //Свойство length используется для последовательного перебора символов строки
    if (input.charAt(i) === "@") {//А метод charAt получает символ с конкретным индексом в строке
	console.log("There's an @ sign at index " + i);
       }
}
/*
	Метод charAt получает целое число от 0 до длины строки (минус 1) и возвращает строку с ОДНИМ символом, 
	находящимся в заданной позиции. Строку можно рассматривать как массив, элементами которого являются отдельные символы, 
	а индексы начинаются с 0 (как и в обычных массивах).Если переданный индекс больше либо равен длине строки, возвращается пустая строка
*/
					метод indexOf (и метод lastIndexOf)
Метод получает строку-аргумент и возвращает индекс первого символа первого вхождения аргумента в своей строке

var phrase = "the cat in the hat";
var index = phrase.indexOf("cat");//Мы хотим найти позицию первого вхождения “cat" в исходной строке
console.log("there's a cat sitting at index " + index);

Также можно передать второй аргумент— индекс начальной позиции поиска

index = phrase.indexOf("the", 5);
console.log("there's a the sitting at index " + index);
	
/*
	Так как поиск начинается с индекса 5, первое вхождение “the" пропускается, 
и обнаруживается второе вхождение “the” с начальным индексом 11
	Если строку найти не удалось, метод возвращает -1
*/
lastIndexOf ---Аналогичен indexOf, но находит последнее вхождение (вместо первого)


							метод substring	(ОЧЕНЬ ВАЖНЫЙ)
Метод substring получает два индекса, после чего извлекает и возвращает заключенную между ними строку
	
var da = "cat where is my cat";
var index = da.substring(4,9);
console.log(index);	
	
/*
	Метод возвращает строку,начинающуюся с индекса 4 и заканчивающуюся индексом 9 (не включая его)
	Второй индекс можно не указывать, в этом случае substring извлекает строку, 
которая начинается с первого индекса и продолжается до конца исходной строки
*/	
								
							метод split
Метод split получает символ-ограничитель и разбивает строку на части по позиции ограничителя	
	
var data = "name|phone|address";
var vals = data.split("|");
console.log("Split array is ", vals);	
	
/*
	Метод split использует ограничитель для разбиения исходной строки на части,которые возвращаются в массиве
	Обратите внимание: при вызове console.log передаются два аргумента, разделенных запятой. В этом случае массив 
vals не преобразуется в строку перед выводом на консоль.Если поставить + то все будет слитно и без [] 	
*/	
----------------------------------------------------	
toLowerCase ---	Возвращает строку,в которой все символы верхнего регистра преобразуются к нижнему регистру(большие буквы становятся маленькими)
var data = "NAME WHERE i WAS BORN WOS DIFFICULT";
var da = data.toLowerCase();
console.log(da);
//toUpperCase() --тоже самое только большие буквы превращает в маленькие
----------------------------------------------------

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
Метод replace ищет совпадение между регулярным выражением и строкой текста и заменяет найденное совпадение (если оно имеется) новой строкой
Обратите внимание: вместо регулярного выражения можно использовать обычную строку

строка.replace(регулярное_выражение,новая_строка)

var str = "HTML - объектно-ориентированный скриптовый язык программирования выполняющийся на стороне клиента. HTML - позволяет сделать веб-страницы динамичными.";
//Теперь произведем глобальную замену в ней и отобразим результат
document.write(str.replace(/HTML/g,"JavaScript"));
/*
	/HTML/g -Это регулярное выражение
	/HTML/ ---Выбирает HTML,если оставить так то метод заменит только первую HTML которую встретит
	/HTML/g  ---g означает все HTML ,тоисть заменит все HTML	
*/
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

-------------------------------------------------------------
Метод slice позволяет извлечь указанную часть строки
Обратите внимание: данный метод не изменяет строку из которой производится извлечение

var str = "Европа — одна из шести частей света.";
document.write(str.slice(8,22) + "<br />");//Скопирует с 8й по 22(результат: одна из шести)
document.write(str.slice(8) + "<br />");//с 8й и до конца (результат: одна из шести частей света.)
document.write(str.slice(-7));//Начнет копирование с конца и скопирует последние 7 символов(результат: света.)
-------------------------------------------------------------
	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
С помощью метода concat Вы можете объединить две и более строки и возвратить результат
Обратите внимание: данный метод не изменяет существующие строки он лишь возвращает их объединенную копию

//Создадим несколько произвольных строк
str1 = "Я ";
str2 = "короткая ";
str3 = "строка!";
//Объединим строки и отобразим результат
document.write(str1.concat(str2,str3) + "<br />");
//Теперь отобразим исходные строки чтобы убедится что
//они не были изменены
document.write(str1 + "<br />");
document.write(str2 + "<br />");
document.write(str3 + "<br />");
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	
	
--------------------------------------------------------------
trim ---Метод Удаляет пропуски с обоих концов строки. Метод удобен при обработке данных,вводимых пользователем

var str = "       Hello World!        ";
alert(str.trim()); //уберает все пропуски
--------------------------------------------------------------	
	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
Метод match ищет совпадение между переданным регулярным выражением и строкой текста и возвращает массив из найденных совпадений или ноль если совпадения не были найдены.
строка.match(регулярное_выражение)
регулярное_выражение-Является обязательным параметром
ссылка на регулярные выражения http://www.wisdomweb.ru/JS/obreg.php

var str = "Европа — одна из шести частей света. Скорость света — абсолютная величина скорости распространения электромагнитных волн в вакууме.";
document.write(str.match(/света/g));//Тоисть не важно сколько света раз попадется мы все их отобразим
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	
	
							ОБЬЕКТЫ(ООП) В МАССИВАХ
var ships = [{ locations: ["10", "20", "30"], hits: ["", "", ""] },
             { locations: ["32", "33", "34"], hits: ["", "", ""] },
             { locations: ["63", "64", "65"], hits: ["", "", "hit"] }];

			 
var ship2 = ships[1];
var loc = ship2.locations;
console.log(loc);	
/*
	Сначала создаем переменную ship2 и ей присваиваем индекс 1
	Затем создаем вторую переменную loc и вызываем метод locations
	Выводим сразу целлый массив("32", "33", "34")
	Другими словами сначала мы входим в массив так сначала идут [] а уже в них {} ,
сначала обращаемся к массиву а потом к обьекту внутри него
*/	

Что бы вызвать к примеру из этого же массива  ["32", "33", "34"] скажем 33:

var ship2 = ships[1];
var loc = ship2.locations[1];
console.log(loc);




							СЦЕПЛЕНИЕ
Некоторые ссылки можно сократить посредством сцепления— ссылки на объекты объединяются в цепочки, позволяющие избежать 
создания временных переменных (таких, как переменная locations в приведенном коде)

for (var i = 0; i < this.numShips; i++) {
  var ship = this.ships[i];
  var locations = ship.locations;
  var index = locations.indexOf(guess);
  ...
}

Этот код можно преобраховать посредством сцепления в:
var index = ship.locations.indexOf(guess);	
	
Сцепление в действительности представляет собой сокращенную форму записи для 
обращения к свойствам и методам объектов (и массивов)	
								Пример:
var ships = [{ locations: ["10", "20", "30"], hits: ["", "", ""] },
             { locations: ["32", "33", "34"], hits: ["", "", ""] },
             { locations: ["63", "64", "65"], hits: ["", "", "hit"] }];

var  index = ships[1].locations[1];
/*
	ships[1] ---сначала идет имя переменной затем номер индекса по счету который хотим вызвать
	locations[1] ---потом имя обьекта который вызываем и его конкретный индекс
*/
console.log(index);			 
//В результате выведится 33	
	
							ЦЫКЛ  do while
Цикл do while работает почти так же, как while, за одним исключением: он сначала выполняет команды в теле цикла,а потом проверяет условие. 
Некоторые логические условия (хотя это бывает не так часто)лучше подходят для циклов do while, чем для циклов while		
Цикл do..while часто называют циклом с постусловием, потому что в отличие от предыдущих циклов он вначале исполняет блок команд и только потом проверяет заданное условие	
	
В примере ниже цикл do..while исполнит блок кода несмотря на то, что условие ложно изначально	
	
var i=20;
do {
   document.write('Если Вы видите этот текст код в цикле был исполнен.');
}
while (i<=3);	
	
Цикл do while аналогичен циклу while за исключением того, что условие проверяется после однократного выполнения команд тела цикла	
	
		ГЕНЕРАТОР СЛУЧАЙНЫХ ЧИСЕЛ В ДИАПАЗОНЕ(ОТ 100 ДО 500)
for (var i = 0; i < 482; i++) {
	var minRange = 100;
	var maxRange = 500;
	
	var range = maxRange - minRange;
	var random = Math.floor((Math.random() *range) + minRange);
	document.write(random + "<br />");
}		
	
	
							Собития
Вы уже знаете, что после загрузки и отображения страницы браузер не сидит без дела. За кулисами идет бурная жизнь: 
пользователи нажимают кнопки,отслеживаются перемещения мыши, поступают данные, меняются размеры окон, 
срабатывают таймеры и т. д. Все это приводит к срабатыванию событий.Каждый раз, когда происходит событие, ваш код получает 
возможность обработать его.Каждый раз, когда происходит событие, вашему коду предоставляется возможность обработать его


						Обработчик события
Обработчики пишутся для обработки событий. Как правило, обработчик представляет собой небольшой фрагмент кода, 
который должен выполняться при возникновении события. В программном коде обработчик представляет собой обычную функцию. 
Когда происходит событие, вызывается функция-обработчик.Чтобы ваш обработчик вызывался при возникновении события, его необходимо сначала зарегистрировать

						Как создать первый обработчик событий
1.Сначала необходимо написать функцию, которая обрабатывает событие загрузки страницы. 
В нашем случае функция при завершении загрузки просто выводит сообщение «I’m alive!»						
function pageLoadedHandler() {//Обработчик— это обычная функция
	alert("I'm alive!");
}//Еще раз напомним, что обработчики также часто называются «функциями обратного вызова»
2.Обработчик написан и готов к работе. Теперь нужно создать необходимые связи, чтобы браузер знал о функции, 
которая должна вызываться при каждом возникновении события загрузки страницы

window.onload = pageLoadedHandler;
/*
Теперь при возникновении события загрузки страницы будет вызываться функция pageLoadedHandler
Вскоре вы увидите, что для разных событий используются разные способы назначения обработчиков
*/

3.Вот и все! Теперь можно устроиться поудобнее и понаблюдать за тем, как браузер будет вызывать функцию, 
связанную со свойством window.onload, при загрузке страницы
							Детальный разбор
<!doctype html>//Сначала браузер загружает страницу, начинает разбор HTML и построение DOM
<html lang="en">
<head>
  <meta charset="utf-8">
  <title> I'm alive! </title>
  <script>
    window.onload = pageLoadedHandler;//Добравшись до сценария,браузер начинает выполнение кода
    function pageLoadedHandler() {
        alert("I'm alive!");//В данный момент браузер просто определяет функцию,которая назначается свойству window.onload.Напомним,что функция будет вызываться при полной загрузке страницы
    }
  </script>
</head>
<body>//Тогда браузер продолжает разбор HTML
</body>//Когда браузер завершает разбор HTML и модель DOM готова к использованию,браузер вызывает обработчик события загрузки страницы
</html>//Что в данном случае приводит к созданию сообщения «I’m alive»
	
	
//document.getElementsByTagName Этот метод получает имя тега (допустим,img,p или div) и возвращает список подходящих элементов	
var images = document.getElementsByTagName("img");
	//Здесь происходит выборка элементов по имени тега img.Вызов находит все теги изображения на странице и возвращает весь набор. 
	//Результат сохраняется в images
	for (var i = 0; i < images.length; i++) {
			images[i].onclick = showAnswer;
	}
	/*
		Затем мы перебираем все изображения и поочередно назначаем обработчик события щелчка showAnswer 
		каждому изображению. После завершения цикла свойству onclick каждого изображения назначен обработчик showAnswer
	
		Так как я понимаю document.getElementsByTagName("img") возвращает все данные в переменную image массивом и
		потом мы с помощью image[i] перебераем этот массивчик и говорим чтобы при клике на любое изобращение вызваем функцию showAnswer
	*/	
								Более подробно
var images = document.getElementsByTagName("img");
/*
	Метод возвращает список объектов элементов, соответствующих заданному имени тега
	Возвращается список объектов,напоминающий массив. Формально он не является массивом,но похож на массив по своим характеристикам
	Обратите внимание на букву “s” в имени— метод возвращает не один объект, а набор объектов
*/
							Примечание
Вы сказали, что метод getElementsByTagName возвращает список. Имеется в виду массив?

Метод возвращает объект, с которым можно работать как с массивом, но на самом деле это объект типа NodeList. 
Объект NodeList представляет коллекцию узлов (технический термин для объектов элементов в дереве DOM). Чтобы выполнить перебор коллекции, 
следует получить ее длину из свойства length, а затем последовательно обратиться к каждому элементу NodeList по индексу в квадратных скобках 
(так же,как это делается с массивами). Впрочем, на этом сходство между NodeList и массивом завершается, поэтому в остальном при 
работе с объектом NodeList необходимо действовать осторожно.Обычно это все,что необходимо знать о NodeList,если только вы не собираетесь добавлять и удалять элементы из DOM
	
	
При вызове обработчик события щелчка получает объект события— более того, этот объект передается для большинства событий, связанных 
с моделью DOM. Объект события содержит общую информацию о событии: какой элемент породил это событие, в какое время оно произошло 
и т. д. Кроме того, передается информация, связанная с конкретным событием: например, для щелчка мышью вы получите координаты точки щелчка	
	
Давайте последовательно разберемся, как работают объекты событий:
Возьмем для примера нашу игру:
1.Вы щелкаете на изображении.
2.происходит событие щелчка.
3.для которого создается объект события.
4.который передается обработчику события	
function showAnswer(eventObj) {//eventObj---Событие
   ...
   В обработчике можно использовать этот объект для получения
информации о событии: тип события, породивший его элемент и т. д.
}	

Как было сказано ранее, объект события содержит как общую, так и специализированную информацию о событии
Общая информаия включает свойство target, в котором хранится ссылка на объект, сгенерировавший событие. 
Итак, если пользователь щелкнул на элементе страницы (например, на изображении), этот элемент 
является источником события и к нему можно обратиться следующим образом:	
	
function showAnswer(eventObj) {//это не обязательное имя можно придумать свое
   var image = eventObj.target;//Свойство target сообщает, какой элемент сгенерировал данное событие
}	
	
	
Браузер обрабатывает события последовательно, поэтому обработчики должны быть по возможности короткими и эффективными. 
В противном случае очередь событий может переполниться, и браузер столкнется с необходимостью обработать их все. 
Что это означает для вас? Что интерфейс начнет «тормозить» и с большими задержками реагировать на действия пользователя	
Браузер перебирает события в очереди от старых к новым, обрабатывая каждое событие	
Если все станет совсем плохо, на экране появляется диалоговое окно с сообщением об остановке сценария. 
Это означает, что браузер не знает, что делать дальше,и перекладывает ответственность на вас!
Тоисть браузер 	обрабатывает события последовательно, а не одновременно
	
	
					Событие перемещения мыши
Событие перемещения мыши сообщает обработчику о том, что указатель мыши переместился над 
некоторым элементом. Обработчик назначается свойству onmousemove элемента. При вызове 
обработчику передается объект события, который предоставляет следующие свойства:					
					
clientX, clientY: смещение (в пикселах) указателя мыши от левого (и верхнего) края окна браузера					
screenX, screenY: смещение (в пикселах) указателя мыши от левого (и верхнего) края пользовательского экрана					
pageX, pageY: смещение (в пикселах) указателя мыши от левого (и верхнего) края страницы браузера					
					
							Еще больше событий
Допустим, вы хотите, чтобы ваша программа ожидала 5 секунд перед выполнением некоторой операции. 
Вот как это делается с функцией setTimeout и обработчиком:
					
function timerHandler() {//Сначала мы пишем обработчик события. Этот обработчик будет вызван при возникновении события таймера
	alert("Hey what are you doing just sitting there staring at a blank screen?");
}
setTimeout(timerHandler, 5000);					
/*
	Вызов setTimeout можно сравнить с установкой секундомера
	вызывается функция setTimeout, которая получает два аргумента: обработчик события и интервал времени (в миллисекундах)
	мы приказываем таймеру ожидать 5000 миллисекунд (5 секунд)	
Браузер следит за всеми таймерами (да, можно запустить сразу несколько таймеров) и обработчиками, которые должны вызываться по этим таймерам
setTimeout не поддерживает дополнительные аргументы в IE8 и ранее
*/					

/*
	Для того чтобы изображение открывалось без щелчка— простым наведением указателя мыши
	Для этого необходимо воспользоваться событием наведения указателя мыши (mouseover). 
	Обработчик этого события для любого элемента страницы назначается в свойстве onmouseover:

	myElement.onmouseover = myHandler;
	
	Кроме того, событие mouseout сообщает о выходе указателя мыши за границы элемента. 
	Обработчик этого события определяется свойством onmouseout
*/					
					
function time(){
//Определим текущее время
var dat = new Date();
var hour=dat.getHours();
var min=dat.getMinutes();
var sec=dat.getSeconds();
tim=hour+':'+min+':'+sec;
//Выведем текущее время в абзац с id=text1
document.getElementById('display').innerHTML=tim;
}
/* Функция start будет вызвана после полной загрузки страницы и будет вызывать функцию
time() каждую секунду */
function start(){
id=setInterval('time()',1000);
}
/* С помощью функции stop Вы можете остановить выполнение кода */
function stop(){
clearInterval(id);
}
start();

setTimeout(stop, 5000);					
					
/*
	Пример часов
	setInterval будет показывать время с интервалом  секунда
*/				

Установка компонентов даты

Следующие методы позволяют устанавливать компоненты даты и времени:

    setFullYear(year [, month, date])
    setMonth(month [, date])
    setDate(date)
    setHours(hour [, min, sec, ms])
    setMinutes(min [, sec, ms])
    setSeconds(sec [, ms])
    setMilliseconds(ms)
    setTime(milliseconds) (устанавливает всю дату по миллисекундам с 01.01.1970 UTC)

Все они, кроме setTime(), обладают также UTC-вариантом, например: setUTCHours().

Также это используют для получения даты, отдаленной от имеющейся на нужный промежуток времени. Например, получим дату на 70 секунд большую текущей:

var d = new Date();
d.setSeconds(d.getSeconds() + 70);

alert( d ); // выведет корректную дату


												Дата в формате 30.01.14
var now = new Date();

function formatDate(date) {
	var dd = date.getDate();
	if(dd < 10) {
		dd = "0" + dd;
	}
	var mm = date.getMonth();
	if(mm < 10) {
		mm = "0" + mm;
	}	
	var yy = date.getFullYear();
	if(yy < 10) {
		yy = "0" + yy;
	}
	return dd + "." + mm + "." + yy;
}

console.log(formatDate(now));

												Дата в рус формате
var now = new Date();

function formatOfDays(date) {
	var days = ["Воскресенье", "Понедельник", "Вторник", "Среда", "Четверг", "Пятница", "Суббота"];
	var months = ["Январь", "Февраль", "Март", "Апрель", "Май", "Июнь", "Июль", "Август", "Сентябрь", "Октябрь", "Ноябрь", "Декабрь"];
	return days[date.getDay()] + " " + months[date.getMonth()] + " " + date.getFullYear() ;
}


console.log(formatOfDays(now));												
												
	
							Еще Собития
						onkeypress
Код переданный обработчику события onkeypress выполнится после того, как любая клавиша на клавиатуре будет нажата					
function da() {
	var doc = document.getElementById("text1");
	doc.onkeypress = g;
}
function g() {
	alert("ss");
}
da();
<input id='text1' type='text'/>					
					
//Когда мы вводим в поле любую букву,цыфру то срабатывает событие					

-------------------------------------------------------------					
					Собитие-window.onunload

Когда человек уходит со страницы или закрывает окно, срабатывает window.unload. В нём можно сделать что-то, не требующее ожидания, например, закрыть вспомогательные popup-окна, но отменить сам переход нельзя.
Это позволяет другое событие — window.onbeforeunload, которое поэтому используется гораздо чаще.

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

					Собитие	window.onbeforeunload
Если посетитель инициировал переход на другую страницу или нажал «закрыть окно», то обработчик onbeforeunload может приостановить процесс и спросить подтверждение.
Для этого ему нужно вернуть строку, которую браузеры покажут посетителю, спрашивая — нужно ли переходить.
Например:

window.onbeforeunload = function() {
  return "Данные не сохранены. Точно перейти?";
};					
/*
	Firefox игнорирует текст, он показывает своё сообщение
Firefox игнорирует текст, а всегда показывает своё сообщение. Это сделано в целях большей безопасности посетителя, чтобы его нельзя было ввести в заблуждение сообщением
*/					
					
----------------------------------------------------------------
						Событие onmouseover
При наведении указателя мыши на элемент генерируется это событие												
function yes() {
	var doc = document.getElementById("display");
	doc.onmouseover = da;
}
function da() {
	for(var i = 0; i < 1; i++) {
		console.log("GG")
	}
}	
yes();//Каждый раз когда мы наводим на елемент display цыкл прибавляет 1
					
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
						Событие onmouseout
Событие генерируется при выходе указателя мыши за границы элемента					
function yes() {
	var doc = document.getElementById("display");
	doc.onmouseout = da;
}
function da() {
	var doc = document.getElementById("display");
	doc.setAttribute("class", "red");
}	
yes();//Когда мы наводим ничего не происходит,а когда выводим указатель мыши то фон у елемента становится крассным					
				
--------------------------------------------------------------------
							Событие onplay
Страница содержит элемент <video>? Вы будете получать это событие при нажатии кнопки воспроизведения
var aud = document.getElementById("myAudio");
aud.onplay = function() {
    alert("The audio has started to play");
};

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
						
						Событие onpause							
var vid = document.getElementById("myVideo");
	vid.onpause = function() {
    alert("The video has been paused");
};													
														
-------------------------------------------------------------------							
							
							Событие onresize
Событие генерируется при каждом изменении размера окна браузера
function da() {
	var doc = document.getElementById("display");
	doc.innerHTML = doc.innerHTML + "Resize is happened";
}	
window.onresize = da;//Каждый раз когда происходит изменении размера окна браузера добавляется Resize is happened

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
							Событие Drag&Drop
dragstart - Событие генерируется при перетаскивании элемента на странице
drop - Событие генерируется при отпускании перетаскиваемого элемента
//Достаточно сложные события ссылка ниже,там и примеры

http://habrahabr.ru/post/187582/

-------------------------------------------------------------------
							Событие touchstart
Событие генерируется при прикосновении к элементам наустройствах с сенсорными экранами			

//Тоже достаточно сложная тема и пока не нужная ссылка ниже,там и начало и конец и движение,вообщем все есть

http://y3x.ru/2011/04/js-touch-events/
http://habrahabr.ru/post/118318/

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

							Изучаем функции и блистаем
							Функции но только на более высоком уровне
function fly(name) {
for (var i = 0; i <= name; i++) {
		console.log(i);
	}	
}
fly(4); //---Это как обычно мы пишем функцию

var fly = function(name) {
	for (var i = 0; i <= name; i++) {
		console.log(i);
	}
}
fly(3);//А вот это уже другой способ,через переменную fly

/*
	Такое использование ключевого слова function— внутри команды, как в команде присваивания,— называется функциональным выражением. 
Обратите внимание: в отличие от объявления, эта функция не имеет имени. Кроме того, результатом этого выражения является значение, 
которое затем присваивается переменной fly.Что это за значение? Мы присваиваем его переменной fly, а затем вызываем через эту переменную,значит, это должна быть ссылка на функцию
Ссылки могут использоваться для вызова функции. Кроме того, их можно присваивать переменным, сохранять в  объектах, передавать и возвращать из функций (как и ссылки на объекты)
*/
							Как это все читает браузер
/*
	1)когда он видит два кода(выше которые) он пропускает переменную fly и читаем функцию fly,Первый раз браузер читает все функции,и браузер сохраняет для использования в будущем(все функции сохраняет браузер,в нашем случае только одну)
	2)Потом начинает выполнение,видит функцию fly и создает для нее переменную с именем fly и выполняет код,когда браузер видит переменную fly с функциональным выражением то сохраняет эту функцию в переменую fly
Функциональное выражение не присваивает ссылку на функцию ничему; вам приходится делать это самостоятельно
*/
							Отличие функции от функционального выражения
/*
	1)Прежде всего, с объявлением функция создается и подготавливается до обработки остального кода. С функциональным выражением функция создается при выполнении кода,на стадии выполнения(первая стадия чтения всех функций,потом браузер уже выполняет весь код)
	2)Другое отличие связано с именами функций— с объявлением имя функции используется для создания переменной, содержащей ссылку на функцию. Кроме того, при использовании функционального выражения имя функции обычно не указывается, 
а функция либо присваивается переменной в коде, либо функциональное выражение используется иным образом
*/							
								
function quack(num) {//С объявлением функции JavaScript берет на себя присваивание ссылки переменной с заданным вами именем (в данном случае quack) 
   for (var i = 0; i < num; i++) {
      console.log("Quack!");
   }
}
var fly = function(num) {//С функциональным выражением необходимо присвоить полученную ссылку переменной самостоятельно.В данном случае ссылка сохраняется в переменной fly 
   for (var i = 0; i < num; i++) {
      console.log("Flying!");
   }
}

var superFly = fly;//После того как значение из fly будет присвоено superFly, переменная superFly содержит ссылку на функцию.Добавив круглые скобки и аргумент, мы сможем вызвать функцию
superFly(2);

var superQuack = quack;//И хотя переменная quack была создана по объявлению функции,хранящееся в quack значение тоже представляет собой ссылку на переменную, поэтому мы можем присвоить его переменной superQuack и вызвать функцию
superQuack(3);

//Другими словами, ссылка остается ссылкой независимо от того, как она была создана (по объявлению функции или функциональному выражению)!

									Первокланый значения(передача функции переменной,передача функции функции и возвращение функции)
						
var passengers = [{name: "Jane Doloop", paid: true,ticket: "coach"},
					{name: "Dr. Evel", paid:true, ticket: "firstclass"},
					{name: "Sue Property", paid: false, ticket: "firstclass"},
					{name: "John Funcall", paid: true,ticket: "coach"}];
/*
	Структура данных, представляющая пассажиров
	Все пассажиры хранятся в массиве
*/

//передача функции другой функции
function processPassengers(passengers, testFunction) {
	for (var i = 0; i < passengers.length; i++) {//В цикле последовательно перебираем всех пассажиров
		if(testFunction(passengers[i])) {//И вызываем проверочную функцию для каждого пассажира
			return false;
		}
	}
	return true;//Если управление передано в эту точку, значит, все пассажиры прошли проверку, и функция возвращает true
}
/*
	Функция processPassengers получает два параметра.В первом параметре передается массив пассажиров(passengers)
	Второй параметр(testFunction) содержит функцию,которая умеет проверять некоторое условие для пассажира
	Если проверочная функция возвращает true, то мы возвращаем false. Иначе говоря, если пассажир не прошел проверку (не заплатил за билет, входит в «черный список» и т.д.), вылет следует запретить!	
*/

//Теперь осталось написать функции проверки пассажиров

function checkNoFlyList(passenger) {
	return (passenger.name === "Dr. Evel");
}
/*
	Обратите внимание: функция получает один объект passenger, а не массив passengers (массив объектов)
	Эта функция проверяет, входит ли пассажир в «черный список». Наш «черный список» прост: полеты разрешены всем, кроме доктора Зло. 
Для всех остальных пассажиров возвращается false (то есть пассажир не входит в «черный список»)
*/

function checkNotPaid(passenger) {
	return (!passenger.paid);//Если не равно true
}
/*
	А эта функция проверяет, заплатил ли пассажир за билет. Для этого достаточно проверить свойство paid объекта пассажира.Если билет не оплачен, возвращаем true
*/

var allCanFly = processPassengers(passengers, checkNoFlyList);
if (!allCanFly) {
	console.log("The plane can't take off: we have a passenger on the no-fly-list.");
}
/*
	Если хотя бы один из пассажиров присутствует в «черном списке», функция возвращает false и на консоль выводится соответствующее сообщение
*/

var allPaid = processPassengers(passengers,checkNotPaid);
if (!allPaid) {
	console.log("The plane can't take off: not everyone has paid.");
}


function printPassenger(passenger) {
			var name = passenger.name; 
			var paid = passenger.paid; 
			if (paid) {
				console.log(name + " has paid");
			}else {
				console.log(name + " has't paid");
			}
return false;
}

processPassengers(passengers, printPassenger);

function serveCustomer(pessenger) {
	var getDrinkOrderFunction = createDrinkOrder(pessenger);//getDrinkOrder теперь возвращает функцию, которая сохраняется в переменной getDrinkOrderFunction
	getDrinkOrderFunction();//Благодаря функциям вызов происходит 1 раз вместо 4х
	/*
	Программа, в которой вся встроенная логика выбора заменяется одним вызовом функции, безусловно, лучше читается. 
	Весь код  хранится в одном месте, которое легко найти, и это удобно
	*/
	
}
function createDrinkOrder(pessenger) {
	var orderFunction;
	/*
Вместо того,чтобы многократно вызывать createDrinkOrder для каждого пассажира, мы вызываем функцию только один раз.Она должна вернуть функцию, которая знает, как заказывать напитки для этого пассажира	
	Создается переменная для хранения функции, которую мы возвращаем
	Теперь код проверки типа билета пассажира выполняется только один раз
	*/
	if (pessenger.ticket === "firstclass"){
		orderFunction = function() {//Если пассажир летит первым классом,создается функция,которая принимает заказы напитков для первого класса
			alert("Would you like a cocktail or wine?");	
		}
	}else {
		orderFunction = function() {//В противном случае создается функция для заказа напитков пассажирами второго класса
			alert("Your choice is cola or water.");
		}
	}
	return orderFunction;//Возвращаем функцию
}
//Вся логика заказа напитков размещается в этой функции

function servePassengers(passengers) {
	for (var i = 0; i < passengers.length; i++) {
		serveCustomer(passengers[i]);//По сути мы перебираем пассажиров в массиве passengers и вызываем serveCustomer для каждого пассажира
	}
}
servePassengers(passengers);

							СОРТИРОВКА ПО ВОЗРОСТАНИЮ
//Что бы поменять по убыванию нужно просто поменять числа в функции  compareNumbers(к примеру в первой случае возвращаеть должно не 1,а -1, в третьем не -1,а 1, или просто поменять знак в первом случае с > на <)
var numbersArray = [60, 50, 62, 58, 54, 54];
/*
	Теперь нужно написать функцию,которая умеет сравнивать два значения из массива.В нашем случае используется массив чисел,так что функция должна сравнивать два числа
	Допустим, числа требуется отсортировать по возрастанию; тогда метод sort ожидает, что если первое число больше второго, функция возвращает положительный 
результат, при равенстве чисел— 0, а если первое число меньше— отрицательный результат.
*/
function compareNumbers(num1, num2) {//Массив состоит из чисел,поэтому функция должна сравнивать два числа
	if (num1 > num2) {
		return 1;
	}else if (num1 === num2) {
		return 0;
	}else {
		return -1;
	}
}
//Теперь, когда функция сравнения написана,остается лишь вызвать метод sort для массива numbersArray и передать функцию при вызове
numbersArray.sort(compareNumbers);//Мы вызываем метод sort для массива и передаем ему функцию compareNumbers
console.log(numbersArray);//После вызова sort массив отсортирован по возрастанию
//Обратите внимание: метод sort является деструктивным, то есть он изменяет исходный массив вместо того, чтобы возвращать новый отсортированный массив
/*
Метод sort отсортировал numbersArray по возрастанию, потому что при возвращении 1, 0 и 1 мы сообщаем методу sort:
   1: первое значение должно располагаться после второго;
   0: значения эквивалентны, их можно не переставлять;
	1: первое значение должно располагаться перед вторым
*/
				Сортировка в массиве с обьектом

var products = [ { name: "Grapefruit", calories: 170, color: "red", sold: 8200 },
                 { name: "Orange", calories: 160, color: "orange", sold: 12101 },
                 { name: "Cola", calories: 210, color: "caramel", sold: 25412 },
                 { name: "Diet Cola", calories: 0, color: "caramel", sold: 43922 },
                 { name: "Lemon", calories: 200, color: "clear", sold: 14983 },
                 { name: "Raspberry", calories: 180, color: "pink", sold: 9427 },
                 { name: "Root Beer", calories: 200, color: "caramel", sold: 9909 },
                 { name: "Water", calories: 0, color: "clear", sold: 62123 }
               ];
			   
function compareSolid(colaA, colaB) {
	if (colaA.sold > colaB.sold) {//просто добавляем имя обьекта
		return 1;
	}else if(colaA === colaB) {
		return 0;
	}else {
		return -1;
	}
}	
/*
	function compareSolid(colaA, colaB) {
	return colaA.sold - colaB.sold;
}
Или такой более короче вариант
*/	
products.sort(compareSolid);
for (var i = 0; i < products.length; i++) {
	console.log(products[i].sold);
}

/*
	function result(gg) {
	for (var i = 0; i < gg.length; i++) {
	console.log("Name: " + gg[i].name + " Calories: "+ gg[i].calories+ " Color: "+ gg[i].color+ " Sold: "+ gg[i].sold);
	}
}
result(products);
Или можем вывести сразу все данные с учотом сортировки
*/
//Метод sort может использоваться для любых массивов (числа, строки, объекты) и для любых видов сортировки (по возрастанию и по убыванию)
Для алфавита точно такаяже сортировка только там сначала сортирует большие буквы,а потом маленькие(тоисть если есть azbuka и Dudka от сначала будет идти Dudka,а потом azbuka потому что azbuka с маленькой начинается)


						анонимные функции, область действия и замыкания

	Вы уже видели две стороны функций— формальную, декларативную сторону объявлений функций и более свободную и выразительную сторону функциональных выражений. 
Пришло время открыть еще одну интересную сторону: анонимную.Анонимными называются функции,которые определяются без имени.Как такое возможно? 
Когда вы определяете функцию в объявлении функции, у этой функции безусловно существует имя. Но при определении функции с использованием функционального выражения присваивать функции имя не обязательно
Дело в том, что анонимные функции часто делают код более лаконичным, более четким, удобочитаемым и эффективным и даже упрощают его сопровождение

//Это обычный код,так мы писали раньше до анонимных функций
function handler() { alert("Yeah, that page loaded!"); }
window.onload = handler;
/*
	Анонимные функции упрощают подобный код. Анонимная функция представляет собой функциональное 
выражение без имени, которое используется там, где обычно должна располагаться ссылка на функцию
*/

window.onload = function() { alert("Yeah, that page loaded!"); };
//А это переделанный код с использование анонимной функции
//Так код смотрится намного лаконичней

				Вот как можно перерабатывать код с помощью анонимных функций:
function cookieAlarm() {
    alert("Time to take the cookies out of the oven");
};
setTimeout(cookieAlarm, 600000);//Таймер на 10 минут(значение задается в миллисекундах, 1000 * 60 * 10 = 600 000)
//Это как мы делали до этого момента
 
setTimeout(function() { alert("Time to take the cookies out of the oven");}, 600000);
//Переработаная с помощью функционального выражения,но она не удобно читается

setTimeout(function() { 
               alert("Time to take the cookies out of the oven");
           }, 600000);
//в код JavaScript можно включать дополнительные пробелы;мы можем использовать отступы и переносы строк, чтобы код лучше читался	   
		   
/*
	Если ваш код ожидает получить ссылку на функцию,вы всегда можете разместить на этом месте 
функциональное выражение—потому что в результате его вычисления получится ссылка на функцию
*/



							Вложенные Функции
Ничто не мешает нам определять функции внутри других функций; это означает, что объявления функций или функциональные выражения можно использовать только внутри этих функций
Размещение функции внутри другой функции влияет на видимость этой функции внутри вашего код
Функции, определяемые на верхнем уровне кода, обладают глобальной областью действия, тогда как функции, определяемые внутри других функций, обладают локальной видимостью
var migrating = true;
var fly = function(num) { 
   var sound = "Flying";
   function wingFlapper() {//Внутреняя функция,Ее областью действия является вся функция fly, и она определена в любой точке тела функции fly
      console.log(sound);
   }
   for (var i = 0; i < num; i++) {
      wingFlapper();
   }
};
function quack(num) { 
   var sound = "Quack";
   var quacker = function() {//функциональное выражение,Ее областью действия является вся функция quack, однако нужно ее ставить в начале(до какие-то действий и проверок) если упустить этот момент команда выполнятся не будет так как не увидит данные об этой функции
      console.log(sound);
   };
   for (var i = 0; i < num; i++) {
      quacker();
   }
}
if (migrating) {
    quack(4);
    fly(4);
}

/*
	Все, что определяется на верхнем уровне кода, имеет глобальную область действия. Следовательно, переменные fly и quack являются глобальными
	Функции внутри функций видни только в этих функция 
*/

Вот как работает лексическая область действия:
/*
Этот термин означает, что для определения области действия переменной достаточно прочитать 
структуру кода (то есть для ее определения не нужно дожидаться выполнения программы)
*/
var justAVar = "Oh, don't you worry about it, I'm GLOBAL";
function whereAreYou() {
    var justAVar = "Just an every day LOCAL";
    return justAVar;
	/*
		При вызове этой функции возвращается переменная justAVar. 
Но какая? Мы используем лексическую область действия, 
поэтому значение justAVar определяется областью действия 
ближайшей функции. И если найти переменную там не удается, то поиск переходит к глобальной области действия.
	*/
}
var result = whereAreYou();
console.log(result);
//Итак, при вызове whereAreYou возвращается значение локальной переменной justAVar,а не глобальной
//Тоэе самое будет происходить и для фнутренних функций, будет выбиратся ближайшее значение

Чем интересна лексическая область действия

var justAVar = "Oh, don't you worry about it, I'm GLOBAL";
function whereAreYou() {
    var justAVar = "Just an every day LOCAL";
    function inner() {
         return justAVar;//Здесь ничего не изменилось,те же переменные и функции
    }
    return inner;//Но вместо того чтобы вызывать внутреннюю функцию, мы возвращаем ее
}
var innerFunction = whereAreYou();
var result = innerFunction();
console.log(result);
/*
	При вызове whereAreYou мы получаем ссылку на внутреннюю функцию inner, которая присваивается переменной innerFunction. 
Затем мы вызываем innerFunction, сохраняем вывод в переменной result и выводим ее значение
Ранее об этом не упоминалось, но все локальные переменные хранятся в окружении environment,при возвращении функции возвращается не только сама функция, но и присоединенное к ней окружение

Другими словами начала мы вызываем функцию whereAreYou,ее результат просто ссылка на другую функцию,
создаем другую переменую и говорим что для результата этой функции добавить() что означает выполнение функции и внутреняя фунция возвразает уже не ссылку а результат, то же самое что и пример выше
*/
								Замыкание
Пример функция счетчика,с замиканием и без: 
					1)Без замыкания
var count = 0;//Глобальная переменная count
function counter() {
    count = count + 1;//При каждом вызове функция counter увеличивает глобальную переменную count и возвращает новое значение
    return count;
}
console.log(counter());
console.log(counter());
console.log(counter());
/*
	Единственный недостаток такого решения заключается в том, что для count используется глобальная переменная, а это может создать проблемы при 
разработке в составе группы (программисты часто используют одинаковые имена, что приводит к конфликтам)
*/
						2)Замыкание
function makeCounter() {
	var count = 0;//Переменная count помещается в функцию makeCounter.Теперь count становится локальной,а не глобальной переменной

	function counter() {//Создаем функцию counter, которая увеличивает переменную count
		count++;
		return count;
	}
	return counter;//Это замыкание: значение count сохраняется в его окружении
//Полностью локальная и защещенная переменная count 
}
var doCount = makeCounter();//1
console.log(doCount());//2
console.log(doCount());
console.log(doCount());
/*
	1)мы вызываем функцию makeCounter(); она возвращает просто counter без () и возвращает ее вместе с окружением , так что она не выполняет функцию(если бы было бы с () то она просто counter увеличыло бы на 1 и все)
	если былобы return counter(); то это действие заставлялобы фунцию counter работать,а так происходит замыкание
	2)после вызова makeCounter() нам вернуло ссылку на функцию counter и теперь мы добавляем к переменной doCount (),а так как doCount возвратило counter то мы () добавляем к counter() и получается что мы вызываем уже функцию 
	counter и заставляем ее работать
*/

Замыкания также могут создаваться передачей функций при вызове функций:

function makeTimer(doneMessage, n) {
	setTimeout(function() {//Имеется функция
		alert(doneMessage);//со свободной переменной doneMessage, которая используется как обработчик при вызове setTimeout
	}, n)
}
makeTimer("Hello my young friend!", 2000);
//Функциональное выражение, содержащее свободную переменную doneMessage, передается функции setTimeout

Замыкание содержит непосредственное окружение, а не его копию
/*
Многие разработчики при изучении замыканий ошибочно полагают, что окружение в замыкании должно содержать копию всех переменных и их значений. 
Это не так. На самом деле окружение обращается к «живым» переменным, используемым в вашем коде, так что если значение будет изменено за пределами 
функции замыкания, то последняя «увидит» это новое значение во время выполнения.
*/
function makeTimer(doneMessage, n) {
	setTimeout(function() {
		alert(doneMessage);
	}, n)
	doneMessage = "Ouc";
}
makeTimer("Hello", 2000);
//В результате выведет Ouc

Создание замыкания в обработчике события,Программа будет отслеживать количество нажатий кнопки:

									Программа без замыкания:
var count = 0;//Переменная count должна быть глобальной,потому что если сделать ее локальной для handleClick (обработчик события щелчка на кнопке— см. ниже), эта переменная будет повторно инициализироваться при каждом нажатии кнопки
window.onload = function() {
    var button = document.getElementById("fireButton");
    button.onclick = handleClick;
};
function handleClick() {
    var message = "You clicked me ";
    var div = document.getElementById("message");
    count++;
    div.innerHTML = message + count + " times!";
}


								Программа с замыканием:

window.onload = function() {
	var count = 0;//Теперь все переменные локальны по отношению к window.onload. Никаких проблем с конфликтами имен
	var div = document.getElementById("message");
	var message = "Clicked:";
	var get = document.getElementById("fireButton");
	get.onclick = function() {//Обработчик назначается как функциональное выражение,присваиваемое свойству onclick кнопки,поэтому мы можем обращаться к div,message и count в функции.Помните про лексическую область действия!
		count++;
		div.innerHTML = message + count + " times";
	};
};
//Функция содержит три свободные переменные: div, message и count, поэтому для функции обработчика click создается замыкание. Таким образом, свойству onclick кнопки назначается замыкание
//Свободными переменными называются переменные в теле функции, не связанные с данной функцией


							Как создать конструктор
Использование конструкторов проходит в два этапа: сначала мы создаем конструктор, а потом используем его для создания объектов

function Dog(name, breed, weight) {//Конструктор выглядит как обычная функция
    
	this.name = name;
    this.breed = breed;//Эта часть больше похожа на объект: значения параметров присваиваются переменным,которые похожи на свойства
    this.weight = weight;//Имена свойств и параметров не обязаны совпадать,но часто совпадают— это еще одно удобное соглашение
}
/*
	Обратите внимание: имя конструктора начинается с прописной буквы(Dog).Это не обязательно, но разработчики обычно следуют этому правилу
	Параметры функции(name, breed, weight)соответствуют свойствам,которые должны передаваться при вызове для каждого создаваемого объекта
	Обратите внимание: конструктор ничего не возвращает
*/
Ранее мы создали конструктор Dog, теперь воспользуемся им:

var fido = new Dog("Fido", "Mixed", 38);
/*
	Для создания объекта используется оператор new
	За оператором new следует вызов конструктора (Dog)
	И аргументы ("Fido", "Mixed", 38)
Чтобы создать объект,представляющий конкретную собаку,мы создаем новый объект собаки с кличкой Fido,смешанной породой (Mixed) и весом 38 фунтов
*/
После обработки этой команды в переменной fido будет храниться ссылка на созданный объект

Определив конструктор для объектов собак, мы можем создавать их и далее: 
var fluffy = new Dog("Fluffy", "Poodle", 30);
var spot = new Dog("Spot", "Chihuahua", 10);
Гораздо удобнее, чем с литералами

							Как работают конструкторы
Чтобы понять, как работают конструкторы, нужно знать, что же делает оператор new

1)Сначала new создает новый, пустой объект
2)Затем new заносит в this ссылку на новый объект
3)После подготовки this вызывается функция Dog,которой передаются аргументы "Fido", "Mixed" и 38
4)Затем вызывается тело функции. Как и большинство конструкторов, Dog задает значения свойств только что созданного объекта this
При выполнении тела функции Dog новый объект заполняется тремя свойствами, которым присваиваются значения соответствующих параметров
5)Наконец, после того как функция Dog будет выполнена,оператор new возвращает this,то есть ссылку на только что созданный объект. 
Обратите внимание: ссылка this возвращается автоматически, вам не придется явно возвращать ее в своем коде. 
И после того как новый объект будет возвращен, эта ссылка присваивается переменной fido
/*
	Другими словами this.name = name;
	this.name -- name - это свойство оно может быть любым именем
	= name; -- это аргумент на то что мы будем вводить его нельзя менять
*/
								добавить методы

function Dog(name, breed, weight) {
    this.name = name;
    this.breed = breed;
    this.weight = weight;
	this.bark = function() {//Отныне каждый создаваемый объект также содержит метод bark, который можно будет вызвать в программе
		if (this.weight > 25) {
			alert(this.name + " says Woof!");
		}else {
			alert(this.name + " says Yip!");
		}
	};
}

var fido = new Dog("fido", "Mixed", 38);
var fluffy = new Dog("Fluffy", "Poodle", 30);
var spot = new Dog("Spot", "Chihuahua", 10);
var dogs = [fido,fluffy, spot];

for (var i = 0; i < dogs.length; i++) {
	dogs[i].bark();
}

Конструктор ничем не отличается от обычной функции.Единственное, чего не следует делать в конструкторе, так это возвращать 
значение (отличное от this), потому что в этом случае конструктор не вернет объект, который ему положено конструировать

Нужно Обязательно указывать new если его не указать будет выводить ошибку: Uncaught TypeError: Cannot call method 'play' of undefined
почему же это могло произойти?
/*
	Помните, что new создает новый объект,прежде чем присвоить его this (а затем вызывает конструктор). Без оператора new новый объект создан не будет
?1)Это означает, что любые ссылки this в конструкторе будут относиться не к новому объекту альбома,а к глобальному объекту вашего приложения
2)Без использования new не существует объекта, возвращаемого из конструктора; это означает, что переменной darkside не будет присвоен объект и она 
останется неопределенной. Из-за этого при вызове play выдается ошибка с сообщением о том, что объект, для которого мы пытаемся вызвать метод, не определен
*/


					Преобразование аргументов в объектный литерал

function Car (make, model, year, color, pessengers, convertible, mileage) {
	this.make = make;
	this.model = model;
	this.year = year;
	this.color = color;
	this.pessengers = pessengers;
	this.convertible = convertible;
	this.mileage = mileage;
	this.started = false;	
	this.start = function() {
		this.started = true;
	};
	this.stop = function() {
		this.started = false;
	};
	this.drive = function() {
		if (this.started) {
			console.log("Woom woom");
		}else {
			console.log("You need started first");
		}
	};
}

Преобразует в:
function Car (gorge) {//Прежде всего,семь параметров конструктора Car заменяются одним параметром для передаваемого объекта
	this.make = gorge.make;
	this.model = gorge.model;
	this.year = gorge.year;//Затем каждая ссылка на параметр заменяется соответствующим свойством объекта,переданного функции
	this.color = gorge.color;
	this.pessengers = gorge.pessengers;
	this.convertible = gorge.convertible;
	this.mileage = gorge.mileage;
	this.started = false;	
	this.start = function() {
		this.started = true;
	};
	this.stop = function() {
		this.started = false;
	};
	this.drive = function() {
		if (this.started) {
			console.log("Woom woom");
		}else {
			console.log("You need started first");
		}
	};
	/*
		В нашем методе параметр конструктора нигде не используется, поскольку мы работаем со
свойствами объекта (для обращения к которым используется переменная this). 
Следовательно, в этом коде ничего изменять вообще не нужно
	*/
}
var gorge =  {
				make: "GG",
                  model: "Cadillac", 
                  year: 1955, 
                  color: "tan", 
                  passengers: 5, 
                  convertible: false, 
                  mileage: 12892
};
//В нашем примере сохранен исходный порядок аргументов,но это ни в коем случае не обязательно
console.log(gorge);

var cadi = new Car(gorge);//Теперь конструктору Car передается один аргумент 
cadi.start();
cadi.drive();
cadi.drive();
cadi.stop();

Это делается для удобства так как в конструкторе может быть много параметров и можно ошибится то так лучше смотрится

					Способ определение какие конструктором был создан обьект
function Car(name,age,weight) {
	this.name = name;
	this.name = age;
	this.weight = weight;
}
var create = new Car("Alexey", 23, 104);
if (create instanceof Car) {
	console.log("this is Car object");
}
/*
	Оператор instanceof возвращает true, если объект был создан указанным конструктором
	В нашем случае это означает:«Являетсяли объект create экземпляром,созданным конструктором Car?»
*/

							Добавить свойство в конструктор
function Dog(name, age, weight) {
	this.name = name;
	this.age = age;
	this.weight = weight;
}
var fido = new Dog("Fido", 2, 3);//Объект собаки, созданный конструктором Dog
fido.owner = "Jim";//Мы можем добавить новое свойство, просто задавая его значение в объекте
delete fido.owner;//А можем удалить свойство оператором delete
console.log(fido);
//Вообщем все тоже самое что и с обьектными литералами							

В объекты даже можно добавлять новые методы:	
						
fido.dark = function() {
	if (this.weight > 2) {
		console.log(" > 2");
	}else {
		console.log(" < 2");
	}
}
fido.dark();							
							
Обратите внимание: здесь изменяется только объект fido. Если добавить метод в fido, 
то метод появится только в этом объекте. У других объектов, представляющих собак, его не будет							
		


					Встроенные объекты здорово экономят время
						
						Обьект Date
Вызов конструктора Date возвращает экземпляр Date, представляющий текущее местное время и дату						

var now = new Date();//Создает новый объект,представляющий текущую дату и время

var dateString = now.toString();//Возвращает строковое представление даты вида “Thu Feb 06 2014 17:29:29 GMT-0800 (PST)”
var theYear = now.getFullYear();//Возвращает год из даты
var theDayOfWeek = now.getDay();//Возвращает номер дня недели,представленного объектом даты, например 1 (понедельник)

Допустим, вам понадобился объект даты, представляющий 1 мая 1983 года; он создается так:
var birthday = new Date("May 1, 1983"); //	Конструктору можно передать простую строку с датой	

А можно дополнить дату временем:
var birthday = new Date("May 1, 1983 08:03 pm");					
--------------------------------------------------------------------------------------------------------

							Обьект Array
Ранее мы создавали массивы в синтаксисе с квадратными скобками [1, 2, 3], массивы также можно создавать конструктором

var emptyArray = new Array();//Создает пустой массив нулевой длины

emptyArray[0] = 99;//Здесь создается новый, пустой объект массива. В него можно в любой момент добавить новые элементы

Также можно создать объект массива заданного размера. Допустим, нам нужен массив для трех элементов

var oddNumbers = new Array(3);
oddNumbers[0] = 1;
oddNumbers[1] = 3;
oddNumbers[2] = 5;
//Если через push добавлять то с 3го начинается
Объект массива интересен в основном своим набором методов:

oddNumbers.reverse();//Перестановка значений массива в обратном порядке (теперь массив oddNumbers содержит элементы 5, 3, 1).Обратите внимание: метод изменяет исходный массив,а не копию
var aString = oddNumbers.join(" gav ");//Между каждым значением массива будет подставленные данные(gav в нашем случае) 
var areAllOdd = oddNumbers.every(function(x) { //Метод every получает функцию,и для каждого значения в массиве проверяет,какой результат вернет функция для этого значения— true или false
    return ((x % 2) !== 0);// Если функция возвращает true для всех элементов массива, то и метод every возвращает true 
});
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

Синтаксис с квадратными скобками [ ], который мы использовали для создания массива, в действительности является сокращенной записью для прямого использования конструктора Array

var items = new Array();
var items = [];
//Эти команды делают одно и то же.Запись с квадратными скобками поддерживается в языке JavaScript для того, чтобы упростить работу программиста при создании массивов

var items = ["a", "b", "c"];//Такой синтаксис массивов называется «литеральным»
var items = new Array("a", "b", "c");
Объекты, созданные на базе литералов и с прямым вызовом конструкторов, ничем не отличаются!

var n = getNumberOfWidgetsFromDatabase();
var widgets = new Array(n);
for(var i=0; i < n; i++) {
    widgets[i] = getDatabaseRecord(i);
}
//В этом коде используются большие массивы,а конкретный размер такого массива неизвестен до выполнения программы
Итак, синтаксис с литералами прекрасно подходит для создания объектов массивов «на скорую руку», а применение конструктора Array может 
оказаться более эффективным при построении массива на программном уровне. Используйте любой способ— или их комбинацию по своему усмотрению

							Другие встроенные объекты:
Math --- Объект Math используется для выполнения математических операций и извлечения значений констант , ссылка(http://www.wisdomweb.ru/JSd/math.php)
Error --- Конструктор создает стандартные объекты ошибок, которые будут полезны, если вы перехватываете ошибки в своем коде , ссылка (https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Error)


							СИЛЬНЫЕ ОБЬЕКТЫ
							
function Dog(name, breed, weight) {
    this.name = name;
    this.breed = breed;
    this.weight = weight;
    this.bark = function() {
        if (this.weight > 25) {
            alert(this.name + " says Woof!");
        } else {
            alert(this.name + " says Yip!");
        }
    };
}
//Этот код мы писали выше

var fido = new Dog("Fido", "Mixed", 38);
var fluffy = new Dog("Fluffy", "Poodle", 30);
var spot = new Dog("Spot", "Chihuahua", 10);

/*
	Три разных объекта с разными значениями свойств
	Каждый объект содержит ссылку на функцию bark
	Каждый объект использует собственную функцию bark.Они делают одно и то же,но каждый объект использует собственную копию функции
Все эти лишние методы, которые вы создаете,убивают приложение. Сейчас у нас кончится свободная память— и все
На мобильном устройстве приложение бы уже скончалось

Как правило, мы не хотим, чтобы при каждом создании экземпляра конструктором создавался новый набор методов. 
Дублирование ухудшает быстродействие приложения и расходует ресурсы, которые могут быть ограничены, особенно на мобильных устройствах
Проблему можно решить с помощью Прототипов
*/

								Прототипы
Объекты JavaScript способны наследовать свойства и поведение от других объектов. А если говорить конкретнее, в JavaScript используется 
модель наследования через прототипы; соответственно, объект, от которого наследуется поведение, называется прототипом

Прототип на примере собаки:
/*
Грубо говоря в прототип мы включаем все что будет у каждой собаки
Прототип не включает свойства клички,породы или веса— эти свойства уникальны для каждой собаки и будут предоставляться реальными собаками,наследующими от прототипа
*/

К примеру мы создали прототип Dog:

							//Свойства и методы, общие для всех собак
							Прототип Dog //Так выглядит диаграма ,это обьект Dog
							------------
							species: "Canine" //Это свойства
							------------
							bark()  //А это методы
							run()
							wag()

	Fido				Fluffy					Spot
------------		-----------				------------
name: "Fido"		name: "Fluffy"			name: "Spot"
breed: "Mixed"		breed: "Poodle"			breed: "Chihuahua"
weight: 38			weight: 30				weight: 10

/*
Три объекта собак,наследующих от прототипа.Прототип содержит свойства (в числе которых и методы),общие для всех собак.Сами объекты содержат свойства, 
специфические для каждой собаки: кличка (name), порода (breed) и вес (weight
*/
					Как работатет наследование:
1)Для начала напишем немного кода.Например,вызовем метод bark объекта собаки:
fido.bark(); //Совершенно обычный вызов метода bark объекта fido
2)Чтобы выполнить этот код,мы обращаемся к экземпляру fido за методом bark.Но там его нет
//Метода bark здесь нет! Обращаемся ВВЕРХ по цепочке, к прототипу.
3)Если bark не удается найти в экземпляре fido, то мы обращаемся к прототипу
4)Проверяя прототип Dog,мы видим, что он содержит метод bark
5)Наконец, находим метод bark и вызываем его

/*
Свойства работают примерно так же.Если мы пишем новый код,в котором используется значение fido.name,это значение берется из объекта fido. 
Но если нас интересует значение fido.species,сначала проверяется объект fido;в нем такого свойства нет, 
поэтому проверяется прототип (где это свойство и обнаруживается)
*/

Теперь если создать много обьектов собак то Теперь используется всего одна функция bark.Гораздо лучше

							Переопределение прототипа
Если понядобится что-то поменять то необезательно лезть в прототип.Можно просто поменять в каком-то обьекте. 
Давайте посмотрим, что происходит при переопределении метода bark в объекте spot

1)Прототип остается тем же(это обьект Dog)
2)Но объект spot получает собственный метод bark,который выводит сообщение “WOOF!”
После этого можно вызвать bark. spot.bark();
3)Поиски метода bark начинаются с объекта spot
4)Метод успешно найден,продолжать поиски в прототипе не нужно.При вызове, как и ожидалось, выводится сообщение WOOF!
5)Метод bark в прототипе не используется для spot, но продолжает использоваться в fido и fluffy

/*
	Свойства и методы всегда можно переопределить в объекте.Переопределение работает,потому что JavaScript всегда обращается за свойством к 
экземпляру (то есть конкретному объекту собаки) до того,как продолжить поиски в прототипе.Следовательно,если вы хотите использовать для 
spot нестандартный метод  bark,вам достаточно включить свою реализацию в объект spot.Когда JavaScript начнет искать метод bark
для вызова, реализация будет найдена в объекте spot, и не будет возиться с поисками в прототипе
*/

							
								Как создать прототип
Сначала нам понадобится конструктор— чтобы понять, как он должен выглядеть

function Dog(name, breed, weight) {
    this.name = name;
    this.breed = breed;
    this.weight = weight;
}

/*
	Каждый экземпляр содержит отдельный набор свойств name, breed и weight, поэтому они будут включены в конструктор
	Методы будут наследоваться от прототипа, в конструкторе они не нужны	
*/

Конструктор у нас имеется, переходим к настройке прототипа.Мы хотим, чтобы прототип содержал свойства species и bark,а также методы run и wag. Вот как это делается:

Dog.prototype.species = "Canine";//Строка “Canine” задается свойству species прототипа
//Начинаем с объекта Dog и получаем его свойство prototype, которое содержит ссылку на объект со свойством species

Dog.prototype.bark = function () {
	if (this.weight > 25) {
		console.log(this.name + " says Woof!");
	}else {
		console.log(this.name + " says Yip!");
	}
};
Dog.prototype.run = function() {
	console.log("Run");
};

Dog.prototype.wag = function() {
	console.log("Wag!");
};

//Дальше как обычно
var fido = new Dog("Fido", "Mixed", 38);
var fluffy = new Dog("Fluffy", "Poodle", 30);
var spot = new Dog("Spot", "Chihuahua", 10);

fido.bark();
fluffy.run();
spot.wag();

//Теперь вносим метод только для spot 

spot.bark = function() {
	console.log(this.name + " says Woof!");
};
spot.bark();

//можно также делать много чего 
Dog.prototype.sitting = false;
Dog.prototype.sit = function() {
	if(this.sitting) {
		console.log(this.name + " is now sitting");
	}else {
		this.sitting = true;
		console.log(this.name + "  sitting");
	}
	
};
spot.sit();

//Таким образом, мы можем определить значение по умолчанию для всех объектов,а затем,если понадобится, создать его специализированную версию в каждом конкретном объекте
/*
	1)Метод spot.sit вызывается впервые. Объект spot не содержит свойства sitting
	2)Обращаемся к прототипу и видим, что свойство sitting содержит false
	3)Свойству this.sitting задается значение true. При этом в объект spot добавляется новое свойство sitting, которому и присваивается это значение
	4)Метод spot.sit вызывается во второй раз. На этот объект spot содержит свойство sitting, равное true
*/

Можно определить, откуда взято используемое значение свойства— из экземпляра или прототипа, методом hasOwnProperty
Метод hasOwnProperty возвращает true, если свойство определяется в экземпляре объекта. Если возвращается false, значит, свойство определено в прототип			
	
console.log(spot.hasOwnProperty("species"));
console.log(fido.hasOwnProperty("species"));	
	
//В обоих случаях возвращается false,потому что свойство species определяется в прототипе,а не в экземплярах spot и fido

console.log(spot.hasOwnProperty("sitting"));//Когда мы в первый раз проверяем, содержит ли spot собственное свойство sitting,возвращается значение false	
spot.sitting = true;//Затем мы задаем spot.sitting значение true, добавляя это свойство в экземпляр spot
console.log(spot.hasOwnProperty("sitting"));//Этот вызов hasOwnProperty возвращает true,потому что spot теперь содержит собственное свойство sitting	

console.log(fido.hasOwnProperty("sitting"));//А этот вызов hasOwnProperty возвращает false,потому что экземпляр fido не содержит свойства sitting.Это означает,что свойство sitting,используемое fido,определяется только в прототипе и наследуется fido	
	
					Как создать Конструкто наследующий методы/свойства от прототипа
					
Скажем есть обьект собака(выше код) и нужно создать выставачную собаку у которой есть свой прототип с методами
и мы хотим что бы некоторые методы брались из уже созданных в прототипе Dog ,что бы не писать лишний код
//Очень удобно пользоватся данным методом для улучшения или добавления чего нибудь,и что бы не писать лишние методы заново просто воспользоватся данной структурой
//Скажем есть один обьект и необходимо создать точно такой же только несколько данных добавить,этот формат кода подойдет как нельзя лучше
	
1)Для начала нам понадобится объект, наследующий от прототипа собаки	
	
	var aDog = new Dog();

//Чтобы создать объект,наследующий от прототипа собаки, мы используем оператор new с конструктором Dog
//Этот код создает объект,наследующий от прототипа собаки.Мы знаем это,потому что точно так же ранее создавались все экземпляры собак— просто на этот раз конструктору не передаются аргументы	
	
2)Теперь нам понадобится прототип выставочной собаки
	
	function ShowDog(name, breed, weight, handler) {
	this.name = name;
	this.breed = breed;
	this.weight = weight;
	this.handler = handler;
}
//Конструктор получает все необходимое для создания собаки (name, breed,weight) и выставочной собаки (handler)

Теперь, когда у нас имеется конструктор, мы можем задать его свойству prototype новый экземпляр собаки:
	
ShowDog.prototype = new Dog();//для конструктора ShowDog будет прототип из которого мы будем брать методы Dog	

//Мы могли бы воспользоваться экземпляром собаки,созданным на предыдущей странице,но вместо этого можно пропустить присваивание и напрямую назначить новый объект свойству prototype	
	
ShowDog.prototype.league = "Webville";
ShowDog.prototype.stack = function () {
	console.log("Stack");
}; 
ShowDog.prototype.bait = function () {
	console.log("Bait");
};
ShowDog.prototype.gait = function(kind) {
	console.log(kind + "ing");
};
ShowDog.prototype.groom = function() {
	console.log("Groom");
};

var scotty = new ShowDog("Scotty", "scotish rerrier", 44, "Cookie");


scotty.stack();
scotty.bark();
console.log(scotty.species);	

/*
	Другими словами что бы сделать прототип от прототипа нужно:
1)Создать конструктор, в нашем случае (ShowDog)
2)И ключевой момент ShowDog.prototype = new Dog();
*/	
	
							Проверка
var fido = new Dog("Fido", "Mixed", 38);
if (fido instanceof Dog) {
    console.log("Fido is a Dog");//True, fido конструктор Dog
}
if (fido instanceof ShowDog) {
    console.log("Fido is a ShowDog");//False,  fido не конструктор Dog
}

var scotty = new ShowDog("Scotty", "Scottish Terrier", 15, "Cookie");
if (scotty instanceof Dog) {
    console.log("Scotty is a Dog");//True
}
if (scotty instanceof ShowDog) {
    console.log("Scotty is a ShowDog");//True
}
//Скотти является собакой и выставочной собакой.Дело в том,что instanceof не только смотрит на разновидность самого объекта,но и учитывает все объекты,от которых он наследует

console.log("Fido constructor is " + fido.constructor);//True, тут все понятно
console.log("Scotty constructor is " + scotty.constructor);
//constructor вызывает конструктор 	
	
Чтобы исправить свойство constructor, нужно позаботиться о том, чтобы он правильно задавался в прототипе ShowDog		
Вот как это делается:

function ShowDog(name, breed, weight, handler) {
    this.name = name;
    this.breed = breed;
    this.weight = weight;
    this.handler = handler;
}
ShowDog.prototype = new Dog();
ShowDog.prototype.constructor = ShowDog;
/*
	Мы берем прототип выставочной собаки и явно назначаем его свойству constructor конструктор ShowDog
	Помните, что это скорее вопрос стиля;без этого изменения код тоже работает
	Другими словами мы просто явно указываем имя для будущего вызова instanceof
*/	

Теперь нужно устранить дублирование в конструкторе ShowDog,ведь в конструкторе Dog используется все тоже самое

function ShowDog(name, breed, weight, handler) {
	Dog.call(this, name , breed, weight);//Этот фрагмент использует конструктор Dog для обработки свойств name, breed и weight.
	this.handler = handler;//Но свойство handler должно обрабатываться в этом коде,потому что конструктор Dog о нем ничего не знает

}
/*
call— встроенный метод,который может использоваться с любой функцией (не забывайте,что Dog— это функция). 
Dog.call вызывает функцию Dog и передает ей объект, который должен использоваться как this, вместе со всеми аргументами функции Dog
*/
Рассмотрим по частям:

Dog.call(this, name, breed, weight);

/*
	Dog— вызываемая функция
	call— вызываемый метод. Он обеспечивает вызов функции Dog. Мы используем метод call вместо прямого вызова Dog, чтобы управлять значением this
	Остальные аргументы просто передаются Dog, как обычно
	Другими словами .call- как бы говорит что this мы должны использовать для name, breed, weight
	
*/

Object— объект, от которого наследуют все остальные объекты. Цепочка прототипов заканчивается на Object		
	
						Метод toString()
Все объекты наследуют от Object,и поэтому могут использовать метод toString для получения простого строкового представления любого объекта
	
function Robot(name, year, owner) {
	this.name = name;
	this.year = year;
	this.owner = owner;
}
Robot.prototype.toString = function() {
	return this.name + " Robot belonging to " + this.owner;
};

var toy = new Robot ("Toy", 2013, "Avary");
console.log(toy.toString());	
/*	
Обратите внимание: метод toString может активизироваться, даже если вы не вызываете его напрямую. 
Например, если вы используете оператор + для конкатенации строки с объектом, JavaScript использует метод toString
для преобразования объекта в строку, прежде чем объединять его с другой строкой	
*/
console.log("Robot is: " + toy);
	
	
								
								Команды
alert("Welcome!"); --вызывает окошко с надписью Welcome
quess = prompt("Как тебя зовут?", " Здесь вводить ");
/*  
Браузер предоставляет встроенную функцию prompt, которая предназначена для получения 
данных от пользователя.Функция prompt имеет много общего с уже использовавшейся функцией 
alert.Как и alert, prompt вызывает на экран диалоговое окно с переданной строкой, 
но предоставляет место, в котором пользователь может ввести ответ. Этот ответ в форме 
строки возвращается как результат вызова функции. Если пользователь закрыл диалоговое 
окно или ничего не ввел, функция возвращает null.
Результат вызова prompt присваивается переменной guess!
Тоесть чтобы пользователь не написал в вызывающем окошке,число,букву,строку,все запишется в переменную quess 
var quess = prompt("Как тебя зовут?", " Здесь вводить "); ЕСЛИ ДОБАВИТЬ ВТОРУЮ СТРОКУ ТО ОНА БУДЕТ В ТОМ МЕСТЕ ГДЕ МЫ БУДЕМ ЧТО-ТО ПИСАТЬ 
Другими словами первая строка "Как тебя зовут?" выводит вопрос,а вторая строка " Здесь вводить " появляется в поле где пользователь вводит информацию
*/

//window.alert(); window.prompt(); --- это одно и тоже что alert(); prompt(); , window - это обьект а alert(); prompt();  его методы
//window -окно браузера, и поскольку он всегда есть его писать не обязательно


document.write("The End of this story!");---выводит надпись со значением(то что в кавычках),
Функция document.write позволяет вывести произвольную разметку HTML и контент в произвольной точке страницы. Так поступать не рекомендуется, хотя время от времени этот способ все же применяется.

alert(flavors.length); //ключевое свойство length показывает сколько элементов в масиве
								Ссылки с книги
http://wickedlysmart.com/hfjs/
http://www.wisdomweb.ru ---Удобный ресурс для JS типа htmlbook только для JS 
http://www.wisdomweb.ru/JS/obreg.php  //ссылка на регулярные выражения 
http://www.wisdomweb.ru/JSd/math.php  --- ссылка на обьект Math (математические операции)
https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Error  --ссылка на обьект Error


				
				
				
				
				
				
									Новая Книга(Javasrcipt и jquery 3е издание)
									
									Тег Script
Парный тег <script></script>// если использовать HTML5 то type="text/javascript" указывать не обазательно,можно смело пропускать 
На самом деле браузеры позволяют опустить атрибут type в файлах HTML4.01 и XHTML1.0 --- сценарий все равно станет работать.Однако
в отсуцтвии атрибута type ваша страница не будет проверенна должным образом.		
Если хотите сделать ссылку на внешний файл Javascript и добавить еще один фрагмент кода Javascript на страницу,
используйте вторую пару тегов элемента  script. Например:

<script src="navigator.js"></script>//Можно добавить больше внешних файлов
<script> 
	alert("Hello");
</script>

Мы можем и часто будем прикреплять несколько внешних файлов  JavaScript к одной странице


										Ошибки в консоле
Unexpected token ILLEGAL --- связанно с опечаткой или пропущеным символом
Uncaught ReferenceError  --- Опечатка в командах --- к примеру (Uncaught ReferenceError: aler is not defined) из-за того что мы не правильно написали команду aler("Привет");

								Консоль в internet explorer 
Unterminated string constant --- равнозначно Unexpected token ILLEGAL в консоле Chrome

									Типы данных
В Javascript выделяют три основных типа данных: Числа,Строки и Булевские значения
1)Числа --- 5, 10.33333, и даже отрицательные  числа, -130, -457.34
2)Строка - это набор букв и других символов заключенных в кавычки									
Что бы написать кавычки внутри строки нужно использовать другие кавычки:
document.write('привет, "крошка"');									
document.write("привет, 'крошка'");									

Другой способ заставить интерпритатор JavaScript воспринимать кавычки в строке как ее часть,а не как окончание.
Для этого необходимо знак переключения кода.Если перед ковычкой поставить  \  то кавчка будет считатся частью строки

document.write("привет, \"крошка\"");	

В некоторый случаях без него просто не обойтись: 
document.write("фильм называется \"Д'Артатьян\"");	

3)Логические типы данных --- true , false

								Конкатенация -- сложения чисел со строками	
var name1 = "2";
var name2 = 4;
document.write(name1 + name2); //в результате будет 24

Есть пара способов для преотвращения подобных ошибок:
1)Можно добавить + в начале строки(или переменной в которой хранится строка),тем самым мы просим интерпритатор javascript преобразовать строку в число

document.write(+name1 + name2);//В результате 6

2)можно использовать команду Number()

document.write(Number(name1) + name2);

//Команда Number() преобразует строку в число,если это возможно(если строка содержит Только буквы то мы получем NaN в качестве сообщения о том что преобразование невозможно)
Лучше вводить команду Number() нежели +(я так понимаю из-за того что + это хак)

					Специальные комбинированные математические операции:
			var score;//переменная для примера

											+=
			score += 10;   --- Альтернатива ---  score = score + 10; 
			--------------------------------------------------------
											-=
			score -= 10;   --- Альтернатива ---  score = score - 10;
			<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
											*=
			score *= 10;   --- Альтернатива ---  score = score * 10;
			--------------------------------------------------------
											/=
			score /= 10;   --- Альтернатива ---  score = score / 10;
			<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
											++
			score ++;  	   --- Альтернатива ---  score = score + 1; 
			--------------------------------------------------------
											--
			score --;      --- Альтернатива ---  score = score - 1;


Тоже самое и для строк:
var score = "Friend";
var name = "Hello";
name = name + " " + score;//1
console.log(name);


name += " " + score;//2
console.log(name); 

//Это одно и тоже только 1 более длинная версия,а 2 короче



document.write("<p>Town</p>"); //Использование тегов в команах обычное дело
document.write("<p>Добро пожаловать " + name + "</p>");//Или такая запись

var firstName = "Иван";
var lastName = "Петров";
document.write("<p>");
document.write(firstName + " " + lastName);
document.write("</p>");
//Иван Петров будет внутри тега p

								Добавить элемент в начало массива 
var proba = [];
proba.push(22);
proba.unshift("gav",44);
console.log(proba);
//В результате команда unshift() позволяет поставить элемент(один или несколько элементов)(в нашем случае gav,44)в начало массива

Методы push/pop выполняются быстро, а shift/unshift – медленно.

								Удалить элемент из массива(удалить массив)
	pop() --- Удаляет элемент из конца массива	
var masiv = [22,55,"Supper"];
masiv.pop();
console.log(masiv);
//В результате выведет 	22,55, а Supper удалит	

	shift() ---Удалит элемент из начала массива 
var masiv = [22,55,"Supper"];
masiv.shift();
console.log(masiv);
//В рузультате выведет 55,"Supper", а 22 удалит

								Поменять местами элементы в массиве
var masiv = ["First one", 1, 2, 3, 4, "Last one"];
masiv.reverse();
console.log(masiv);
//Метод reverse() позволяет менять местами элеменнты, в результате будет идии ["Last one", 4, 3, 2, 1, "First one"]

									Обьекты
Вводя новую переменную и сохраняя в ней значения мы создаем новый экземпляр определенного  класса обьекта:
var first_name = "Вова";//строковой обьект
var age = 32;//числовой обьект
var valid = false;//логический обьект
 
							ЦЫКЛ в обратную сторону(сконца)
var example = ["Понедельник", "Вторник", "Среда", "Четверг", "Пятница", "Субота", "Воскресенье"];
for (var i = example.length - 1; i >= 0; i--) {
	document.write(example[i] + "<br />");
}

					Вложенный массив (иди многомерный массив)
var score = 0;
	var questions = [
		["Сколько лун у планеты Земля", 1],//этот код является массивом из двух элементов первый элемент вопрос,второй ответ
		["Сколько лун у планеты Сатурн", 31],
		["Сколько лун у планеты Венера", 0]
	];
		function askQuestion(question) {
			var answer = prompt(question[0], "");
			if (answer == question[1]) {
			alert("Верно");
			score++;
			}else {
				alert("Неверно, Правильный ответ " + question[1]);
			}
		}
	for (var i = 0; i < questions.length; i++){
		askQuestion(questions[i]);
	}		
			

								Библиотека	JQUERY
Что такое библитека Javascript - Это коллекция кодов предоставляющая простые решения многих повседневных задач программирования.В ней содержатся готовые функции Javascript 
Есть много библиотек Javascript:

Yahoo User Interface Library --- Это проект сервиса Yahoo
Dojo Toolkit --- Располагает  очень большим собранием файлов Javascript, примениммых в решении практически любой задачи.Однако она довольно сложна и рассчитана на опытных программистов
Mootools --- популярная библиотека направленная на создание сложной анимации и визуальных эффектов 
Raphael.js --- удинственной целью является облегчение процесса рисования векторных изображений в браузере
И другие:  Ember.js, Angular.js, Backbone.js

							Преимущества библиотеки Jquery
Относительно небольшой размер файла.Сжатая версия библиотеки занимает 96 КБ(версия 1.11) и около 83(версия 2.1).Если ваш веб-сервер использует метод сжатия gzip, то вы можете уменьшить размер файла до 38 КБ!
Jquery не подразумевает, что вы являетесь компьютерным гением.Она лишь предполагает,что большинство знакомы с CSS 
Jquery используется более чем на 57% сайтов.Популярность jquery - признак ее высокого качества							
Бесплатность
Jquery открыто для разработчиков со всего мира и они постоянно вносят свою лепту в программный код.Это все равно что иметь команду программистов Javascript 
Плагины

								Получение библиотеки jQuery
Библиотека jQuery представляет собой внешний файл,содержащий программный код на языке Javascript,и внешний файл нужно добавить на страницу
									
									Способ №1
Можно использовать версию размещенную на ресурсах Google, Microsoft или jQuery.com 
Медод использует сеть доставки контента (CDN content distribution network),это означает,что файл jQuery разположен на другом веб-сайте,который отправляет данный файл любому кто его запрашивает.
Преимущества:
1)Можно снизить загрузку на веб-сервис,позволив ресурсам Google, Microsoft или jQuery.com распостранять файл среди посетителей нашего сайта.
2)К тому же, CDN имеет дополнительное преимущество,выражающее в наличии серверов по вмему миру.Поэтому если кто-то в Сингапуре,например, просматривает наш сайт,то он получит файл jQuery с сервера который,вероятно расположен гараздо ближе ,чем наш веб-сервер,
это означает,что посититель получит файл скорее,и наш сайт будет отображатся бистрее.  
3)И самое главное,есть довольно высокая вероятность того, что у какого-нибудь посетителя нашего сайта уже есть файл jQuery, сохнаненный в кэше браузера.Так как он уже скачал jQuery файл c ресурса Google, при посещении другого сайта, ему не нужно загружать его снова при посещении вашего сайта,что приводит к значительному увеличении скорости
Недостатки:
1)Чтобы воспользоватся данным методом посетители должны быть подключены к Интернету.В автономном режиме не будет работать(к примеру при демонстрации в классе или в музее).В этом случае нужно просто скачать файл с jQuery.com и добавить на наш сайт


									Способ №2
Скачать файл jQuery на собственный комрьютер и добавить его на сайт

На сайте jQuery.com можно загрузить библиотеку jQuery и изучить ее.
Значки в левой верхней части страници позволяют перейти к другим проектам, например, jQuery UI, jQuery Mobile (для создания веб-сайтов,которые можно просматривать с помощью  мобильных устройств),Sizzle (встроенная в jQuery библиотека javascript,котороя облегчает выбор и изменение частей веб-страницы), и QUnit(для тестирования программ javascript)

			Ссылки на файл jQuery,расположенный на сервере  CDN 
Чтобы добавить ссылку  нужно добавить строку кода в раздел head ,прямо перед закрывающим тегом </head>
					
Например ссылка на версию jQuery 1.11.0 при использовании CDN корпорации Microsoft:
<script>
	src="http://ajax.aspnetcdn.com/ajax/jQuery/jquery-1.11.0.min.js"
</script>

При использовании CDN jQuery:
<script src="http://code.jquery.com/jquery-1.11.0.min.js"></script>

И наконец при использовании CDN Google:
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js" ></script>
//src="http://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"   как альтернатива

Нужно использовать всего лишь одну из этих строк на странице,в зависимости от выбранной сети CDN
Google,является самой популярной сетью,так что если вы не уверенны относительно того,какую сеть CDN использовать,используйте серверы ресурса Google
Чтобы изменить версию jQuery 2 просто измените значение 1.11.0 на 2.1.0
Например чтобы использовать CDN Google для загрузки версии jQuery 2.11.13:
<script src="//ajax.googleapis.com/ajax/libs/jquery/2.1.13/jquery.min.js" ></script>
/*
	Вы могли заметить, что ссылка на CDN-сервер Google выглядит несколько необично.Она не начинается со значения http://,как ссылка на CDN сервер Microsoft или jQuery
	Это URL-адрес относительно протокола.Это означает,что при загрузке файла браузер применит используемый в настоящее время протокол.Например если наша страница отправляется через защищенный сервер по протоколу https,то при отправке файла jQuery будут использоватся этот эе протокол
	С такими URL-адресами есть одна проблема: они работает только при просмотре страницы с веб-сервера.Если вы используете URL-адреса относительно протокола в локальных файлах,которые вы просматриваете,открывая их через свой веб-браузер,они не станут работать
*/
								Версии библиотеки jQuery 1 и 2
На сайте jQuery.com доступны две версии библиотеки - 1 и 2.Какую мне следует использовать?
Большая разница и причина выпуска версии jQuery 2 заключается в том,что в ней отсуцтвует подержка версий 6, 7 и 8 браузера Internet Explorer.Из-за того что подержка этих браузеров требует большого обьема кода,что приводит к увеличению размера файла библиотеки jQuery,била создана 2я версия 
В надежде что браузеры Internet Explorer 6, 7 и 8 в один прекрасный день перестанут использоватся,команда jQuery создала облегченную версию библиотеки,в которой отсуцтвует подержка этих браузеров.Тем не менее версии Internet Explorer 6, 7 и 8 все еще используются,поэтому версия 1 библиотеки jQuery по прежнему доступна.
Более того Internet Explorer 8 является наиболее используемой версией браузера.Поэтому пока лучше использовать jQuery 1 ,она имеет теже функции что и jQuery 2 но подерживает старые версии браузеров Internet Explorer.Поэтому лучше применять последнюю версию jQuery 1
В дальшейшем любые новые функции,которые команда jQuery добавит в библиотеку ,будут относится к версии 2.В версию 1 окажутся включены только исправления ошибок.Так что переход на версию 2 можно будет расмотреть в будущем	
	
На сайте jquery.com при скачивании(помимо версии) нужно выбрать какой тип файла скачать минимизированный или несжатый.
Размер незжатого файла очень большой (более 280 КБ),предназначен он для того чтобы лучше разобратся в библиотеке jQuery и прочитать код	
Минимизированную версию файла библиотеки jQuery следует использовать для веб-сайтов.Он гораздо меньше весит(все коментарии,табуляции и разрывы строк убраны),что делает файл быстро загружаемым но более сложным для чтения
//Обично можно опознать минимизированный файл javascript по наличию части .min в имени файла,например jquery.min.js указывает на то,что данный файл содержит минимизированный вариант библиотеки jQuery 	
	
							Коротко о версиях и обновлениях jQuery	
Можно посмотреть насколько одна версия отчичается от другой используя систему нумерации
jQuery 1.11.3//1 версия,11 релиз,3 исправления обшибок
/*
	Первая цифра указывает на версию 1 это первая версия 2 это вторая версия
	далее идут релизы 1.1, 1.2, 1.3 ... как правило каждая из этих цифр указывает на новые функции,переписанные старые функции для достижения большей эффективности в работе....
	последняя цыфра обычно относится к исправлению каких-либо ошибок в версии	
*/
При использовании CDN Google мы можем не указывать часть номера версии.Если вы используете в ссылку номер 1.11 вместо 1.11.0(<script src="//ajax.googleapis.com/ajax/libs/jquery/1.11/jquery.min.js" ></script>)
то сервис Google загрузит последнюю версию семейства 1.11 например, 1.11.2 .Если библиотека jQuery обновлена до версии 1.11.9,то Google зарузит данную версию.
Это умная техника поскольку незначительные изменения версий с 1.11.0 по 1.11.2 часто являются исправлениями ошибок,что может улучшить функционирование вашего сайта	
	
$(document).ready() --- это встроенная функция библиотеки jQuery,которая ожидает,пока HTML-код страницы полностью загрузится,прежде чем запустить ваш сценарий	(нужно всегда использовать если код помещен в раздел заголовка <head></head>)
Можно помещать на страницу несколько $(document).ready().jQUERY без проблем обработает 

	
Нельзя размещать другие элементы script перед этементом script,который загружает библиотеку jQuery 	
Посколько jQuery-программирование часто ссылается на стили CSS нужно помещать javascript код после стилей.Хорошим правилом будет помещать код javascript перед закрывающим тегом </head>	
	
								Обращение к DOM
								JavaScript
document.getElementById("banner"); --- метод достает из DOM id и возвращает его(как правило в созданную переменую)
document.getElementsByTagName("a"); --- подобным образом  выбирает все ссылки на странице
document.getElementsByClassName("author"); --- последние верии браузеров предусматривают способ выбора элементов DOM на основе селекторов CSS.Данный пример извлекает все элементы с классом author
document.querySelectorAll("span.author"); --- более понятной функцией является метод querySelectorAll()	, который позволяет использовать любой селектор CSS для выбора элементов страници.Например,чтобы выбрать только элементы span с классом author
						
								jQuery
С помощью библиотеки jQuery мы вибираем один и более элементов, используя специальную команду обьект jQuery.Основной синтаксис:
$("селектор");
Мы можем использовать практически все селекторы CSS 2.1 и многие селекторы CSS3,создавая обьект jQuery
			К примеру выбрать элемент с id = banner можно так
$("banner")	
B к примеру мы хотим изменить HTML код внутри элемента:
$("#banner").html("<h1>Javascript был тут</h1>");
//C класами точно также только нужно писать .banner
									Пример для класов
$(".submenu").hide();//все элементы с класом submenu мы cкрываем с помощью hide()

//http://api.jquery.com/category/selectors/ --- Полный список селекторов jquery 	
	

								Дочерний селектор
body > p //выбор элементов p которые являются дочерними по отношению к элементу body 
									
								Соседние родственные селекторы
Позволяют выбрать элемент,появляющийся сразу после другого элемента.Например у нас есть невидимая панель которая появляется только после щелчка кнопкой
мишки по вкладке.В нашем HTML-коде вкладка может быть представлена элементом заголовка(например h2),а скрытая панель элементов div который следует за заголовком.
Чтобы сделать элемент div (то есть панель) видимым мы должны его выбрать.(и лего сделать с помощью jQuery)	
(выберет рядом стоящие элементы,если выбрать div + p ,а p дочерний элемент div то не сработает,а вот если div и p стоят рядом то будет работать(если скажем div и p дочерний элемент body))	
									
									Селекторы Атрибута
Позволяет выбрать элементы в зависимости от того,если ли у селектора определенный атрибут и даже удостоверится 
$("img[alt]") //Что бы найти элементы img с атрибутом alt
Расмотрим различные селекторы атрибута:
$("a[href]")  //Находит все элементы а имеющие набот атрибутов href
$("input[type='text']") //найдет все окна с текстом в форме.Поскольку большинство элементов форм имеет один и тот же элемент(input),единственный способ определить тип элемента - это проверить его тип атрибута 
$('a[href^="http://"]') //найдет ссылки ведущие за пределы нашего сайта,^= обозначает начинается с, а именно в нашем примере с http:// ,что идет дальше не важно
$("a[href$='.pdf']") //выбирает элементы  чьи атрибуты заканчиваются определенным значением ,что великолепно подходит для поиска файловых расширений.В данном примере мы находим все ссылки указывающие на файлы .pdf	
$("a[href*='eksmo.ru']") //находит элементы с атрибутом в любом месте которого содержится конкретное значение,в данном примере мы найдем любые ссылки указывающие на отдельно взятый домен
	
									Фильтры jQuery
Библиотека jQuery позволяет фильтровать выборки, основываясь на определенных характеристиках
Например,с помощью фильтра :even несложно выбрать все нечетные элементы коллекции.Мы также можем находить элементы содежащие определенные жлементы,текст,скрытые элементы и даже элементы,коорые не соотвецтвуют данному селектору.
Чтобы использовать фильтр, добавьте двоеточие после основного селектора,а заним введите имя фильтра
Например чтобы найти все нечетные(1,3,5...) строки в таблице можно написать селектор jQuery следующим образом:
----------------------------------------------------------------------------
$("tr:even") //Выбирает нечетные числа
$("tr:odd")	 //Выбирает четные числа
//на самом деле even выбирает четные числа но выборка осуществляется как бы в массиве и счет идет 0,2,4  и получается метод возвращает 1,3,5 нечетные числа,с odd тоже самое ,поэтому чтобы не путать сразу пишу что нечетные выбырает
Фильтры :even и :odd вибирают каждый второй элемент в группе
-----------------------------------------------------------------------------

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	
$("p:first") //выбирает первый элемент абзаца 
$("p:last")	 //выбирает последний элемент
Фильтры :first и :last выбырают первый и последный элемент группы
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	

--------------------------------------------------------------------------------
$("a:not(.navButton)") 
Фильтр :not()находит элементы, не соответствующие данному типу селектора.Например мы хотим выбрать все элементы а,кроме тем которые относятся к класу navButton
//кпримеру мы захотели добавить цвет фона красным для всех ссылок кроме ... и not() указывает какие ссылки не будут красным фоном
Разрешается использовать фильтр :not() с любимы фильтрами и с большинством селекторов библиотеки jQuery.
Например чтобы найти все ссылки, начинающиеся не с http:// ,мы можем написать следующий код:
$("a:not([href^='http^//'])") 	
--------------------------------------------------------------------------------
	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	
Фильтр :has() находит элементы содержащие другой селектор.Например мы хотим найти все элементы li, но только если внутри них есть элемент а:	
$("li:has(a)")
Данный фильтр несколько отличается от селекторов потомков ,так как выбирается элементы li,а не ссылку(тег а),причем только те которые содержат ссылку	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
	
---------------------------------------------------------------------------------
Фильтр :contains() находит элементы,содержащие конкретный текст.Например, чтобы найти все ссылки,гласящие "Щелкни по мне!",мы можем:

$("a:contains(Щелкни по мне!)")	
//Крутой как по мне фильтр,ищет по словам 	
---------------------------------------------------------------------------------

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
Фильтр :hidden находит скрытые элементы,к которым относятся элементы ,обладающие свойством CSS display,установленным на значение none(которых мы не видим на странице)
Элементы которые мы скрываем используя hide() ,элементы чья высота и ширина равны нулю,а также скрытые элементы форм.Но данный селектор не применим к visibility,invisible;
Мы сожем найти и сделать их видимыми,используя jQuery следующим образом:

$("div:hidden").show();

Данная строка не воздействует на элементы div которые в настоящий видимы на странице 
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	
	
---------------------------------------------------------------------------------
Фильтр :visible находит на странице видимые элементы
$("p:visible").css("background-color", "red"); //для все видимых p будет фон крассный 
---------------------------------------------------------------------------------	
	
	
Библиотека jQuery использует уникальный принцип,называемый связыванием,что позволяет нам добавлять функции одну за другой
$("#popUp").width(300).height(300).text("Привет!").fadeIn(1000);

Этот код применяет четыре jQuery-функции: width(),height(), text(), fadeIn() к элементу с id popUp	
/*
можно разбивать такие строки на несколько строк:

$("#popUp").width(300)
.height(300)
.text("Привет!")
.fadeIn(1000);
*/	
	
	
					Добавление и манипулирование содержимым	с помощью jQuery функций	
/*
	Будем делать на примере данного кода:
	<div id="container">
		<div id="errors">
			<h2>Ошибки:</h2>
		</div>
	</div>
*/
--------------------------------------------------------------------------------
									Функция	.html()
Функция .html() может считывать существующий HTML-код внутры элемента,а также замещать текущее содержимое другим HTML-кодом.
Для возвращения HTML-кода из выборки просто добавьте .html() после выборки jQuery.Например мы можем, используя фрагмент HTML-кода в начале этого раздела:

alert($("#errors").html());

Данный код создает оповещение с текстом "<h2>Ошибки:</h2>".Используя функцию html() таким образом,мы сможем сделать копию HTML-кода,содержащегося внутри определенного элемента и вставить его в другой элемент на странице.
Если в качестве аргумента мы сообщим функции .html() строку,то заменим текущее содержимое выборки

$("#errors").html("<p>В данной форме четыре ошибки</p>");

Данная строка кода заменяет весь HTML-код внутри элемента с идентификатором errors
--------------------------------------------------------------------------------					

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
									Функция	.text()
Работа функции .text() похожа на работу функции .html(),но не принимает HTML-элементы.Она полезна,если нам необходимо заменить текст,заключенный в элемент.

$("#errors").text("Ни одной ошибки не найдено");
//Вообщем тоже самое что и .html() только .text() не может считывать существующий HTML-код внутры элемента

Функция text() преобразует все HTML-элементы в безопасные эквиваленты,от есть вместо
<script> получается &lt;script&gt
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

/*
	Если использовать функции .html() .text() для извлечения HTML-кода или текста из выборки,будет извлечен только из первого элемента выборки
	К примеру если мы извлекаем .html() к десяти div то код извлечет только из первого div
	Тем не менее при использовании .html() .text() для  вставки HTML-кода или текста,все выбранные элементы окажутся затронутыми в этой вставке
*/	
--------------------------------------------------------------------------------------
										Функция .append()
Функция .append() добавляет HTML-код в качестве последнего дочернего элемента выбранного элемента.Допустим,мы выбрали элемент div,но вместо замены его содержимого мы просто хотим добавить
фрагмент HTML-код перед закрывающим тегом </div> .Функция .append() - Это отличный способ добавить элемент в конец макрированного списка ul  или нумерованного списка ol.

$("#errors").append("<p>В данной форме четыре ошибки</p>");

После выполнения этой функции мы получаем:

<div id="container">
		<div id="errors">
			<h2>Ошибки:</h2>
			<p>В данной форме четыре ошибки</p>
		</div>
	</div>

Обратите внимание,что первоначальный HTML-код  внутри элемента div остается прежним и после него добавляется новый фрагмент HTML	
--------------------------------------------------------------------------------------	
	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
										Функция	.prepend()
Функция	.prepend() схожа с функцией .append(), но добавляет HTML-код прямо после открывающего тега выборки.

$("#errors").prepend("<p>В данной форме четыре ошибки</p>");

После выполненя функции .prepend() мы получаем:
<div id="container">
		<div id="errors">
			<p>В данной форме четыре ошибки</p>
			<h2>Ошибки:</h2>
		</div>
</div>
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	
	
--------------------------------------------------------------------------------------
									Функции .before() и .after()
Если нужно добавить код вне выборки,до открывающегося тега или после закрывающегося тега,используйте функции .before() и .after()
Например чтобы убедится что посетитель не оставил текстовое поле пустым:

<input type="text" name="userName" id="userName">//код для наглядности

$("#userName").before("<span class='error'>Имя пользователя обязательно</span>");//Выведет сообщение ПЕРЕД 
$("#userName").after("<span class='error'>Имя пользователя обязательно</span>");//Выведет сообщение После

--------------------------------------------------------------------------------------	
	
									Замена и удаление выборок

---------------------------------------------------------------------------------------
										Функция .remove()
Данная функция удаляет что-либо.К примеру мы создали всплывающее окно(более професионально чем alert,разместили его с помощью абсолютного позиционирование и когда нажимает кнопку закрыть мы конечно хотим закрыть его)
Что бы сделать это используем .remove().К примеру всплывающее окно имеет id="popup"

$("#popup").remove();

Функция .remove() не ограничивается только одним элементом.Предположим мы захотели удалить все элементы span с примененным к ним классом error:

$("span.error").remove();
---------------------------------------------------------------------------------------
	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
										Функция .replaceWith()
Функция заменяет какой-то элемент на другой.К примеру у нас есть картинки, и при клике на картику,покупатель добавляет товар в корзину,и мы хотим чтобы картинка менялась на текст:

$("#product101").replaceWith("<p>Добавлено в корзину</p>");

Данный код удаляет со страницы img и заменяет его элементом p
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
	
	
	
	
Библиотека jQuery предполагает функции для манипулирования атрибутом класса элемента

----------------------------------------------------------------------------------
										Функция addClass()
Функция addClass() добавляет элементу конкретный класс.Мы вводим функцию addClass() после выборки jQuery и передаем функции строку,предоставляющую собой имя класса,который мы добавляем
Например, чтобы добавить класс externalLink всем ссылкам,ведущим за пределы вышего сайта,можете использовать следующий код:

$("a[href^='http://']").addClass("externalLink");

Функция addClass() не исключает присвоенных классов,она просто добавляет новый
----------------------------------------------------------------------------------

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
										Функция removeClass()
Функция removeClass() удаляет  указанный класс из выбранных элементов.
Например если мы хотим удалить класс highlight из элемента div с идентификатором alertBox,сделайте следущее:

$("#alertBox").removeClass("highlight");
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
	
/*
	Применяя функции addClass() и revomeClass(), мы только передаем им имя класса,опуская точку которая обычно используется при ссоздании селектора класса.
	Например,запись addClass("externalLink")  правильна, а addClass(".externalLink") -Нет
*/	
	
----------------------------------------------------------------------------------
									Функция .toggleClass()	
Функция .toggleClass() позволяет включать или отключать отдельные классы,то есть добавлять класс,елси его еще нет или удалять имеющийся класс.	
Переключение- распостранненый способ показа элемента в действии или в бездействии.Например щелкая по элементу итерфейса "переключатель" ,мы его включаем,а когда щелкаем по нему снова,он исчезает
К примеру мы хотим при клике на id="changeStyle" появлялся класс altStyle и менял цвет страницы:

$("#changeStyle").click(function() {
	$("body").toggleClass("altStyle");
});

При первом клике добавляется класс(altStyle) при втором клике он удаляется,и так до бесконечности
----------------------------------------------------------------------------------	
	
									
									Чтение и извенение свойств CSS	
jQuery-функция css() позволяет изменять свойства CSS определенного элемента,то есть всесто того чтобы просто добавлять класс с какимито стилями,мы можем сразу в jQuery добавлять стили
Можно использовать функцию css() тремя способами:
1)Находить текущее значение свойства CSS определенного элемента(к примеру цвет фона,или ширину...)

var bgColor = $("#main").css("background-color");
/*
	jQuery возвращает цвета в rgb или в rgba,кроме того переводит все значения в пиксели даже если мы использует font-size: 150%
*/	
2)Устанавливать свойство CSS определенного элемента 

	
Функция css() позволяет присваивать элементу свойство CSS.Для этого мы должны передать функции два агрумента:имя свойства CSS и значение.

$("body").css("font-size", "200%");	
	
Второй агрумент может быть как строкой так и числом.Числовые значеня jQuery переводит в пиксели
К примеру чтобы изменить отступ в элементе класса pullquote на 100px :

$(".pullquote").css("padding", 100); 	
	
Часто полезно изменять свойства CSS,основываясь на текущем значении.Например когда мы нажимаем на кнопку "Увеличить текст" ,размер увеличивается в два раза                 
Для этого нужно прочитать значение,а затем установить новое значение.В данном случае мы сначала определяем текущий размер шрифта,а потом увеличиваем это значение в два раза:
	
var baseFont = $("body").css("font-size");
baseFont = parseInt(baseFont);
$("body").css("font-size", baseFont * 2);	
	
/*
	В первой строке возвращается значение размера шрифта эоемента  body.Причем значение возвращается в пикселях и является строкой,например "16px"
	Если мы хотим удвоих размер(умножить на 2),мы должны преобразовать эту строку в число,удалив часть "px"
	Во второй строчке кода используется метод JAVASCRIPT parseInt() - по сути эта функция отсекает все,что следует за числом,в нашем примере эта функция отсекает px и остается число 16
	И уже в третьей строки мы уже просто множим 16 * 2
*/	

	
3)Настраивать несколько свойст	CSS одновременно	
	
Передача функции .css() так называемой обьектной константы.Литерал обьекта(или обьектная константа) - это список пар свойств/значение.
После каждого имени свойства мы добавляем : ,за которым следует значение, пары свойств/значение разделяются запятыми,все это заключено	в фигурные собки {}

$(".submenu").css({"background-color" : "red", "font-size" : 20 });	
	
//Чтения в одну строку неудобен и многие программисты разбивают его
	
$(".submenu").css({
	"background-color" : "red", 
	"font-size" : 20 
});	
	
	
Есть также встроенная в jQuery возможность связывания:
	
$(".submenu").css(	"background-color", "red").css("font-size", 20 );	
	
Но данный код не оптимален,так как браузеру требуется выбрать элемент изменить и снова выбрать элемент и изменить,тратя на это ресурсы процессора	
	
	
	
							Чтение,установка и удаление атрибутов HTML	

----------------------------------------------------------------------------------
								Функция attr()
Функция attr()	- позволяет читать указанный атрибут HTML-элемента.
Например чтобы определить графический файл на который указывает элемент img ,мы передаем функции строку src:

var imageFile = $("#banner img").attr("src");

Функция attr() возвращает значение атрибута,установленного в HTML.В данном примере код возвращает свойство src для первого элемента img,
и переменная imageFile будет содержать путь к изображению:например "images/banner.png" или "http://www.thesite.com/images/banner.png"	
Здесь не важен регистр (href,HREF,hRef  все будет работать)

Передавая второй аргумент функции attr() ,мы можем установить атрибут элемента
Например чтобы перейти к другому изображению ,изменим свойство src элемента img:

$("#banner img").attr("src", "images/newImage.png");
----------------------------------------------------------------------------------							

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
									Функия .removeAttr()	
Функия .removeAttr() - удаляет атрибут элемента

$("a").removeAttr("href");	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	
	
						
	
							Работа с каждым элементом выборки
						
----------------------------------------------------------------------------------
									Функция .fadeOut()
Функция .fadeOut() - заставляет элемент медленно исчезать.Прикрепив данную функцию к выборке jQuery,содержащей несколько элементов,
функция прорабатывает выборку в цикле и заставляет медленно исчезать каждый ее элемент.
Например чтобы на страницу исчезли все элементы img,нужна всего лишь одна строка:

$("img").fadeOut();
----------------------------------------------------------------------------------
						
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
									Функция .each()						
Функция .each()	- позволяет перебрать серию элементов и с каждым из них выполнить определенное действие.
Чтобы использовать Функцию .each() мы передаем ей особый агрумент - анонимную функцию.Она содержит действия,которые вы хотите выполнить над каждым элементом.	
Поскольку это анонимная функция мы не можем ее вызвать(обычно вызывается по имени),в данном случае мы используем анонимную функцию в качестве аргумента для другой функции

$("selector").each(function(){
	//здесь помещается код
});	

jQuery-функция .each() позволяет перебрать все элементы выборки страницы и произвести серию действий над каждым из них
Функция .each() - действует как цикл ,инструкции содержащие в анонимной функции,будут поочередно применятся к каждому элементу
К примеру у нас на страницу есть 50 изображений и мы добавляем:

$("img").each(function(){
	alert("Найдено изображение!");
}); 

Появятся 50 диалоговых окон с оповищением Найдено изображение!


ЧТОБЫ ОБРАТИТСЯ К СЧЕТЧИКУ each():

$("img").each(function(i){
	alert("Найдено изображение!");
}); 

Счетчик нужнен кпримеру для смены фотографий где нужно отобразить каждую фотографию из массива

 
									Ключевое слово  $(this)
Чтобы получить доступ к элементу прорабатываемому  настоящий момент в цикле.
Оно относится к элементу,вызывающему анонимную функцию.Так при первом проходе цикла слово this относится к первому элементу выборки jQuery,при втором проходе цикла ко второму элементу ...
Слово this относится к чистому JS чтобы превратить слово this в его эквивалент в jQuery напишите: $(this)

Предположим что нужно найти все ссылки ведущие за пределы сайта:
1)Первый шаг получение списка всех ссылок ведущих за пределы сайта.

			$("a[href^='http://']")

2)Теперь чтобы выполнить цикл для каждой ссылки добавляем функцию .each() 

			$("a[href^='http://']").each(function(){

			});

3)Поскольку каждая ссылка имеет собственный URL-адрес ,нам нужен доступ к каждому элементу на каждом этапе цикла.Ключевое слово $(this) позволяет сделать это:

$("a[href^='http://']").each(function(){
	var extLink = $(this).attr("href");
});

Мы будем использовать ключевое слово $(this) почти при каждом применении функции .each()
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<						
						
----------------------------------------------------------------------------------
											Функция .clone()			
Функция .clone() - jQuery дублирует элемент ,включая весь HTML-код внутри него.
Клонирование позволяет скопировать элемент полностью,включая все присвоенные ему атрибуты.

	$(document).ready(function(){
		$("span.pq").each(function(){
			var quote = $(this).clone();
		});//End of each
	});//End of ready

В данном случае делается копия элемента span с классом pq, включая все присвоенные ему атрибуты.	
----------------------------------------------------------------------------------			
						
						
						
										
										CОбЫТИЯ
/*
Cтрукрута для всех событий 

	$("selector").имя события(function(){
		
	});
*/									
----------------------------------------------------------------------------------
									Нажатие на кнопку миши click
click --- Это собитие запускается,когда мы нажимаем и отпускаем кнопку мыши.Обычно оно присваивается ссылку с изображением при щелчке на который отображается рисунок большего размера.
//Событие click действует и в том случае,если ссылка нажимается с помощью клавиатуры
-----------------------------------------------------------------------------------

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
									Двойной щелчек мыши dblclick
dblclick --- Данное собитие запускается,когда вы дважды нажимаете и отпускаете кнопку мыши. Это действие мы выполняем,чтобы открыть файл или каталог на рабочем столе или в окне файлового менеджера операционой системы.
Щелчек по веб-странице - это не самое обычное действие,поэтому,используя это событие ,мы должны ясно дать посетителю понять,в каком месте страницы можно совершить двойной щелчок и что после этого произойдет.
Следует также отметить,что двойной щелчек кнопкой мыши равносилен двум одиночным щелчкам,поэтому не присваивайте собития одиночного и двойного щелчка одному и тому же элементу.В противном случае функция одинарного щелчка будет выполнена дважды до того,как запустится функция двойного щелчка 
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

----------------------------------------------------------------------------------
									Когда нажимаем на кнопку миши но не отпускаем mousedown 
mousedown --- Это первая часть щелчка,момент когда мы нажимаем кнопку мыши,но не отпускаем ее.Удобно при перетаскивании элементов по странице.
Мы можем позволить посетителям перетаскивать элементы по страницу так,как они это делают с ярлыками на рабочем столе операционной системы.
Пользователь должен щелкнуть  кнопкой мыши по какому-либо элементу и, не отпуская ее,переместить элемент на новое место,а потом отпустить кнопку мыши,в результате произойдет перемещение.
----------------------------------------------------------------------------------

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
									Момент когда отпускаем кнопку мыши mouseup
mouseup --- Событие mouseup,это вторая часть щелчка,момент когда мы отпускаем кнопку мыши.
Это событие удобно использовать тогда,когда мы "бросаем", на новое место элемент,который раньше находился в другом месте
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

----------------------------------------------------------------------------------
mouseover --- Запускается когда мы проводим указателем мыши по элементу страницы.Используя событие mouseover, мы можем присвоить навигационной
кнопке обработчик событий,заставляя появлятся подменю,когда посетитель проводит указателем мыши по кнопке
//Работает как превдокласс CSS :hover ,когда наводим он появляется но когда отводим мышку он не пропадает как при :hover 
//Другими словами обычный :hover в jQuery разбивается на при навидении mouseover и при убирании курсора мыши mouseout
----------------------------------------------------------------------------------

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
mouseout --- Запускается когда мы смещаем курсор с элемента.Мы можем использовать это событие,чтобы сигнализировать о том,
что посетитель убрал указатель мыши со страницы,либо чтобы спрятать всплывающее меню,когда указатель покидает его
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

----------------------------------------------------------------------------------
mousemove --- Это событие запускается,когда мы передвигаем курсор,то есть оно происходит постоянно.
Мы используем событие mousemove для отслеживания текущего положения указателя мыши на экране.
Дополнительно мы можем присвоить его отдельно взятому элементу в коде страницы,например div ,и реагировать только на передвижения указателя мыши внутри этого элемента
----------------------------------------------------------------------------------



								События документа/окна 

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
load --- Запускается Когда браузер заканчивает загрузку всех файлов веб-страницы: самого HTML-файла,связанных изображений,Flash-фильмов,внешних файлов CSS и Javascript
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

----------------------------------------------------------------------------------
resize --- Запускается когда мы изменяем размер окна браузера,нажимая кнопку разворачивания окна,либо изменяя ширину окна браузера,перетаскивая его границу.
Некоторые дизайнеры используют это событие для изменения шаблона страницы,когда посетитель изменяет размер окна своего браузера.
Например,можно проверить его ширину - если окно очень широко, то следует изменить дизайн и добавить больше столбцов,чтобы контент поместился на странице

$( window ).resize(function() {
  $( "body" ).prepend( "<div>" + $( window ).width() + "</div>" );
});

//В данном примере когда мы изменяем размер окна браузера,вверху страницы появляется текущий размер окна
/*
	Или такой простой пример:
$( window ).resize(function() {
	var $width = $(window).width();
	$( "body" ).prepend( "<div>" + $( window ).width() + "</div>" );
	if($width < 1000) {
	$("body").css("background-color","red");
	}else {
	$("body").css("background-color","orange");
	}
});
*/
----------------------------------------------------------------------------------	
	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	
scroll --- Запускается когда мы используем полосу прокрутки или клавиатуру(клавиши PageUp,PageDown,Home,End...)
либо когда прокручеваем веб-страницу с помощью колеса мыши.Если на странице нет полос прокрутки,событие scroll не запускается.
Некоторые программисты используют его,чтобы понять,в каком месте на экране появятся элементы(после прокрутки страницы)  	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	
	
----------------------------------------------------------------------------------
unload --- Запускается когда мы щелкаем по ссылке для перехода на другую страницу,закрываем вкладку в окне браузера или само окно
Это действие позволяет сделать последнее действи прежде чем посетитель покинет страницу
Некоторые программисты используют это событие чтобы предельно усложнить процесс покидания страницы.
Каждый раз когда посетитель пытаетсяпокинуть страницу,появляется новое окно и страница загружается снова.
Но это событие можно использовать и с добрыми намерениями,например, программа может предупреждать посетителя
о форме,которую он начал заполнять,но не отправил или программа может отослать данные формы на веб-сервер,чтобы сохранить информацию,прежде чем посетитель покинет страницу
----------------------------------------------------------------------------------


										События форм

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
submit --- Запускается когда посититель отправляет данные формы с помощью щелчка по кнопке Submit(отправить), 
или нажатие клавиши Enter когда курсор находится в текстовом поле.Наиболее часто это событие используется при 
проверки форм,чтобы убедится, что все требуемые элементы формы правильно заполнены,до того как данные будут отосланы на веб-сервер 
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

----------------------------------------------------------------------------------
reset --- Пусть и не часто но кнопка Reset(Отменить), может пригодится нам,чтобы отменить любые изменения,сделанные в форме.
Это событие возвращает страницу в состояние,в котором она находилась на тот момент,когда она была загружена
Мы можем запустить сценарий,когда посетитель пытается отменить форму,используя событие reset
Напрмер,если пользователь внес в форму какие-либо изменения,мы можем вызвать диалоговое окно с вопросом: 
"Вы уверены,что хотите отменить сделанные изменения?".Это окно даст пользователям возможность нажать кнопку НЕТ и предотвратить обнуление(очистку) формы.
----------------------------------------------------------------------------------

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
change --- Многие элементы формы запускают это событие при изменее их статуса,например,когда кто-нибудь
нажимает переключатель или выбирает пункт из выпадающего меню.Мы можем использовать событие change,
чтобы сразу же проверить выбор,сделанный в меню или посмотреть какоц переключатель был выбран
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

----------------------------------------------------------------------------------
focus --- Запускается,когда мы переходим к элементу формы,щелкая по нему мышью или нажимая клавижу TAB
Иначе говоря,теперь внимание браузера смокусировано на этом элементе страницы.Так,выбирая переключатель или устанавливая флажок,
мы вводим эти элементы в фокус.Мы можем реагировать на событие focus с помощью языка JAVASCRIPT.
Например длбавить полезную инструкцию в текстовое поле: "Введите ваше имя".Когда посититель устанавливает 
текстовый курсор в поле(вводя его в фокус),мы можем стереть эти инструкции и у пользователя будет пустое поле,которое можно заполнить
----------------------------------------------------------------------------------

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
blur --- Противоположно событию focus.Запускается,когда элемент формы выводится из фокуса(при нажатии клавиши TAB или при щелчке кнопкой мыши за пределами элемента)
Событие blur также полезно при проверки форм.Например,когда когда кто-либо вводит свой электронный адресс
в текстовое поле и клавишей TAB переходит к следующему элементу,мы можем сразу же проверить,что ввел посетитель,чтобы убедится,что это -правильный почтовый адрес
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
/*
	События focus и blur также применимы к ссылкам на странице.Когда мы с помощью клавиши TAB переходим к ссылке,запускается
	событие focus,а когдамы "сходим" со ссылки с помощью клавиши TAB (или щелчка кнопкой мыши),запускается событие blur
*/



										События клавиатуры
Браузеры также отслеживают как посетитель использует свою клавиатуру,поэтому мы можем присваивать команды клавишам
Например нажав Пробел посетитель может запустить или остановить анимацию JAVASCRIPT
К сожалению браузеры по-разному реагируют на события клавиатуры,иногда сложно даже установить какая буква была введена

-------------------------------------------------------------------------------
keypress --- Это событие запускается в тот момент когда мы нажимаем клавишу.Причем,чтобы оно сработало,нам необезательно эту клавишу отпускать.
Событие keypress запускается снова и снова до тех пор,пока клавиша удерживается нажатой,поэтому данное событие позволяет проверить 
удерживает ли посетитель  клавишу нажатой.Например,если мы создали гоночную онлайн-игру,мы можем назначить клавишу для пердали газа.
Игроку требуется только нажать и удерживать эту клавину,чтобы заставить машину двигатся
-------------------------------------------------------------------------------

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
keydown --- Подобно событию keypress,оно запускается при нажатии клавиши.На самом деле оно запускается непосредственно перед запуском события keypress.
В браузере Opera событие keydown запускается только один раз,в других программах работает так же как и событие keypress,запускается снова и свова,пока клавиша нажата
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

-------------------------------------------------------------------------------
keyup --- Запускается когда мы отпускаем клавишу
-------------------------------------------------------------------------------

								Как использовать событие: 	
1)Выбрать один или более элементов $("a")
2)Назначаем событие к примеру $("a").имя события, более явный пример: $("a").click()
3)Передать функцию событию,в функции должны быть команды которые станут выполнятся при запуске события.
Мы можем передать имя функции следующим образом: 

$("#start").click(startSlideShow);

Когда мы присваиваем событию функцию то опускаем круглые скобки(),обычно добавляемые после функции для ее вызова
//Другими словами,следующий код работать не будет: $("#start").click(startSlideShow()) 

Однако наиболее распостраненный способ добавления функции - это передать анонимную функцию(функция без имени)
$("#start").click(function(){
	
});




									Ожидание загрузки HTML-кода 
$(document).ready(function(){
	//Здесь находится код
});

Функция .ready() позволяет дождатся загрузки всей страницы,а потом запускать сам код JAVASCRIPT
Как правило,весь программный код находится внутри этой функции,которая настолько важна,что нам следует использовать ее на всех страницах,
где мы используем библиотеку jQuery.Мы должны включить ее однажды,это обычно первая и последняя строки нашего кода.
/*
	Поскольку функция .ready() используетсяпрактически каждый раз при добавлении кода jQuery,
	ее можно записывать коротко.Удалив часть $(document).ready
	$(function() {
		
	});
*/

									Где лучше размещать код?
Нету однозначного ответа,если разместить в head то возможно если много внешних ссылок прийдется посетителю прийдется ждать несколько секунд,
но после первого раза,благодаря кэшированию в следующий раз страница будет грузится гараздо быстрее,
если разместить в body, то возможно страница будет менятся прямо на глазах у посетителя....
Другими словами не переживайте если страница загружается медлено,но если это поможет переместите код в конец страницы.
Но в большенстве случаем нету разницы используем ли мы функцию .ready() в верхней части страницы или нет
/*
	При создании веб-страниц на компьютере и ее тестировании мы не столкнемся с данными проблемами,
	Только когда мы разместим свой сайт на веб-сервере, у нас могут возникнуть проблемы связанные со скоростью загрузки
*/


								Событие наведения и смещения мыши
Поскольку использование этих событий(наведение и смещения мыши) в паре это обычно, jQuery предлагает краткий способ обращения к обоим.
Функция hover() работает как и любое другое событие,кроме того что вместо одного агрумента(функции) оно принемает две функции.
Первая функция выполняется при наведении указателя мыши на элемент,а вторая при смещении с него. 

$("selector").hover(функция1, функция2);
//$("selector").hover(function(){}, function(){});
Данный код используется часто,к примеру чтобы появился невидиммый элемент div(скажем подменю) при наведении,а
при сдвиге курсора мышки подменю снова оказывается скрытым.Для этого и используется функция hover()

$("#menu").hover(function(){
	$("#submenu").show();
},function(){
	$("#submenu").hide();	
});
	
	
										Обьект события
В момент запуска события браузер записывает информацию о нем и сохраняет его в так называемом обьекте события.
Обьект события содержит данные, собранные в момент,когда произошло событие,такие как координаты указателя мыши по горизонтали и вертикали...
В библиотеки jQuery обьект доступен для функции.Обьект передается функции как агрумент,и чтобы получить к нему доступ мы всего лишь добавляем к функции имя парамента
Например,мы хотим найти координаты указателя мыши в момент,когда происходит щелчек в каком-то либо месте страницы.	
	
$(document).click(function(events){
	var xPos = events.pageX;
	var yPos = events.pageY;
	alert("X:"+ xPos+" Y:"+ yPos);
});

Здесь важна переменная events.Когда вызывается функция(при щелчке),обьект события сохраняется в переменной events
В данном примере events - это имя переменной,присвоеное программистом.Это не ключевое слово,а просто
переменная для сохранения обьекта события.Мы можем использовать любое имя

Обьект события имеет различные свойства(к несчастью) их список в каждом браузере может быть разным
Вот перечень некоторых общих свойств:

-------------------------------------------------------------------------------
pageX --- Расстояние(в пикселях) от указателя мыши до левого края окна браузера(другуми словами растояние ведется от левого края страницы)
-------------------------------------------------------------------------------

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
pageY --- Расстояние(в пикселях) от указателя мыши до верхнего края окна браузера(от верхнего края браузера до мышки)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	

-------------------------------------------------------------------------------
screenX ---	Расстояние (в пикселях) от указателя мыши до левого края монитора
-------------------------------------------------------------------------------	

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
screenY	--- Расстояние(в пикселях) от стрелки мыши до верхнего края монитора 
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	

-------------------------------------------------------------------------------
shiftKey --- Является истинным,если клавиша Shift была нажата,когда происходило событие	
-------------------------------------------------------------------------------	

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
which --- Используется с событием нажатия клавиши для определения числового кода нажатой клавиши
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	

-------------------------------------------------------------------------------
target --- Обьект,бывший целью события,например для события click() - это элемент,по которому щелкнули кнопкой мыши	
-------------------------------------------------------------------------------	

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
data --- Обьект jQuery,использованный с функцией blind() для передачи данных функции, управляющей собитием	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	
	

								
									Отмена обычного поведения событий(отмена события)
Некоторые элементы HTML-кода имеют заранее запрограммированные реакции на события.
Например,при щелчке по ссылке обычно загружается новая веб-страница,щелчек по кнопке подтверждения формы отсылает данные на веб-сервер для обработки
Иногда мы хотим,чтобы браузер повел себя не так как обычно. Допустим,при подтверждении
формы(событие submit()) мы можем пожелать остановить ее отправку,пока посититель не внесет в форму недостающих выжных данных
	
Функция preventDefault() позволяет отменить нормальное поведение браузера.
Она является частью обьекта события,поэтому доступ к ней осуществляется в рамках функции,управляющей событием	
Допустим, на странице есть ссылка с идентификатором menu. Она указывает на другую страницу меню.
Однако мы добавили умный код JavaScript, и если посетитель щелкает по ссылке,меню появляется на той же странице.
Но,как правило,браузер все же проследует по ссылке,поэтому нам необходимо отменить его обычное поведение следующим образом:
		
$("#menu").click(function(ev){
	//Какой-то Умный код
	ev.preventDefault();
});	
	
Другой вариант это просто возвращение значения false, как результат выполнения функции события.
Например следующий код функционально оналогичен коду приведенному выше:
	
	$("#menu").click(function(ev){
	//Какой-то Умный код
	return false;
});	

									
									Удаление событий
Иногда нам может понадобится удалить событие которое мы ранее присвоили элементу.
jQuery-функция off() позволяет это сделать.Например,если мы хотим отменить реакцию всех 
элементов с классов c классом tabButton на событие щелчка кнопкой мыши, то мы можем использовать следующий код:

$(".tabButton").off("click");


Теперь более сложный пример:
$("a").mouseover(function(){
	alert("Hello!");//Добавляем событие,при наведении выводи Hello
});
$("#disable").click(function(){
	$("a").off("mouseover");
});
	
Когда пользователь щелкает по элементу #disable (например по кнопке формы),событие наведение мыши удаляется со всех ссылок и больше не появляется

Если мы хотим удалить все события с элемента не передавайте функции off() никаких аргументов.
Например чтобы удалить все события (mouseover,click,dblclick) с кнопки отправки,мы можем написать

$("input[type='submit']").off();


Библиотека jQuery предлагает функцию stopPropagation() препятствующую присвоению события любому элементу-предку.
К примеру при щелчке на div мы выбираем изображение и когда щелкаем по изображению div тоже автоматически срабатывает на click()
и мы не хотим чтобы при щелчке по изображению с div тоже срабатывал на щелчек,в данном
случае мы должны предотвратить присвоение div события click,тоисть при щелчке по картинке она должна загрузить новое изображение и останови событие щелчка

$(#theLink).click(function(evt){
	//некие действие
	evt.stopPropagation();//остановить событие
});



								Професионально управление событиями 	
Метод on() - это более гибкий способ работы с событиями по сравнению с событиям
такими как click() или mouseover().Он позволяет не только указывать событие и функцию для реакции на него,
но и передавать дополнительные данные для использования функцией,обрабатывающей событие.
Это дает возможность различным элементам и событиям передавать различную информацию одной и той же функции

По мере развития библиотеки jQuery имена функция изменились.При чтении более раних книг или статей
можно наткнутся на  такие функции как bind(), live(), delegate() - все они были заменены одной функцией on(),
предназначенной для добавления событий к элементам.Кроме того функция off() заменила 
функцию unbind(),которая использовалась для удаления событий с элементов

Итак формат функции on() cледующий:

$("selector").on("событие мыши", селектор ,данные, имя функции);

1.Первый агрумент- это строка,содержащая имя события(щелчек,наведения курсора,и любые другие события перечисленные в разделе Событие мыши)
2.Второй аргумент не является обязательным, так что нет необходимости предоставлять значение для него 
при использовании функции on().Если мы все-таки решим передать аргумент, то он должен представлять собой допустимый селктор,например, tr,.callout, #alarm
/*
	можно использовать 2й аргумент для того, чтобы применить событие к другому элементу в рамках выделенного элемента
*/
3.Третий аргумент - это данные,которые мы желаем передать функции(литерал обьекта или переменую).
Литерал обьекта(или обьектная константа)- это список имен свойств и их значений:

{
	firstName : "Ivan",
	lastName : "Ivanov"
}

Мы можем сохранить литерал обьекта в перемоной следующим образом:

var linkVar = {message: "Привет от ссылки"};

4.Четвертый аргумент,другая функция,та самая которая выполняет какое-либо действие при запуске события.
Это может быть или анонимная функция или функция с именем


Передача данных при использовании функции on() не обязательна.Мы можем использовать функцию on()
просто чтобы присоединить событие и функцию,опустив аргумент с данными:

$("selector").on("событие мыши", "имя функции");
это тоже самое что и :
$("selector").click(имя функции);


Предположим мы хотим создать всплывающее окно с оповищением в ответ на событие,но сообщение в окне
должно быть разным в зависимости от того, какой элемент инициировал событие.
Один из способов сделать это - создать переменные,хранящие различные обьектные константы,а затем предать переменные функции on():

var linkVar = {message: "Привет от ссылки"};
var pVar = {message: "Привет от абзаца"};
function showMessage(evt) {
	alert(evt.data.message);
} 
$("a").on("nouseover", linkVar, showMessage);
$("p").on("click",pVar, showMessage);


Создали 2 переменные с одними и тем же именами свойства(message), но с разным текстом
Функция showMessage принимамет обьект события и сохраняет его в переменной evt
Эта функция запускает команду alert(),отображая свойство message(которое само является свойством свойства data обьекта события)
Другми словами мы создаем обьект и записываем все что нужно передать,а потом с помощью
функции и ключевого слова data вызваем данные на какое-нибудь событие


Прелесть функции on() состоит в тои что мы можем задавать сразу несколько событий:

$(document).on("click keypress",function(){
	$("p").hide("slow");
});

Важная часть click keypress,представляющая несколько имен событий разделенных пробелом
мы приказываем jQuery выполнить анонимную функцию при запуске любого события(в данном случае click или keypress)
К тому же мы можем присоединить несколько событий каждый из которых запускает различные действия,
нам не обезательно использовать функцию on() несколько раз.Другими словами если мы хотим
чтобы произошло одно событие при щелчке по элемнту,а другом при наведении на этот элемент указателя мыши мы можем написать следующий код:

$("#theElement").on("click", function(){
	//какое-то интересное действие
});
$("#theElement").on("mouseover", function(){
	//еще какое-то интересное действие
});
Мы можем добится того же результата передав функции on(), обьектную константу,
состоящую из имени события,за которой следуют двоеточие и анонимная функция.
К примеру переписанный выше код с использованием обьектной константы будет выглядеть вот так:

$("#theElement").on({
	"click" : function() {
		//какое-то интересное действие
	},//окончание функции click 
	"mouseover" : function() {
		//еще какое-то интересное действие
	}
});


Тем не менее у этого метода присоединения обработчиков событий к элементам существует одна проблема:
он работает только в том случае,если элемент уже присуцтвует на странице.
Если мы динамически добавляем HTML-код после добавления такого обработчика событий как,
сlick(),mouseover, или on() то к этим новым элементам не будут присоединены никакие обработчики событий.
К примеру мы создали  список дел,при вводе текста и клике на кнопку "добавить в список дел"
мы получаем список итак, ul уже есть на сайте, а вот li еще нету так как списока дела еще нету(а он добавляется именно в li) 
Проблема в том что при загрузке страницы на ней нет элементов li так что добавления обработчика события click к
каждому элементу не приведет к каким-то изменениям.
/*
Другими словами этот код работать не будет:
	$("li").on("click", function(){
		$(this).css("text-decoration", "line-through");
	});
*/
Вместо этого нам следует делегировать события,то есть,применить событие к родительскому элементу,
находящемуся на более высоком уровне в цепочке(к элементу который уже присуцтвует на странице),
а затем отслеживать эти события на конкретных дочерних элементах.
Поскольку событие применяется к уже существующему элементу,добавление новых дочерних элементов не повлияет на этот процес.
Другими словами мы делегируем отслеживание событий уже существующему родительскому элементу.
Нам нужно использовать функцию on() следующим образом:

$("ul").on("click", "li", function(){
		$(this).css("text-decoration", "line-through");
});

При создании страницы мы добавили пустой элемент ul, в качестве контейнера для добавления каждого нового задания в элементе li
В результате при загрузке страницы один пустой элемент ul уже находится на месте.
Затем выполнение проведенного выше кода добавляет в этот элемент функцию on().
Посетитель еще не добавил в список никаких пунктов,так что там пока отсутствуют элементы li.
Тем не менее при добавлении селектора li в качестве второго аргумента функции on() мы заявляем о том,
что хотим отследить события click не в ul,а в любом элементе li,присутствующем в этом неупорядоченном списке.
Время добавления элемента li не имеет значения,поскольку отслеживанием событий занимается элемент ul	
		
/*	
$("ul").on("click", "li", function(){
		$(this).css("text-decoration", "line-through");
});

Другими словами если у нас есть уже список и если  убрать li то при клике на любой из элиметов мы подчеркнется
весь ul а не отдельные li,а если оставить как в примере то будет подчеркиватся отдельные li
*/	
	
В большенстве случаем такой подход не нужен но с технологией Ajax где контент динамически добавляется она пригодится	
	
В некоторых случаях	мы можем применять делегирование событий просто для эффективности кода.Если мы добавляем
большое количество элементов к одному и тому же обработчику событий,например сотни ячеек таблицы,то часто
лучше бывает делегировать событие элементу table следующим образом:

$("table").on("click", "td", function(){
	//Code
});
	
Применяя событие к таблице,мы устраняем необходимость применять обработчики событий непосредственно к сотням
или даже тысячам отдельных элементов,поскольку эта задача может поглотить всю вычеслительную мощность браузера 
//Как в случае с CSS загрузкой картинки так и тут,браузеру легче обработать одну большую картинку/или какой нибудь запрос чем много мелких
	
	
$(".main h2").click(function(){
	var $answer = $(this).next(".answer");
});	
	
//$answer --- это переменная,переменная начинается с символа $,это указывает на то что мы сохраняем обьект jQuery(результат выполнения функции)
	
-------------------------------------------------------------------------------
Функция .next()	находит элемент который следует непосредственно за текущим элементом.
Другими словами,она находит элемент следующий за элементом h2.Мы можем уточнить этот поиск,
передав дополнительный селектор функции .next().Код .next(".answer") находит первый элемент 
после элемента h2, который также имеет класс answer
Скрывает только один элемент(один из li или первый div...)
-------------------------------------------------------------------------------	

	
$(".main h2").click(function(){
		var $answer = $(this).next(".answer");
		if($answer.is(":hidden")) {
			
		}else {
		
		}
});	

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
Функция is(),чтобы проверить не является ли конкретный элемент скрытым.
Метод is() позволяет проверить сообтвецтвует ли текущий элемент конкретному селектору.
Мы передаем функции любой селектор CSS или jQuery, и эта функция прверяет соответствует ли обьект данному селектору.
Если да,то функция возвращает значение true,если нет то false.
Используемый в коде селектор :hidden является особым,присущим только в jQuery селектором,
который	определяет скрытые элементы.В данном случае мы проверяем, не скрыл ли ответ.Еслли нет,то мы можем его отобразить
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
	
	

$(".main h2").click(function(){
	var $answer = $(this).next(".answer");
	if($answer.is(":hidden")) {
		$answer.slideDown();
	}else {
		
	}
});	yjtukiy,uiuil
	
-------------------------------------------------------------------------------
slideDown() --- это одна из jQuery-функций,предназначенных для создания анимации.
При ее использовании скрытые элементы отображаются на странице, как бы выезжая из-под отображенных.	
-------------------------------------------------------------------------------	  
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	
	
-------------------------------------------------------------------------------
fadeOut() --- Это наподобии slideDown(),только если slideDown() выползает то fadeOut() бликает и появляется
fadeIn() ---это наподобии slideUp()
-------------------------------------------------------------------------------	
	
										
										Анимация jQuery
Каждая из функций эффекта может иметь настройки скорости и функцию обратного вызова.
Скорость - это период времени,необходимый для выполнения эффекта.
Обратный визов - это функция,которая выполняется по завершении эффекта
	
Чтобы задать скорость эффекта,соответствующей функции передается одно из трех строковых
значений("fast", "normal" или "slow") либо число,представляющее количество милисекунд,
необходимых для завершения эффекта(1000 = 1 секунда, 500 = полсекунды ...)
Например, код для медленного исчезновения элемента будет выглядеть так:

	$("element").fadeOut("slow");
	
Или к примеру мы хотим чтобы элемент исчезал в течении 10 секунд:
	
	$("element").fadeOut(10000);
	
	
Ключевые слова,используемые для задавания скорости эффекта:
"fast", "normal" или "slow" --- соответствуют 200, 400, и 600 миллисекундам.

$("element").fadeOut("slow"); 
это тоже самое что и :
$("element").fadeOut(600); 

	
								Основы отображения и сокрытия
Библиотека jQuery предлагает три функции для отображения и сокрытия элементов:

-------------------------------------------------------------------------------
show() --- показывает ранее скрытый элемент.Она не работает,когда элемент уже виден на странице.
Если мы не устанавливаем значение скорости,элемент появляется моментально.
Однако если скорость заданна,например,show(1000), то элемент анимируется от верхнего левого к нижнему левому.
-------------------------------------------------------------------------------	

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
hide() --- скрывает видимый элемент.Она не работает,если элемент уже скрыт,и точно также как show(),
если мы не передаем значения скорости то элемент моментально исчезает.
Однако при установленном значении скорости он исчезает,как бы сужаясь 
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	
	
-------------------------------------------------------------------------------
toggle() --- переключает текущее состояние элемента.Если элемент в данный момент отображен,
то функция toggle() скрывает его.Если элемент скрыт,она заставляет его появиться.
Эта функция идеально подходит,когда нам нужен один элемент управления(например кнопка),
для попеременного показа и сокрытия элемента. 
-------------------------------------------------------------------------------	
	
	
					
					Постепенное появление и исчезновение элементов

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
fadeIn() --- показывает скрытый элемент.Сначала на странице появляется пространство для элемента
(это может означать,что остальные элементы страницы сдвинутся с места),затем элемент постепенно становится видимым.
Данная функция не работает,если элемент уже виден на странице.
Если мы не зададим скорость,эффект появления будет использовать значения "normal"(400 миллисекунд)					
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<					

-------------------------------------------------------------------------------
fadeOut() --- заставляет элемент исчезать,делая его прозрачным.Она не работает если элемент уже скрыт.
Как и в случае с функцией fadeIn(),если мы не срисваиваем значения скорости,то элемент
исчезает в течении 400 миллисекунд.	
-------------------------------------------------------------------------------	
	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
fadeToggle() --- сочетает эффекты функций fadeIn() и fadeOut().
Если в настоящий момент элемент скрыт,то при использовании функции fadeToggle() он появляется,
если виден,то исчезает.Мы можем использовать данную функцию для того,чтобы заставить рамку
с инструкциями появлятся и исчезать со страницы.Например у нас есть кнопка со словом "Инструкции".
Когда посетитель щелкает по ней,появляются инструкции,при повторном щелчке - они исчезают.	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	
	
-------------------------------------------------------------------------------
fadeTo() --- работает немного не так,как остальные функции.Она изменяет степень 
непрозрачности изображения до определенного значения.Например,мы можем сделать
картинку полупрозрачной.В отличие от остальных эффектов,задавание скорости является обязательным
Дополнительно присваивается числовая величина в диапазоне от 0 до 1,характеризующая
степень непрозрачности элемента.Например,чтобы сделать все абзацы на 75% непрозрачными:

$("p").fadeTo("normal", .75);

Данная функция изменяет степень	непрозрачности элемента вне зависимости от того,виден он или нет.
Например,мы задаем значение непрозрачности,равное 50%,для элемента который в настоящий момент скрыт.
Если затем мы отобразим этот элемент,он окажется полупрозрачным.
-------------------------------------------------------------------------------	
	
	
								Скользящие элементы
	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
slideDown() --- заставляет скрытый элемент появится в поле зрения.
Сначала появляется верхняя часть,и по мере появления остальной части,то,что находится
под элементом сдвигается вниз.Функция не влияет на элемент уже видимый на странице.
Если мы не присваиваем значение скорости то элемент появляется на странице используя настройку "normal"(400 миллисекунд)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	
	
--------------------------------------------------------------------------------
slideUp() --- удаляет элемент из виду,скрывая его нижнюю часть и двигая все,что находится ниже,
вверх по мере того,как элемент исчезает.Эффекта не будет,если элемент уже скрыт.
Как и в случае с функцией slideDown(),если мы не зададим значение скорости,по умолчанию будет "normal"(400 миллисекунд)
--------------------------------------------------------------------------------	
	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
slideToggle() --- применяет функцию slideDown() к элементу,который в данный момент скрыт,
а функцию slideUp() к видимому.Она позволяет создать единный элемент управления,
например кнопку,как для отображения,так и для сокрытия элемента	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	
	
	
Обычно когда мы скрываем или показываем элемент на странице,другие элементы сдвигаются,чтобы занять его место.
Например если скрыть изображение,то содержимое которое было ниже его,сдвинется вверх.
Чтобы контент не прыгал,можно воспользоватся position: absolute;  	
	
	
										Анимация
Используя функцию animate() мы можем анимировать любое свойство CSS,принимающее числовое значение(пискселы,em или проценты).
Например размер текста,позицию элемента на странице,степень непрозрачности обьекта или толщину границы.
//Сама по себе библиотека jQuery не может анимировать изменения цвета,текста или границы.Однако это может сделать плагин jQuery UI 

Для использования этой функции нам следует передать обьектую константу,содержащую список свойств CSS,
которые мы хотим изменить, и значения,изменения на которые необходимо анимировать.
Например мы хотим анимировать элемент,передвинув его на 650px от левого края,изменить степень прозрачности на 50% 
и увеличив размер шрифта до 24px:

{
	left: "650px",
	opacity: .5,
	fontSize: "24px"
}	
	
//В кавычки берем только если оно включает единицу измерения (px, em, %)	
	
	
Язык JavaScript не принимает дефисы в именнах свойств CSS.Например,font-size-это свойство CSS,
но javascript не понимает его,поскольку дефис в языке JavaScript соответствует операции минус.
При использовании свойств CSS в JavaScript удалите дефис и сделайте заглавной первую букву слова,следующего за дефисом
Например,font-size станет 
ize,a border-width - borderWidth.
Однако если мы предпочетаем имена свойств,принятые в CSS(чтобы не путать),заключаем их в кавычки:

{
	"font-size": "24px",
	"border-left-width": "2%"
}

К примеру мы хотим анимировать элемент #message:

$("#message").animate(
{
	left: "650px",
	opacity: .5,
	fontSize: "24px"
},
1500
);

-------------------------------------------------------------------------------
Функция animate() --- может принимать несколько аргументов.
Первый - это литерал обьекта,содержащий свойства CSS, которые мы желаем анимировать.
Второй - это длительность анимации(в миллесикундах).В примере выше 1500 миллесикунд(1,5 секунды)
-------------------------------------------------------------------------------
	
Мы также можем задать относительно его текущего значения,используя операции += или -= как часть настроек аниамции
Например,мы хотим анимировать элемент,сдвигае его на 50 пикселов вправо при каждом щелчке по нему:

$("#moveIt").click(function(){
	$(this).animate({
		left: "+=50"
	},
	1000
	});
});	

/*
Если к примеру, быстро наводить курсор и убирать,то мы заметим что элемент продолжит появлятся и исчезать
еще некоторое время после того как мы прекратим передвигать указатель мыши.
Причина данной проблемы из-за того что jQuery создает очередь анимационных эффектов.	
Любой анимационный эффект помещается в очередь и если мы наводим и убираем мышку то jQuery
добавляет в очередь ,а потом выполняет по порядку. 
Решением  данной проблемы является остановка всех анимационных эффектов перед запуском новой анимации.
Другими словами,когда мы наводим указателем мыши на элемент div,который находится 
в процессе анимации,jQuery должна остановить выполняемую в данный момент анимацию и запустить эффект,
соответствующий событию наведению.К счастью,библиотека jQuery предусматривает
функцию stop() для такого рода задач	

$(this).stop().animate({
		left: "0",
		backgroundColor: "rgb(27,45,94)"
	},
	500,
	"easeInSine");
	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
stop() --- фукнция stop() просто заверщает любой анимационный эффект,прежде чем 
запускать новый и предотвращает создание очереди эффектов	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	

*/
	
							Управление скоростью анимации
Функции jQuery(slideUp(),fadeIn()....),а также функция animation(),принимает еще один аргумент,
который контролирует скорость во время анимации: easing.
Например,при перемещении элемента по странице движение элемента может начинатся медленно,затем ускорятся и  наконец замедлятся
Библиотека jQuery включает только два метода easing: swing и linear.

1)Метод linear производит равномерную анимацию,так что каждый шаг анимации подобен всем остальным
(например,если мы анимируем перемещение элемента по экрану,каждый шаг будет соответствовать одному и тому же растоянию)

2)Метод swing более динамичен: анимация начинается в более быстром темпе,а затем замедляется.
Метод swing установлен по умолчанию,поэтому если мы не укажем аргумент easing, jQuery будет использовать метод swing 
	
	
Аргумент easing указывается вторым по порядку для любого эффекта jQuery,поэтому чтобы заставить элемент
сместить вверх,используя линейный метод,напишем следующий код:
 	
	$("#element").slideUp(1000,	"linear");
	
	
При использовании функции animate() метод easing указывается в качестве третьего аргумента после обьектной константы,
содержащей свойства CSS,которые мы хотим анимировать и значения общей скорости анимации.
Например,чтобы использовать линейный метод easing в коде:
	
	
$("#message").animate(
{
	left: "650px",
	opacity: .5,
	fontSize: "24px"
},
1500,
"linear"
);

//jQuery UI включает множество дополнительных методов easing
//api.jqueryui.com/easings --- полный список методов (easing --управление скоростью анимации)

Чтобы использовать jQuery UI (который представляет собой внешний файл),нужно поместить ссылку на этот файл на своей странице.
Например чтобы элемент div оригинально увеличивался в размере при щелчке:

$("#animate").click(function(){
		$(this).animate({
			width: "400px",
			height: "400px"
		},
		1000,
		"easeInBounce"
		);
});


					Выполнение действия после завершения эффекта
Для решения этой дилеммы мы можем передать функцию обратного вызова люому эффекту.
Например на нашей странице есть изображение с идентификатором photo,а под ним абзац caption
Чтобы появилась фотография и только потом надпись,можно использовать функцию обратного вызова:

$("#photo").fadeIn(1000, function(){
		$("#caption").fadeIn();
});


Функции обратного вызова это единственный способ выполнить действия поочередно
//Тоисть сначала передвинуть картинку в центр,потом вывести название,потом название передвинуть а потом скрыть все 
 					
Тем не менее нам необязательно использовать функцию обратного вызова,можно использовать				
так сказать хитрости.К примеру нам нужно переместить картинку,а потом скрыть ее:
$("img").animate({
	"margin-left": "400px"
},1000);

$("img").fadeOut(3000);
//В данном случае код выполняется сразу,но картинка отодвигается за 1 секунду а исчезает за 3 

Используя связывание можно переписать данный код:

$("img").animate({
	"margin-left": "400px"
},1000).fadeOut(3000);
//Тот же реультат что и выше

Если мы хотим чтобы фотография появилась,исчезла и снова появилась,можно использовать связывание так:

$("img").fadeOut(1000).fadeIn(1000).fadeOut(1000);

-------------------------------------------------------------------------------
delay() --- данная функция просто ожидает определенное количество миллисекунд,прежде чем запускать следующуий эффект.
Например,мы хотим чтобы изображение исчезло через 10 секунд после своего появления:

$("#photo").fadeIn(1000).delay(10000).fadeOut(250);
-------------------------------------------------------------------------------


	
	
Если к примеру, быстро наводить курсор и убирать,то мы заметим что элемент продолжит появлятся и исчезать
еще некоторое время после того как мы прекратим передвигать указатель мыши.
Причина данной проблемы из-за того что jQuery создает очередь анимационных эффектов.	
Любой анимационный эффект помещается в очередь и если мы наводим и убираем мышку то jQuery
добавляет в очередь ,а потом выполняет по порядку. 
Решением  данной проблемы является остановка всех анимационных эффектов перед запуском новой анимации.
Другими словами,когда мы наводим указателем мыши на элемент div,который находится 
в процессе анимации,jQuery должна остановить выполняемую в данный момент анимацию и запустить эффект,
соответствующий событию наведению.К счастью,библиотека jQuery предусматривает
функцию stop() для такого рода задач	

$(this).stop().animate({
		left: "0",
		backgroundColor: "rgb(27,45,94)"
	},
	500,
	"easeInSine");
	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
stop() --- фукнция stop() просто заверщает любой анимационный эффект,прежде чем 
запускать новый и предотвращает создание очереди эффектов	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	
	
	
Библиотека jQuery знает о префиксах вендоров(-webkit-,-moz-,...).Когда мы указываем значение
свойства CSS,требующего наличия префиксов,jQuery также устанавлвает версии свойств CSS с префиксами вендоров
	

	
	
								Смена изображения
Чтобы заменить файл изображения используем функцию attr()

$("#photo").attr("src", "images/newImage.jpg");
	
	
Изменения атрибута src изображения не затрагивает всех остальных атрибутов элемента img
Например если установлен атрибут, alt ,то измененное изображение будет иметь тот же 
атрибут что и оригинал.Если указаны height и width то новые картинки будут подстраиватся под эти настройки
	
	
Другое решение - это сначала загрузить новое изображение,получить его размеры,
а затем изменить атрибуты src,width,height и alt для элемента img:

var newPhoto = new Image();
newPhoto.src= "images/newImage.jpg";
var photo = $("#photo");
photo.attr("src", newPhoto.src);
photo.attr("width", newPhoto.width);
photo.attr("height", newPhoto.height);

/*
	Код new Image() - сообщает браузеру "Я собираюсь добавить на страницу новое изображение"
	newPhoto.src= "images/newImage.jpg"; --загружает новую картинку
	var photo = $("#photo"); - текущее изображение на странице
	дальше меняется высота и ширина
*/
	
jQuery-фукнция attr(),может одновременно устанавливать  Можно написать код короче.	
	
var newPhoto = new Image();
newPhoto.src= "images/newImage.jpg";	
$("#photo").attr({
	"src": newPhoto.src,
	"width": newPhoto.width,
	"height": newPhoto.height
});	
	
Например можно запрограммировать смену картинки при наведении на нее указателя мыши
Этот эффект часто применяется при содании навигационнах панелей 	
	
	
						Смена изображения с помощью jQuery
Существует еще один способ смены изображения,который не подразумевает изменения атрибута
src или отдельного изменения других атрибутов изображения.
Простой способ замены одного изображения другим заключается в замене элемента img 
исходной картинки новым элементом img с помощью метода jQuery в replaceWith()						
						
К примеру на нашей странице есть такое изображение: 

<img src="sad.png" alt="Sad Face" height="50" width="50" id="swap">

Мы можем заменить его другим элементов img так:

$("#swap").replaceWith("<img src='happy.png' alt='Радостное лицо' height='100' width='150' id='swap'");					
						
						
Метод replaceWith() заменяет выбранный в данным моммент элемент любым HTML-кодом,которым мы ему предаем
С помощью этого метода можно устанавливать различные атрибуты src,alt,width,height в строке,
которую мы предоставляем методу replaceWith(),например: 						
$("#swap").replaceWith("<img src='happy.png' alt='Радостное лицо' height='100' width='150' id='swap'");					
Это как правило,проще чем менять каждый из этих атрибутов по отдельности						
						
						
						
Метод replaceWith() возвращает HTML-код,который заменяет jQuery.Другими словами,
мы можем сохранить удаляемый HTML-код.Например,если мы хотим заменить изображение,
но сохранить его HTML-код для последующего использования,мы можем сделать так:

var oldImage = $("#swap").replaceWith($("#swap").replaceWith("<img src='happy.png' alt='Радостное лицо' height='100' width='150' id='swap'"));					
						
Теперь переменная oldImage содержит HTML-код,который был заменен.В случае с
приведенным выше примером эта переменная содержит код:						
						
<img src="sad.png" alt="Sad Face" height="50" width="50" id="swap">						
						
Теперь мы можем использовать переменную oldImage снова,например,для возврата картинки на место
	
						
						Предварительная загрузка изображения 
	
Но есть одна проблема с переключением на новое изображение с помощью описанного выше способа.						
Когда мы выставляем новый путь к файлу в атрибут src,браузеру необходимо загрузить файл.
Если кто-нибудь подведет указатель мыши к изображению до того,как загрузится новая картинка,
возникнет неприятная задержка,прежде чем появится изображению.
В случае с навигационной панелью данный эффект приведет к ее замедленной работе						
						
Чтобы избежать такой задержки,необходимо предварительно загрузить изображения,
чтобы они появлялись непосредственно в ответ на действия.Например,когда посититель
наводит указатель мыши на кнопку навигационной панели,картинка должна появлятся сразу же
Предварительная загрузка изображения означает приказ браузеру загрузить картинку
до того,как мы планируем ее отобразить.Когда изображение загружено,оно сохраняется в кэше браузера,
чтобы все последующие запросы обслуживались с жесткого диска посетителя,а не загружались с сервера заново
						
var newPhoto = new Image();//создаем объект рисунка
newPhoto.src = "images/newImage.jpg";//инициируем загрузку рисунка
//ЭТО ПРЕДВАРИТЕЛЬНАЯ ЗАГРУЗКА ИЗОБРАЖЕНИЯ

Предварительная загрузка заключается в том,что мы вополняем ее до того,как нам
необходимо будет заменить текущее изображение.Один из способов предварительной
загрузки - это создание в начале сценария массива,содержащего пути ко всем рисункам,
которые мы хотим предварительно загрузить,а затем - проработка этих путей в цикле с 
созданием для каждого из них нового обьекта-изображения:
	
	var preloadImages = ["images/roll.png",
						"images/flower.png",
						"images/cat.jpg"];
	
	for (var i = 0; i < preloadImages.length; i++) {
		new Image().src = preloadImages[i];//Создает новый обьект
	}
	
	
Можно использовать jQuery чтобы обеспечить этот же эффект только без функции new Image()
	
	var preloadImages = ["images/roll.png",
						"images/flower.png",
						"images/cat.jpg"];
	
	for (var i = 0; i < preloadImages.length; i++) {
		$("img").attr("src" ,preloadImages[i]);
	}
	
	
							Сменяемые изображения
							
Например на странице есть картинка,и при наведении на него должна появится новая картинка:

$(document).ready(function(){
	var newPhoto = new Image();//Это какаето функция специально для предварительной загрузки картинки,если поменять название она работать не будет
	newPhoto.src = "images/newImage.jpg";
	$("#photo").mouseover(function(){
		$(this).attr("src", newPhoto.src);
	});
});	
	
/*
var newPhoto = new Image();
newPhoto.src = "images/newImage.jpg";
		предварительная загрузка изображения
*/	
	
Теперь сделаем так что при отводе мышки у нас вернулось изображение:

$(document).ready(function(){
	var newPhoto = new Image();
	newPhoto.src = "images/newImage.jpg";
	var oldSrc = $("#photo").attr("src");
	$("#photo").hover(function(){
		$(this).attr("src", newPhoto.src);
	},
	function(){
		$(this).attr("src", oldSrc);
	});
});		
	
//oldSrc - это переменная,для отслеживания исходного атрибута src - пути к файлу,появляющемуся при загрузке странице	
//	var newPhoto = new Image(); --для предварительной загрузки нужно создать обьект изображения	
	
	
Один из способов предварительной загрузки это создать массив с изображениями(выше пример),	
Но есть более эффективный(и менее тредоемкий)метод предварительной загрузки изображений.
Мы лишь должны убедится,что сохранили сменяемое изображение там же,где и исходное изображение,
и назвали его похожим именем.С помощью регулярных выражений.К примеру у нас картинки  с именем
blue.jpg сменяются на blur_h.jpg именно это делает строка вроде 	var imgExt = /(\.\w{3,4}$)/;
В сущности данное выражение находит точку,за которой следует три или четыре символа в конце строки
	
/*
	полная версия
	$(document).ready(function() {
	$("#gallery img").each(function(){
		var imgFile = $(this).attr("src");
		var preloadImage = new Image();
		var imgExt = /(\.\w{3,4}$)/;
		preloadImage.src = imgFile.replace(imgExt, "_h$1");
	});//end of each
}); // end ready

	Метод replace() заменяет текст,окончание файла будет измененноо на _h1 c blur.jpg на blur_h.jpg
*/	
	
	
Если мы не передадим функции события никаких аргументов то библиотека jQUERY просто запустит  к примеру click() запустит просто шелчок

									
									Открытие ссылок в новом окне
HTML давно предложил метод с использованием атрибута target="_blank".
С помощью этого атрибута браузер откроет ссылку в новом окне.Но это нужно делать вручную,что очень долго
target="_blank" - не подходит только для HTML 4.01 и XHTML 1.0 но подойдет для любых
другиз типов документов,включая HTML5.И пройдет валидацию,если добавить target="_blank" в JavaScript
валидатор проверит только код в файле веб-странице,а не тот HTML который мы добавим в JAVASCRIPT
И любому браузеру понятен target="_blank"
		
$("a").attr("target","_blank");	//Добавит ко всем ссылкам,открытие в новом окне
	
Если мы собираемся использовать безопасные веб-адреса,начинающиеся с https:// нам следует использовать код:

$("a[href^='http://'], a[href^='https://']").attr("target", "_blank");

Если на нашем сайте используются абсолютные пути то нам нужен еще один шаг.Например,если адрес
нашего сайте  www.your_site.com и мы ссылаемся на другие страницы или файлы следующим образом:
http://www.your_site.com/a_page.html , 
то предыдущий код открывает в новом окне и такие ссылки.Если мы не хотим открывать в новом
окне каждую страницу нашего сайта,то нам нужен такой код:

var myURL = location.protocol + '//' + location.hostname;
$("a[href^='http://'], a[href^='https://']").not("[href^='"+myURL+"']").attr("target", "_blank");
	
Данный код сначала определяет URL-адрес нашего сайта и присваивает данный адрес переменной - myURL.
URL-адрес сайта требует небольщой помощи со стороны обьекта браузера window.Браузеру 
известен протокол для доступа к URL - http:// (для безопасных сайтов - https://).
Эта информация  сохраняется в свойстве  обьекта protocol.Подобным образом,если сайт называется,
например www.sawmac.com ,то это название сохраняется в свойстве hostname.Так JavaScript-код
location.protocol + '//' + location.hostname генерирует строку,которая выглядит так:
http://www.sawmac.com 
Конечно в данном случае имя хоста изменяется в зависимости от того,где расположенна страница с данным
кодом JavaScript.Например,если мы поместите код на страницу,находящуюся на  http://www.your_site.com
и кто-нибудь просмотрит ее с этого сайта,значением location.hostname будет www.your_site.com	
//Другими словами location.protocol - находит (http:// или https://),а location.hostname - находит www.sawmac.com и в сумме получается http^//www.sawmac.com	

---------------------------------------------------------------------------------------------
Функция .not() --полезна при исключении определенныхх элементов из выборки jQUERY
--------------------------------------------------------------------------------------------


									Cоздание новых окон
Браузеры позволяют открывать новые окна и настраивать их,например,регулировать высоту,ширину,
размещение на экране и даже отображение полос прокрутки,меню или адресной строки.
Для этого используется метод open() ,имеющий следующую структуру:

open(URL, name, properties)

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
Метод open() --- принимает три аргумента. Первый - URL-адрес страницы,котороя должна появится
в откывшемся окне,то же значение следует использовать для атрибута href ссылок
(например, http://google.com , /pages/map.html или ../../portfolio.html).
Второй аргумент - имя окна,оно может быть любым,на наше усмотрение.
В качестве третьего параметра мы можем передать методу строку,в которой 
содержатся настройки для нового окна (например,его высота и ширина)
Дополнительно при открытии нового окна обычно создается переменная для хранения ссылки на него.
Например,если мы хотим открыть домашнюю страницу сервиса Google в новом окне площадью
200 квадратных пикселов,напишем код:

var newWin = open("http://www.google.com/", "theWin", "height=200 width=200");

Данный код открывает новое окно и сохраняет ссылку на него в переменной newWin.
/*
	Имя которое мы присваиваем новому окну (в нашем случае hteWin),делает не так много.
	Однако после присвоения окну имени,если мы попытаемся открыть новое окно,используя то же имя,
	то мы не не получим нового окна.Вместо этого,веб-страница, запрошенная посредством метода
	open(), загрузится в созданном ранее окне,которому присвоено данное имя	
*/
/*
	Всплывающие окна завоевали плохуя репутаци,и большенство браузеров снабжены возможностью блокировки
	всплывающий окон,так что,даже если мы добавили для открытия нового окна браузер не позволит ему появится
	Посетитель либо увидит сообщение о том что всплывающее окно заблокированно,либо не узнает об это вообще
	На деле многие браузеры не позволяют открывать новое окно в ответ на большинство событий вроде 
	передвижения указателя мыши или нажатия клавиш.Единственный надежный способ  применять команды javascript 
	для открытия окон состоит в запуске действия после щелчка или отправки форм.(событие click)
*/
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
									Свойства окна(3й параметр метода open())
Окна браузера включают множество различных компонентов: полосы прокрутки,
маркеры масштабирования,панели инструментов.....Кроме того,они имеют определенную ширину,
высоту и положение на экране.Большую часть этих свойств можно определить при создании нового 
окна с помощью строки,котороя содержит разделенный запятыми список свойств и их значений,
передаваемой в качестве третьего аргумента метода open().Например,для установки ширины и 
высоты нового окна ,а также отображения адресной строки напишим следующий код:

var winProps = "width=400, height=300,location=yes";
var newWin = open("about.html", "aWin", winProps);


/*
	Cовокупность свойств окна браузер(полосы прокрутки,панели инструментов и угловые маркеры масштабирования)
	называется "хромом".Каждый браузер имеет свою собственную версию этих свойств,и 
	веб-разработчики мало что могут сделать в смысле контроля над их работой и внешним видом.
	Тем не менее при создании нового окна с помощью языка JavaScript мы можем включать и
	отключать некоторые из данных характеристик 	
*/

При настройке свойств,определяющих размеры или положение окна мы пользуемся значениями 
в пикселях,тогда как другие свойства регулируются логическими  значениями yes(включить свойство) 
или no(отключить свойство).Если для такого свойства логическое значение не задано,то 
браузер отключит его по умолчанию(например,если мы не задали свойство location, то браузер
то браузер скрывает адресную строку,которая обычно появляется в верхней части окна)
Только свойства height,width,left,top,toolbar работают одинаково во всех браузерах.
Как указанно в следующем списке некоторые браузеры полностью игнорируют некоторые из этих
свойств,так что если мы создаем всплывающие окна с помощью JAVASCRIPT нужно обязательно их протестировать во всех браузерах

-------------------------------------------------------------------------------------------
height --- задает высоту окна в пикселях.Мы не можем устанавливать иные единицы измерения,
кроме пикселов.Если значение не задано,браузер исходит из высоты текущего окна
-------------------------------------------------------------------------------------------

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
width --- указывает ширину окна.Здесь также допустимы только значения в пикселях,а если
значение не задано ,то браузер исходит их ширины текущего окна
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
/*
	height и width НУЖНО УКАЗЫВАТЬ ВМЕСТЕ,А ТО НЕ БУДЕТ РАБОТАТЬ НИ ТО НИ ДРУГОЕ
*/
-------------------------------------------------------------------------------------------
left --- задает позицию в пикселах от левого края монитора
-------------------------------------------------------------------------------------------

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
top --- задает позицию в пикселях от верхнего края монитора 	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	
	
-------------------------------------------------------------------------------------------
scrollbars --- задает полосы прокрутки,которые находятся в правой и нижней частях окна браузера
если размер страницы превышает размер окна.Чтобы скрыть полосы прокрутки,установите для этого
свойства значение no.Мы не можем выбирать,какую из полос скрыть(либо отображены,либо обе скрыты),
а некоторые браузеры,например,Chrome и Safari не позволяют скрыть полосы прокрутки.	
-------------------------------------------------------------------------------------------	
	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
status --- контролирует отображение строки состояния в нижней части окна.Браузеры 
Firefox и Internet Explorer обычно не позволяют скрывать строку состояния,так что 
в этих браузерах она видна всегда
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	
	
-------------------------------------------------------------------------------------------
toolbar --- определяет видимость панели инструментов,содержащей	кнопки навигации,вкладки
и другие элементы,доступные в данном браузере.В Safari настройки панели инструментов и 
адресной строки одинаковы:включение любого из параметров активирует и панель инструментов и адресную строку 
-------------------------------------------------------------------------------------------	
	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
location --- определяет отображение поля навигации,которое также называется адресной строкой.
Это поле содержит URL-адреса веб-страниц и дает возможность перехода к другой странице 
путем ввода нового адреса.Браузеры Opera,Internet Explorer,Firefox не позволяют скрывать 
адресную строку.Это свойство предотвращает неподобающие использование язка JavaScript,
например,для открытия нового окна и перехода на другой сайт,похожий на тот,который мы только
чир покинули.В браузере Safari включение этого свойства активизирует панель инструментов в поле навигации
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	
	
-------------------------------------------------------------------------------------------
menubar --- Относится к браузерам,имеющим меню в верхней части окна,(например,Файл,Правка...)
Это свойство применимо только к браузерам,работающим в среде Windows.В операционной системе
OS X меню расположено в верхней части экрана,а не в индивидуальном окне.Данное свойство
не применимо к браузеру Internet Explorer 7 и более поздним версиям,которые не содержат меню	
-------------------------------------------------------------------------------------------	
	
/*
	Все бы ничего но я прочитал что большая часть не работает в Chrome,Firefox,Safari,Internet Explorer
*/	

	
								Использование ссылки на окно
Открыть новое окно мы можем использовать ссылку на него для контроля над ним.Например мы открываем новое окно:

var newWin = open("products.html", "theWin", "width=300, height=300");

Мы можем применить к этой переменной любой из методов браузера для контроля над ним.
Например если мы хотим его закрыть:

newWin.close();

Браузеры подерживают различные методы для обьекта окна,среди них можно выделить наиболее часто используемые:

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
close() --- закрывает указанное окно.Например,команда close() закрывает текущее окно.
Однако данный метод можно применить и к ссылке на окно: например newWin.close().Мы можем
назначить выполнение этой инструкции любому событию,например,такому,как щелчек по кнопке,говорящей "Закрой это окно"
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
	

/*
	Если мы создали окно например newWin что выше,и хотим закрыть ее,то мы можем это сделать толькл
	с той страницы с которой это окно открылост newWin.close();Тоисть если разместить кнопку "закрыть",то она сработает только на странице с которой открылось это окно,а не в открытом окне
*/	
	
	
-------------------------------------------------------------------------------------------
blur() --- выводит окно "из фокуса".Это означает,что окно перемещается на задний план под 
все открытые окна.Это способ скрыть открытое окно,его используют специалисты по веб-рекламе,
чтобы создавать рекламные обьявления типа "pop under" - окна,скрытые под текущими,таким образом,
что закрыв все окна,посетитель страницы обнаружит надоедливую рекламу	
-------------------------------------------------------------------------------------------	
	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
focus() --- противоположен методу blur() ,помещает окно поверх всех других окон 	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	
	
-------------------------------------------------------------------------------------------
moveBy() --- позволяет перемещать окно на заданное число пикселов вправо и вниз.Мы должны
передать методу два аргумента.Первый указывает число пикселов,на которое окно следует 
передвинуть вправо,а второй - число пикселов,на которое окно следует передвинуть вниз.
Например, кот newWin.moveBy(200,300); перемещает окно,на которое ссылается переменная newWin,
на 200 пикселов вправо и на 300 пикселов вниз.Мы также можем использовать отрицательные 
значения,таким образом,для передвижения окна на 100 пикселов вверх и на 300 пикслов влево,
мы можем использовать данный код: newWin.moveBy(-100,-300);	
-------------------------------------------------------------------------------------------	
	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
moveTo() --- позволяет перемещать окно в заданное место на экране.Эта команда эквивалентна 
использованию свойств left и top при открытии нового окна.Например,чтобы поместить окно строгого
в левом верхнем углу монитора,напишите следующий код: moveTo(0,0);
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	
	
-------------------------------------------------------------------------------------------
resizeBy() --- изменяет ширину и высоту окна.Первый из двух аргументов определяет,на сколько
пикселов должна увеличится ширина окна,а второй - на сколько пикселов должна стать больше высота.
Например,код resizeBy(100,200); делает текущее окно на 100 пикселов выше и на 200 пикселов шире.
Для уменьшения размеров окна используйте отрицательные значения
-------------------------------------------------------------------------------------------	

/*
	ОКОНЧАНИЕ By() - ГОВОРИТ О ТОМ НА СКОЛЬКО ДОЛЖНО УВЕЛИЧИТСЯ К ПРИМЕРУ 
	ОКОНЧАНИЕ To() - ИЗМЕНЯЕТ РАЗМЕРЫ 
*/
	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
resizeTo() --- изменяет размеры окна на заданные.Например, код resizeTo(200,400); задает
для текущего окна ширину 200 пикселов и высоту 400 пикселов	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	
	
------------------------------------------------------------------------------------------
scrollBy() --- прокручивает документ внутри окна на заданное количество пикселов вправо и вниз.
Например, код scrollBy(100,200); прокручивает документ вниз на 200 пикселов,и 
вправо на 100 пикселов.При невозможности прокрутки документа(когда он целеком помещается
внутри окна или достигнут его конец)функция недоступна	
------------------------------------------------------------------------------------------	
	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
scrollTo() --- прокручивает документ окна на заданную позицию по отношению к левому 
и верхнему краям.Например,код scrollTo(100,200); прокручивает текущий документ на 
200 пикселов от верхнего края окна и на 100 пикселов от левого.При невозможности прокрутки
документа(когда он целиком помещается внутри окна или достигнут его конец) функция недоступна
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	
	
//я пробывал половина методов не работает особенно прокрутки
/*
	Плагин JAVASCRIPT ScrollTo обеспечивает простой способ контроля над прокручиванием
	документа с помощью языка JavaScript
	http://xiper.net/collect/js-plugins/effects/scrollto  --- ссылочка как использовать
	https://github.com/flesler/jquery.scrollTo/blob/master/jquery.scrollTo.min.js  --ссылка где скопировать код плагина
*/
	
	
	
								Знакомство с плагинами jQUERY
							На что нужно обратить внимание!!!
1.Перед загрузкой классного плагина,нужно убедится что вместе с классным плагином мы 
не скачиваем десятки других плагинов.Это будет снижать скорость загрузки нашего сайта и 
может привести к замедленной работе браузера посетителя из-за того что браузерам прийдется
обрабатывать несколько программ(плагинов) javascript.Таким образом,нам следует ограничить
количество плагинов только теми которые нам действительности нужны	

2.Кроме того,при добавлении плагина мы становимся зависимы от его разработчика.Если при
выпуске плагина в нем содержалась необнаруженная ошибка, то нам или разработчику 
придется ее исправить, иначе нам потребуется удалить плагин с нашего компьютера
	
3.Нам нужно выбирать плагины имеющие хороший послужной список.Если плагин был размещен на
веб-сайте только сегодня и это версия 0.0.0.1,лучше его не использовать(или по край немере дважды подумать прежде чем его использовать)
Мы можем определить "зрелость" плагина по номеру версии.То есть версия 0.0.1 означает что
плагин является совершенно новым,в то время как версия 4.1.10 говорит о том что он пережил несколько доработок
 	
4.Также нужно смотреть на дату выхода плагина.Важно знать дату последнего обновления плагина.
Плагин,имеющий длинную историю обновления,исправлений и добавления новых функций,вероятно
прослужит еще длительное время и продолжит обновлятся при возникновении проблем.
Если плагин обновлялся 4 года назад держитесь от него подальше,поскольку он может 
не работать в последней версии jQUERY,и конечно он не был протестирован в новейших браузерах
 	
/*
	на сайте plugins.jquery.com ,каждый плагин имеет свою собственую страницу,на которой показана
	история его развития,мы можем увидить как дуту выхода...,так и сколько людей следят
	за ним.Чем больше у плагина наблюдателей тем больше его популярность.
*/

									
								Основы работы с плагинами jQUERY
1.Загрузить файлы(это как правило файл .js, файл .css и любые изображения,используемые в плагине)
2.Поместить необходимые файлы в папку нашего сайта.К примеру мы скачали плагин super-plagin
Лушче всего создать папку super-plagin и поместить все файлы(.js,.css и картинки),в эту папку,
а затем переместить данную папку в другую папку plugins, так будет красиво чисто и понятно,а главное надежно
3.Прикрепите CSS-файл плагина к веб-странице.Этот код помещается в разделе заголовка 
веб-страницы непосредственно под ссылкой на другие таблицы стилей,которые мы используем:

<link href="css/site.css" rel="stylesheet">
<link href="plugins/super_plagin/super-plagin.css" rel="stylesheet">					

4.Создайте ссылку на JavaScript-файл плагина.Плагины jQUERY зависят от этой библиотеки,
так что сначала нам необходимо создать ссылку на файл jQUERY,а затем - на файлы плагинов:

<script src="js/jquery.min.js"></script>
<script src="plugins/super_plugin/jquery.super-plagin.min.js"></script>

5.Измените HTML-код нашей страницы.Каждый плагин имеет свои собственные правила использования.
В большенстве случаем для того чтобы плагин заработал,мы должны добратся до HTML-кода
страницы и добавить некоторое содержимое.Это может быть простое добавление нескольких
классов к уже существующим элементам.Эти классы служат своеобразными маркерами плагина,
определяющими фрагменты HTML-кода, которые плагин должен выбрать и изменить.
В других случаях нам может потребоваться добавить специально  структурированный HTML-код.
Например, виджет Accordion,предусмотренный в jQUERY-UI,требует чтобы мы создали осособую 
структуру: HTML-элемент,который выступает в качестве контейнера для аркадеона,а также 
ряд HTML-элементов h,закоторыми следует элементы div:

<div id="accordion">
	<h3>Первый заголовок</h3>
	<div>Первая панель с содержимым</div>
	<h3>Второй заголовок</h3>
	<div>Вторая панель с содержимым</div>
</div>

Плагин будет изменять HTML-код: отображать его в виде панели-акардиона с областями,которые
посетитель может скрывать и отображать;создать набор движещих слайдеров или отображать всплывающие подсказки

6.Вызов функции плагина.Точный метод вырируется от плагина к плагину.Тем не менее многие
плагины работают аналогичным образом:
создают выборку jQUERY, а затем вызывают функцию плагина.Выборка jQuery часто представляет 
собой селектор  идентификатора или класса,который мы добавили на свою HTML-страницу.
Например,в случае c jQuery-UI Accordion все сводится к выбору HTML-элемента,который
содержит элементы акордеона,и к вызову функции accordion():

$("#accordion").accordion();

Да часто можно обойтись одной строкой кода.Большенство плагинов также позволяют изменить
принцип своей работы путем передачи дополнительных инструкций,часто в форме литерала обьекта javascript.
К примеру настроить виджет Datepicker.Например чтобы отобразить бок о бок три календаря
на разные месяцы,а также панель под ними,содержащую кнопку длч выбора текущей даты:

$("#date").datepicker({
	numberOfMonths: 3,
	showButtonPanel: true
});

Каждый плагин имеет свои особенности,однако большинство из них подчиняется общей схеме,описанной выше.


								Работа с плагином SmartMenuw(www.smartmenus.org)
1.CSS							
Главный CSS-файл под название sm-core.css отвечает за размещение навигационных кнопок.
Делает основную работу по размещению элементов,необходимой для размещения кнопок и выпадающих меню

Затем мы можем создать собственные стили для настройки внешнего вида или использовать
одну из предложеных тем.Каждая тема поставляется в собственом CSS-файле:
sm-simple.css,sm-clean.css,sm-blue.css 

2.JavaScript
Основная концепция использования языка JavaScript для управления видом меню проста.
Указатель мыши наводится на элемент списка,и если тот имеет вложеный список(раскрывающееся меню),
то этот список отображается;затем указатель мыши смещается со списка и все вложеные списки скрываются
Существует ряд тонкостей усложняющих эту основную идею.Раскрывающиеся меню исчезает тотчас,
как курсор оказывается вне родительского списка,требуют точной техники управления мишью
Если список имеет несколько вложеных списков то легко сдвинуть мишь с этого списка и все прийдется начинать сначала
Для решения этой проблемы в большенсве случаев добавляется таймер с целью отсрочить исчезновение меню 

 
										Теперь на практике
1)Подключаем файл: <link href="smartmenus/sm-core-css.css" rel="stylesheet">
Это основной файл он должен быть всегда,дальше тему на усмотрение
<link href="smartmenus/sm-simple.css" rel="stylesheet">

2.В начале навигационной панели добавить класс 										

 <ul class="sm sm-simple">
	//какой-то список
 </ul>
// sm -необходимо для всех меню,оно позволяет творить все волшебство; sm-simple -это имя темы 

3.Загрузить JavaScript(после основного файсла с jQuery) <script src="smartmenus/jquery.smartmenus.min.js"></script>
4.В отдельном js файле или вставить скрипт прямо в html добавить:

$(document).ready(function() {
	$(".sm").smartmenus();
});  

5.Можно вносить изменения подобным образом:
$(document).ready(function() {
	$(".sm").smartmenus({
		showFunction: function($ul, complete) {
			$ul.slideDown(500,complete);
		}
	});//end of smartmenus
}); // end ready

В данном случае ключом является showFunction.Плагин имеет множество заранее запрограмированных
параметров,один из них  showFunction.Если это имя передается плагину,то функция,передающаяся
в качестве значения,используется для анимации внешнего вида подменю.

6.И чтобы при отводе мишки было событие:

$(document).ready(function() {
	$(".sm").smartmenus({
		showFunction: function($ul, complete) {
			$ul.slideDown(500,complete);
		},
		hideFunction: function($ul,complete) {
			$ul.slideUp(2000,complete);
		}
	});//end of smartmenus
}); // end ready

Для того чтобы отредактировать стили можно скипировать любую тему которую мы применяем,
поменять ей имя и там жуе вносить изменения.Например изменим стили для темы sm-simple.css
поменяем имя на sm-simplesgggg.css

<link href="smartmenus/sm-simplesgggg.css" rel="stylesheet">

и вставим новый адрес,и все будет работать просто теперь вносим изменения в этот файл




										Улучшение веб-форм
Таблица селекторов для работы с конкретными типами элементов формы:

:input | пример $(":input") --- Выделяет все элементы типа input,textarea,select,button, то есть все элементы форм
:text | пример $(":text") --- Выбирает все текстовые поля 
:password | пример $(":password") --- Выбирает все поля для ввода пароля
:radio | пример $(":radio") --- Выбирает все переключатели 
:checkbox | пример $(":checkbox") --- Выбирает все флажки
:submit | пример $(":submit") --- Выбирает все кнопки подтверждения(отправки)
:image | пример $(":image") --- Выбирает все кнопки рисунки
:reset | пример $(":reset") --- Выбирает все кнопки сброса
:button | пример $(":button") --- Выбирает все кнопки 
:file | пример $(":file") --- Выбирает все поля файла(применяется для выгрузки файлов на сайт)
:hidden | пример $(":hidden") --- Выбирает все скрытые элементы  

Мы можем комбинировать селекторы формы с другими селекторами.Например, у нас на странице
есть две формы  и мы хотим выбрать текстовы поля только у одной из них:

$("#signup :text")

Кроме того можно использовать фильтры,которые отбирают элементы форма,соответствующие 
определенному состоянию.Например,у нас есть группа переключателей у которых одно имя 
name ="shipping"  и нужно выбрать какой из них был отмечен:

var checkedValue = $("input[name='shipping']:checked").val(); 

Селектор $("input[name='shipping']") - выбирает все элементы с именем shipping, но после
добавления части  :checked - только отмеченые документы.


:selected - выбирает все отмеченные элементы option внутри списка или меню,позволяя узнать
какой выбор сделал посетитель(элемент select).Например у нас есть элемент select с 
идентификатором region в котором перечислены все области Украины.Для выяснения 
какую область выбрал наш посетитель напишем:

var selectedRegion = $("#region :selected").val();   

//Здесь есть пробел,этот код сначала он находит элемент с нужным id, а затем внутри него ищет все выбранные элементы 

------------------------------------------------------------------------------------------
Функция val() --- возвращает значение,хранящееся в отмеченом элементе,например Почта
Функция val() может как задавать так и считывать значения элементов формы.Если мы вызываем
ее без  передачи аргументов, она будет считывать значения.При передачи функции значения она
введет его в элемент формы.Например у нас есть поле для ввода электронного адреса клиента
с id="email".Его значение можно выяснить,введя следующий код:

var fieldValue = $("#email").val();  

Задать значение элементу формы можно просто передав это значение  функции val().Например,
у нас есть форма для заказа товаров и мы хотим автоматически расчитать общую стоимость 
заказа,исходя из количество товаров заявленого клиентом:
 
var unitCost = 9.95;//хранит цену за единицу товара
var amount = $("#quantity").val();//Получаем значение(какое количество товаров ввел посетитель к примеру 2)
var total = amount * unitCost;
total = total.toFixed(2);//Форматирует результат,включая два знака после запятой
$("#total").val(total);//Задаем значения,и выводим конечный результат 
------------------------------------------------------------------------------------------

								Проверка активации кнопок и флажков
Для определения статуса конкретного переключателя или флажка 

Для установки флажка при загрузки веб-страницы следует добавить атрибут checked:

<input type="checkbox" class="input" checked>//Теперь будет при загрузке стоять галочка

if ($(".bip").prop("checked")) {
		alert("YES it's checked");//Флажок установлен
	}else {
		alert("NO, it isn't checked");//Флажок сброшен
};

Функция prop() позволяет проверяет установлен ли атрибут checked для переключателя


									Подтверждение
Когда посетитель наэжимает кнопку Подтвердить(submit) или Enter происходит событие submit
Мы можем выполнить сценарий во время подтверждения формы.Мы можем проверить правильно ли
заполнены жлементы формы или нет.Когда форма подтверждена, JavaScript проверяет ее элементы
при обнаружении проблем останавливает передачу и сообщает посетителю причину отказа.
Если все заполнено правильно то форма передается как обычно.
Для выполнения функции при наступлении события подтвержения формы сначала выберите форму,
затем применим jQUERY-функцию submit(),чтобы добавить наш сценарий.Скажем нам нужно убедится
что при передаче формы поле с именем не должно быть пустым.Если поле пустое мы должны дать
знать об этом посетителю и остановить процесс передачи формы.  								

<form class="form"> 
		<div>
		<label>Name:</label>
		<input type="text" class="text">
		</div>
		<div>
		<label>What kind of name:</label>
		<input type="radio" name="floor" value="Good">Good
		<input type="radio" name="floor" value="Bad">Bad
		</div>
		<div>
			<label>TextArea</label>
			<input type="textarea">
		</div>
		<input type="submit" value="submit">
	</form>


$(document).ready(function(){
	
 $(".form").submit(function(){//Присоединяет функцию к событиям формы submit
	if($(".text").val() == ""){//если пустая строка
		alert("Введите имя в поле Name");//если пустая то выводит сообщение
		return false;//Очень важная строка,останавливает процес передачи формы,если пропустить этот шаг,то форма будет передана без имени пользователя
	}
 });
 
});

Остановить отправку формы можно также с помощью preventDefault()
$(document).ready(function(evt){	
 $(".form").submit(function(){
	if($(".text").val() == ""){
		alert("Введите имя в поле Name");
		evt.preventDefault();
	}
 }); 
});


Событие submit применяет только к формам,так что сначала мы должны выбрать форму,а затем
присоединить к ней функцию  события submit.


									Активное состояние
Когда текстовый курсор находится в поле(либо после щелчка по элементу формы кнопкой мыши,
либо при переходе на него с помощью TAB),элемент формы переходит в активное состояние,
называемое focus.Фокус представляет собой событие,запускаемое браузером и указывающее 
на то,что текстовый курсор находится в конкретном поле или выделен определенный элемент
формы.Некоторые дизайнеры используют его для удаления текста который присуцтвует в поле:

<input type="text" class="text" value="Пожалуйста введите имя">									

Этот код создает текст "Пожалуйста введите имя",позволяя давать посетителю указания по
заполнению формы.Посетитель не должен сам стирать ненужный текст мы это делаем автоматически
при активации поля:

$(".text").focus(function(){//Выбирает поле
	var  field = $(this);
	if(field.val() == field.prop("defaultValue")){
		field.val("");	
	};
});

field.val(""); - стирает содержимое поля и задает новое значени пустую строку.Однако,нам
не нужно удалять содержимое всякий когда он оказывается в фокусе.Например,пользователь
ввел свое имя.Если потом текстовый курсор покинет данное поле,а затем вернется,то
введенное имя не должно исчезнуть.Тогда и работает if(field.val() == field.prop("defaultValue"))
Текстовые поля имеют атрибут defaulValue,представляющий текст,содержащийся в поле при
первоначальной загрузки страницы.Даже если мы стерли этот текст,браузер будет его помнить
Управляющая инструкция проверяет соответствует ли текущий текст поля(field.val()) тому
который был первоначально field.prop("defaultValue").Если текст совпадает то интерпритатор
JavaScript стирает текст в поле.Другими словами при загрузке в текстовом поле был текст
"Пожалуйста введите имя", и инструкция спрашивает,если совпадает то стираем,после изменения
текста при клике на поле,инструкция еще раз спрашивает если не совпадает то просто пропускает.

//есть placeholder но он не работает в Internet Explorer


									Неактивное состояние
Когда мы покидаем элемент формы или щелкаем кнопкой мыши за его пределами,браузер 
запускает событие blur,которое обычно применяется к полям text и textarea для выполнения
сценария проверки формы,когда кто-то покидает заполненное текстовое поле.Например,у нас
есть длинная форма с большим количеством вопросов,многие из которых требуют определенных
типов ответов(электронные адреса,телефоны,почтовые индексы...)Допустим,посетитель не смог
заполнить все элементы формы  правильно,но нажал на кнопку отправки формы и получил длиный
список ошибок,указывающих на неправильное заполнение формы.Вместо того чтобы сваливать
на него все сразу,мы можем проверять значение элементов формы паралельно их заполнению.
В таком случае при первой же ошибке посетитель сразу получит предупреждение и сможет ее исправить.

Предположим,у нас есть поле для сбора информации о количестве товаров,нужных клиенту:

<input type="text" class="text">								
									

Мы хотим убедится что поле содержит только числа(11,2, но не одинадцать или два):									
$(".text").blur(function(){
	var  get = $(this).val();
	if(isNaN(get)){
		alert("Ведите число");
	}
});									
									
Если посетитель ввел буквы то после того как он покинет поле выведется сообщение.


При наличии формы с множеством элементов формы,принимающих числовые значения,мы можем
назначить каждому из этих элементов одно и то же имя класса,например "numOnly",
и проверить каждое из них с помощью следующего кода:

$(".numOnly").blur(function(){
	var get = $(this).val();
	if(isNaN(get)){
		alert("Ведите число");
	}
});	

//Этот метод позволяет с помощью нескольких строк кода проверить числовой элемент каждого элемента


								Щелчек мыши
Событие click() происходит при щелчке кнопкой мыши по элементу формы.Оно особенно полезно
для переключателей и флажков,поскольку мы можем добавлять функции,изменяющие форму на базе
значений,выбираемых посетителем.Например у нас есть форма заказа,представляющая отдельные 
элементы формы для информации по платежу и доставке.Для предотвращения повторного ввода
одних и тех же данных в случаях,когда информация совпадает,следует установить флажок
"Аналогично информации по платежу",что скрывает информацию по доставке и делает форму 
удобнее для чтения.
Событие click() применимо и к текстовым полям но не так как focus.Focus работает и при
TAB а click только при помощи мышки 

			
										Смена
Событие change раскрывающегося списка формы позволяет делать интересные вещи,когда 
пользователь выбирает пункт в раскрывающемся списке.Выбор пункта из верхнего раскрывающегося
списка динамически изменяет список пунктов,представленных во втором раскрывающемся списке.
Выбрав товар из верхнего списка,во втором мы получим варианты доступных цветов для этого товара
			
			
<select  class="select" name="subject">	
	<option value="review">Отзыв</option>	
	<option value="suggestion" selected>Предложение</option>	
	<option value="problems">Жалоба</option>
</select>			
			
			
$(".select").change(function(){
	alert("Смена");
});		
			
//При любой смене сработает вызов

$(".select").change(function(){
	if($(this).val() == "problems") {
		alert("Смена");
	}	
});//А в данном случает вызов сработает только когда мы выберем Жалобу из списка 			
			
			
								Усовершенствование форм
Всегда нужно старатся упрощать формы.Например скрыть элементы которые пока не нужны...

1.Фокусировка на первом элементе формы.
Зачем заставлять посетителя перемещать указатель мыши на нужное место и только потом
вводить текст.Поэтому для удобства мы сразу перемещаем текстовый курсор в нужное место
 
$(".text").focus();//Сделать это проще простого с помощью focus			
			
Однако мы можем использовать универсальный сценарий который не требует идентификатора, и
который всегда будет вводить в фокус первое текстовое поле формы 
	
$(":text:first").focus();//Выбирает первое текстовое поле на странице 
	
Если наша страница содержит более одной формы(например,формы:Поиск по сайту,Подпишитесь 
на рассылку новостей), то нам нужно	указать идентификатор для конкретной формы 
	
$("#signup :text:first").focus();	
	
2.Отключение/включение элементов формы 	
Например форма о страховании супруги.Но она должна появится только в том случае если я женат
Чтобы отключить элемент формы,задайте для атрибута disabled значение true.Например, для
отключение всех полей ввода формы можно использовать следующий код:

$(":input").prop("disabled", true);//Можно заменить prop на attr	
	
или например отключить при клике:

$("#single").click(function(){
	$("#spouseSSN").prop("disabled", true);
});	

Чтобы включить элемент формы мы можем написать следующий код:

$(":input").prop("disabled", false);//Нужно просто поставить false
//Нужно писать true или false как логический тип данных а не как строковой,например "true" -неправильная запись,а true - правильная
	
3.Скрытие/Отображение параметров формы
Помимо и лучшим способом будет просто скрыть не нужную форму с элементами,так как даже
если мы откючили элементы формы они видны,а так их просто не видно и появляются они только в нужный момент
Сделать это легко с помощью hide() и show() при клике.Один из способов заключить код,
который мы собираемся скрыть в элемент div,присвоить ему идентификатор,а потом скрыть его

	
						Предотвращение многократной отправки формы
Иногда бывает так что одна и та же информация отправляется несколько раз.Как этого избежать?
Из-за того что веб-серверы и Интернет могут иметь задержки от момента когда посетитель
нажал кнопку отправки до появления сообщения "Ваша информация полученна".Иногда такая
задержка достаточно долгой и посетители нажали кнопку отправки еще несколько раз,решив
что в первый раз система не сработала.Это приводит к тому что одна и та же информация
может быть отправлена несколько раз.А в случае с онлайновыми продажами это означает,что
мы несколько раз расплатились с помощью своей кредитной карты.Ксчастью язык JavaScript
предоставляет легкий способ деактивировать кнопку подтверждения,как только начался процесс
отправки.С помощью disabled мы можем сделать так,чтобы эта кнопка больше не нажималась.   
	
Исходя из того что форма имеет идентификатор formID,а кнопка передачи - идентификатор
submit, сначала добавим в форму  функцию submit(),а затем внутри функции отключим кнопку
передачи:

$("#formID").submit(function(){
	$("#submit").prop("disabled", true);
});
	
Если на странице присутствует только одна форма	то на даже не нужно использовать 
идентификаторы для элементов:

$("form").submit(function(){
	$("input[type='submit']").prop("disabled", true);
});	
	
кроме того можно изменить сообщение на кнопке передачи.Например на "Передача информации закончена"
	
$("#formID").submit(function(){
	var subButton = $(this).find(":submit");
	$("#submit").prop("disabled", true);
	subButton.val("Передача информации закончена");
});
		
//или проще с помощью attr("value", "Передача информации закончена");	
	
	
	
	
$("#creditCard label").css("color", "");//измененный цвет удаляется но сохраняется цвет по умолчанию,заданный таблицей стилей
//Возвращает цвет по умолчанию 
	
	
	
								Плагин jQuery Validation
Удобный и простой плагин для проверки форм.Расмотрим базовую схему применения плагина:
1.Загрузить саму библиотеку jQuery
2.Загрузить и присоединить плагин Validation (можно скачать по адресу jqueryvalidation.org)
Нам нужет только файл jquery.validate.min.js
3.Добавить правила проверки.Это просто инструкции указывающие сделать данный элемент формы
обязательным для заполнения,убедится что данный элемент формы содержит адрес электроной почты...
Другими словами,на этом этапе мы определяем какие элементы будут проверятся и каким образом.
4.Добавить сообщения об ошибках.Данный этап необязателен.Плагин Validation распологает 
встроеным набором сообщений об ошибках типа "Этот элемент формы обязателен для заполнения",
"Введите жопустимую дату","Введите допустимый номер"...Подобные простые сообщения вполне
уместны но тем не менее,мы можем настраивать их, чтобы сообщения предоставляли более ясные
инструкциидля заполнения каждого элемента формы,например, "Введите свое имя" или "Введите дату вашего рождения"...	
(Мы также можем управлять стилем и расположением сообщений)	
5.Применить функцию validate() к форме.
Плагин включает функцию,которая	творит все волшебство - validate().Сначала с помощью 
библиотеки jQuery выберем форму,а затем применим к выделенной форме функцию.Наример,наша
форма имеет идентификатор signup.Код HTML может выглядеть так:

	<form action="proctss.php" method="post" name="signup" id="signup">

Простейший способ провести проверку:

	$("#signup").validate();
	
------------------------------------------------------------------------------------------
Функция validate() применяет в качестве аргумента самую разную информацию,влияющую на 
работу плагина.Например, хотя мы можем определить правила проверки и сообщения об ошибках
в HTML-коде формы,мы также можем задавать правила и сообщения при вызове функции validate()
------------------------------------------------------------------------------------------
	
								Создания правил проверки
								
Простейшим способом проверки с помощью плагина Validation является присвоения элементу 
формы одного или нескольких имен класса.Плагин проверяет имена класса каждого элемента 
формы на предмет наличия условий проверки.Если они есть,к элементу формы будут применены 
соответствующие правила проверки.
	
К примеру у нас есть текстовое поле для ввода имени:

		<input name="name" type="text">
		
чтобы дать плагину понять,что данное поле обязательно для заполнения,дабавим класс required
Например,чтобы сделать текстовое поле обязательным для заполнения:

	<input name="name" type="text" class="required">
	
Плагин Validation включает методы,отвечающие наиболее распостраненным требованиям проверки:

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
required --- Элемент формы обязателен для заполнения,пометки или выбора 	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< 	

------------------------------------------------------------------------------------------
date --- Данные должны иметь формат  MM/ДД/ГГГГ.Наример ,дата 10/30/2014 считается 
корректной, а 10-30-2014 - нет
------------------------------------------------------------------------------------------	
	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
url --- Веб-адрес должен быть записан в полной форме типа http://www.shia-vet.com 
Частичный URL-адрес,например www.shia-vet.com или shia-vet.com(http://shia-vet.com)
является недействительным 	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	
	
------------------------------------------------------------------------------------------
email --- Электронный адрес должен иметь формат bob@chia-vet.com Этот класс не проверяет
действительность введенного адреса,так что даже такой адрес,как nobody@noplace.com
успешно пройдет проверку 	
------------------------------------------------------------------------------------------	
	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
number --- Данные должны быть числом типа 32 или 102.50 или даже -145.5555 
Однако ввод символов,например, $45.00 или 100,000 - недопустим  	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	
	
------------------------------------------------------------------------------------------
digits --- Данные должны быть положительными целыми числами.Числа 1,20,12333 - являются
корректными,а 10.33 или -12 - нет 
------------------------------------------------------------------------------------------	
	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
creditcard --- Должен быть введен корректный номер кредитной карты 	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	
	
Есть случаи когда нужно ввести два класса к примеру для обезательного ввода даты рождения:
	<input type="text" name="dob" class="required data">
	
	

								Добавление сообщений об ошибках
Плагин Validation распологает набором универсальных сообщений об ошибках.Например,если 
обязательный для заполнения элемент формы не содержит данных,появляется сообщение 
"Этот элемент формы является обязательным для заполнения".Если в элемент формы необходимо
ввести дату,появится сообщение "Ввердите правильную дату".Однако мы имеем возможность
модифицировать эти сообщения и создавать собственные.Простейший путь  - добавить элементу
формы атрибут title и задать текст сообщения в качестве значения атрибута.Например мы
с помощью класса required делаем элемент формы обязательным для заполнения:

	<input type="text" name="name" class="required">
	
Для форматирования текста сообщения об ошибке просто добавим атрибут title:

	<input type="text" name="name" class="required" title="Пожалуйста,введите ваше имя">

Обычно веб-дизайнеры используют атрибут title для удобства пользователя,предоставляя
конкретные инструкции,которые появляются при наведении указателя мыши на какой-либо
элемент формы или для программ позволяющих озвучивать текст на экране.Но встучае с Плагином
Validation этот атрибут служит для создания сообщений,которые мы хотим вывести на экран.
Плагин сканирует все проверяемые элементы формы в поиске атрибута title.Найдя его,плагин
использует значение атрибута в качестве текста сообщения об ошибке 

При использовании нескольких методов(классов) нужно правильно написать сообщение,
вот пример правильного сообщения:
	
<input type="text" name="name" class="required data" title="Пожалуйста,введите дату в формате 01/28/2014">
								
//Это был простой способ созданий правил и сообщений

Иногда нам может понадобится более сложный вариант.Например,мы хотим предусмотреть разные 
сообщения об ошибках в зависимости от их типа: одно - для пустого элемента,другое - для
неверного формата...С помощью стандартного метода проверки,описанного ранее,решить такую 
проблему невозможно.К стастью,плагин Validation предусматривает более расширенный метод
проверки,который позволяет применять более широкий диапазон правил проверки.Например,
расширенный метод необходим,чтобы задать минимальное количество знаков при вводе данных.
Устанавливая пароль,мы можем ввести требование его минимального размера в шесть знаков

								Расширеная проверка
Плагин Validation предоставляет еще один способ проверки формы,не требующий изменения 
HTML-кода элементов формы.Кроме того,существует большое количество дополнительных 
настроек для управления работой плагина.Они передаются путем передачи функции validate()
обьектной константы.К примеру у нас есть HTML-код:
	
	<form action="proctss.php" method="post" name="signup" id="signup">
	<div>
		<label for="name">Имя</label>
		<input type="text" name="name">
	</div>
	<div>
		<label for="email">Адрес электронной почты</label>
		<input type="text" name="email">
	</div>
	</form>
Базовая структура выглядит так:
	
	rules: {
		fieldname: "validationType"
	}
 
Обьект называется rules,и внутри него мы определяем элементы формы и типы проверки.Затем 
обьект передается функции validate() :

	$("#signup").validate({
		rules: {
			name: "required"
		}
	});//end of validate 

В данном случае элемент формы называется name,а правило указывает на его обязательное 
заполнение.Для применения применения нескольких правил к этому элементу формы мы должны
создать для него другой обьект.
/*
	name - это идентификатор обращения тоисть в HTML-коде должно быть name="name" тогда мы можем обратится name
	если будет name="email" - то мы можем обратится email: {какое-то правило}, или name="gav" -то соответсвенно будет gav: {правила} 
*/

	$("#signup").validate({
		rules: {
			name: "required",
			email: {
				required: true,//Делает поля обязательным для заполнения
				email: true//требует наличия в поле электронного адреса 
			}
		}
	});//end of validate 


/*
	email: {
				required: true,
				email: true
			}
Задают правила для поля содержащего  электронный адрес.Поле называется email
Грубо говоря эти скобки нужны если мы используем больше одного значения,	
если бы мы использовали одно значение то код выгладет так:

	email: 	required: true, 
	
а так как мы используем два значение то будут скобки:
email: {
		required: true,
		email: true
	}
*/

									Расширенные правила
------------------------------------------------------------------------------------------
minlength --- Поле должно содержать по крайней мере,определенное число знаков.Например,
правило,задающее ввод в поле  минимум шести знаков имеет следующий вид:

minlength: 6
------------------------------------------------------------------------------------------

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
maxlength --- Поле должно содержать не более определенного числа знаков.Например, правило
задающее ввод в поле не более 100 знаков записывается так:

maxlength: 100  	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< 	

------------------------------------------------------------------------------------------
rangelength --- Правило,сочетающее minlength и maxlength.Устанавливает минимальное и 
максимальное число знаков,разрешенных при вводе данных.Например,правило задающее ввод
в поле минимум шести знаков но не более ста:

rangelength: [6,100]	
------------------------------------------------------------------------------------------	
	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
min --- Поле должно содержать число равное или больше указаного числа.Например следующее
правило требует,чтобы поле содержало число,и чтобы это число было равным или больше 10

min: 10  	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	
	
------------------------------------------------------------------------------------------
max --- Задает максимальное число которое может содержать поле.Например, для гарантии 
того,что поле содержит число меньше 1000 используется следующий код:

max: 1000 	
------------------------------------------------------------------------------------------	
	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
range --- Правило,сочетающее min и max и задающее диапазон для чисел,вводимых в поле.
Например,чтобы обеспечить ввод чисел,не меньших 10 но и не больше 1000 :

range: [10,1000] 	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	
	
------------------------------------------------------------------------------------------
equalTo --- Требует,чтобы содержимое поля совпадало с содержимым другого поля.Например,
при вводе пароля посетителя часто просят повторить его.Этим проверяется правильность
ввода пароля в первый раз.Чтобы применить данный метод,мы должны сначала задать строку,
содержащую правильный селектор jQuery.Например,первое поле пароля имеет идентификатор
password.Если хотим обеспечить соответствие содержимого поля "Подтвердите пароль"
содержимому первого поля,применим код:

equalTo: "#password" 	
------------------------------------------------------------------------------------------	
	
Допустим наша форма включает два поля,одно из которых служит для ввода пароля,а второе
для его подтверждения.HTML-код для этих двух полей выгладит так:

	<input name="password" type="password" id="password">
	<input name="confirm_password" type="password" id="confirm_password">
	
Оба поля обязательны для заполнения,а пароль должен содержать от 8 до 16 символов.Наконец,
на нужно гарантировать,что поле "Подтвердите пароль" совпадает с первым полем для ввода 
пароля.Допустим,форма имеет идентификатор signup:

		$("#signup").validate({
			rules: {
				password: {
					required: true,
					rangelength: [8,16]
				},
				confirm_password: {
					equalTo: "#password"
				}
			}			
		});
	
	
	
							Расширенные сообщения об ошибках
Сообщения можно добавить с помощью атрибута title.Однако данный способ не позволяет 
создавать отдельные сообщения для каждого типа ошибки проверки.Скажем поле является 
обязательным для заполнения и должно содержать число.Нам нужно два разных сообщения для
каждого типа ошибки: "Это поле обязательно для заполнения" и "Введите число".Мы не можем
это сделать для атрибута title.Вместо этого мы должны передать функции validate() обьект
JavaScript содержащий,различные сообщения об ошибках ,которые хотим отобразить 
Процесс схож с созданием расширенных правил,базовая структура messages такова:

	Messages: {
		Fieldname: {//элемент формы которое мы проверяем
			methodType: "Сообщение об ошибке"//один из методов проверки 
		}
	}
	
/*
Плагин Validation распологает методом remote - позволяющим выполнить проверкус помощью сервера
К прмиеру посетитель вводит имя и нам нужно проверить с помощью сервера есть ли такое имя 
в базе или нет,так как два имени не могут быть одинаковыми.Предположим у нас есть поле
username,которое является обязательным для заполнения и не должно содердать имя,уже
используемое на сайте.Для создания правила можно добавить следующий код:

	username: {
		required: true,
		remote: "check_username.php"
	}
	
Удаленный метод принимает строку,содержащую путь от текущей до серверной страницы.В нашем
примере страница называется check_username.php.Когда плагин пытается проверить данные в
поле,он посылает веденное имя пользователя(username) и данные посетителя на страницу 
check_username.php ,которая определяет можно ли использовать это имя.Если да то PHP-страница
возвращает true,если же имя уже задействованно возвращается false и поле не проходит проверку
*/							
	
Чтобы совместить методы проверки для полей ввода пароля и сообщения для каждого типа 
ошибок добавим код:

	$("#signup").validate({
		rules: {
			password: {
				required: true,
				rangelength: [8,16]
			},
			confirm_password: {
				equalTo: "#password"
			}
		}//end of rules
		messages: {
			password: {
				required: "Пожалуйста введите пароль",
				rangelength: "Ваш пароль должен содержать от 8 до 16 символов"
			},
			confirm_password: {
				equalTo: "Введенные пароли не совпадают"
			}
		}//end of message		
	});
	
	
							Стилизация сообщений об ошибках
Когда плагин Validation проверяет форму и находит некорректное значение в элементе,
происходит следующее: сначала элементу формы добавляется класс,а потом HTML-элемент label,
содержащий сообщение об ошибке.Например наша страница имеет такой вот код:

	<input type="text" name="email" class="required">

если посетитель попытается отправить эту форму не заполнив(при условии что плагин подключен)
плагин прервет процесс передачи и изменит HTML-код пол,добавив в него дополнительный
HTML-элемент.Новый HTML-код будет иметь следующий вид:

	<input type="text" name="email" class="required">
<label for="email" generated="true" class="error">Это поле обязательно для заполнения</label>

Чтобы изменить вид сообщения нужно просто добавить нужный стиль в таблицу со стилями.
К примеру чтобы текст сообщения был крассный и жирным:

	label.error {
		color: #f00;
		font-weight: bold;
	}
	
							Способ размещение сообщений об ошибках
Плагин Validation размещает сообщение об ошибке после элемента формы к которому применимо
правило проверки.Однако для флажков и переключателей это выгладит ужасно.Но в данном 
случае сообщение должно находится в другом месте,желательно после всех флажков или переключателей
Плагин Validation предусматривает способ управления размещением сообщений об ошибках.Мы
можем создавать собственные правила размещения сообщений путем передачи еще одной
обьектной константы функции validate().Для этого нужно вставить данный код после messages.
Тоесть сначала идет rules,затем messages, а уже потов данный код:


		errorPlacement: function(error, element) {
			if(element.is(":radio") || element.is(":checkbox")) {
				error.appendTo(element.parent());
			}else {
				error.insertAfter(element);
			}
		}//end of errorPlacement
	
Плагин Validation принимает произвольный обьект errorPlacement,предстовляющий собой 
анонимную функцию,определяющую сообщение об ошибке.Каждая ошибка обрабатывается данной
функцией,так что если нам нужно изменить расположение некоторых сообщений,нам придется
использовать управляющую инструкцию для определения элементов формы,чьи ошибки мы хотим
переместить.Функция принимает и сообщение и элемент формы к которому относится ошибка,
так что мы можем использовать управляющую инструкцию для выяснения того,является ли 
элемент формы флажком или переключателем.Если является то сообщение об ошибке помещается 
в конец элемента,содержащего данный флажок или переключатель.

/*
	Полная версия для примера выгладит так:
	$(document).ready(function() {
	$("#signup").validate({
		rules: {
			email: {
				required: true,
				email: true
			},
			password: {
				required: true,
				rangelength: [8,16]
			},
			confirm_password: {
			equalTo: "#password"
			} 
		},
		messages: {
			email: {
				required: "Введите адрес электронной почты.",
				email: "Это некорректный адрес электронной почты."
			},
			password: {
				required: "Введите пароль",
				rangelength: "Пароль дольжен быть от 8 до 16 символов"
			},
			confirm_password: {
				equalTo: "Пароли не совпадают"
			}
		},//end of messages
		errorPlacement: function(error, element) {
			if(element.is(":radio") || element.is(":checkbox")) {
				error.appendTo(element.parent());
			}else {
				error.insertAfter(element);
			}
		}//end of errorPlacement
	});
}); // end ready
*/

									jQuery UI 
jQuery UI --- это плагин позволяющий легко решить множество проблем,связанных с 
пользовательским интерфейсом,предусматривает большой набор эффектов и элементов 
интерфейса(также называемых виджетами),которые упрощаю процес создание интерактивных 
веб-приложений

Плагин jQuery UI состоит из множества частей которые могут быть сгрупирырованы в
три категории:

1.Выджеты 
Выджет - это фрагмент кода JavaScript,создающий один удобный элемент интерфейса.Например,
виджет  Dialog позволяет отображать всплывающие окна,подобные окнам с оповищением,внешний
вид и работу которых мы способны контролировать.Можно использовать это диалоговое окно,
чтобы показать посетителю,например,форму авторизации,или отобразить правила использования
сайта.Мы можем использовать диалогове окно когда кто-то просматривает наш сайт или для 
вывода информации об изображении при наведении на него указателя мыши.
В качестве другого примера можно привести виджет DatePicker,который облегчает посетителям
пройес выбора даты.Он открывает всплывающее окно с календарем.Пользователь может выбрать
дату в этом календаре с помощью щелчка мыши.Мы можем использовать этот виджет как часть формы

2.Взаимодействия
jQuery UI включает некоторые очень полезные  инструменты,позволяющие посетителям 
взаимодействовать с нашими веб-страницами.Например,мы можем сделать так,чтобы любой 
элемент на странице можно было перетаскивать.Представьте страницу интернет-магазина,на
которой посетители могут буквально перетащить нужный предмет в корзину.Создать онлайн-игру
в шашки,предоставив игрокам возможность перемещать их путем перетаскивания.Мы также можем
обеспечить способ изменения размера элементов страницы,например мы открываем всплывающий
диалоговый виджет с формой для создания  сообщения в блоге.Посетитель просматривающий 
диалоговое окно,может перетащить угол рамки,чтобы увеличть или уменьшить ее.

3.Эффекты
Библиотека jQuery предоставляет различные виды анимации(появление и исчесзновени элементов...)
Однако плагин jQuery UI предусматривает множество дополнительных возможностей,включая 
изменения цвета,различных классов CSS... 


Преимущества плагина jQuery UI перед другими плагинами:
1)jQuery UI является частью	проекта jquery.org,тоисть команды из jQuery и jQuery UI 
работают в тесном сотруднечестве,поэтому изменения в jQuery быстро послекут изменения в jQuery UI
2)Плагин jQuery UI предоставляет собой один файл javascript c двумя файлами CSS.При 
внесении изменений в jQuery UI мы можем быстро и просто обновить эти файлы.
3)Все виджеты имеют единобразный вид,поэтому нам не придется тратить много времени на 
приведение различных плагинов в соответствии со стилями сайта.
4)Плагин jQuery UI хорошо подерживаемый проект на конец 2014 когда в команде начислевалось
270 программистов,так что любые ошибки быстро исправляются

							Использование плагина jQuery UI
Quiсk Downloads - эти файлы предназначены для программистов которые собираются изучать 
или дорабатывать код.
Theme - в нижней часте страницы,можно выбрать различные темы которые можно использовать
с jQuery UI и получить доступ к ThemeRoller - который позволяет выбрать цветовую схему,
шрифты и дизайн jQuery UI

После загрузки jQuery UI.Внутри этой папки содержатся еще два каталога.Нам нужен только
каталог images,содержащий графичесские элементы,используемые плагином jQuery UI.Мы можем
проигнорировать папку external,она содержит библиотеку jQuery,которую мы ранее загрузили
и добавили на сайт.
							
								Использование
1)По поводу javascript просто нужно подключать файлик jquery-ui.min.js
2)CSS файлов 6 но нам нужен только jquery-ui.min.css , поскольку он содержит весь необходимый код	

jquery-ui.theme.min.css - содержит данные о цветах,шрифты,размеры шрифтов..визуальные эффекты
jquery-ui.structute.min.css - содержит код CSS отвечающий за расположение виджетов и 
элементов на странице.
Другими словами для обеспечение работы файла jquery-ui.min.css нужны эти два файла 		
	
	
							Добавления jQuery UI на веб-страницу
1)Для использования плагина jQuery UI нам необходимы только файлы jquery-ui.min.js и
jquery-ui.min.css,а также папка с изображениями.Для удобства можно создадать папку css
и js, в папку js закидываем query-ui.min.js, а в css jquery-ui.min.css и обязательно папку
images так как в файлик на нее сылается,а все остальное можно удалить
2)Размещаем CSS-файл плагина jQuery UI на сайте,Желательно перед нашей таблицей стилей,
тоесть сначала идут стили плагина,а потом наши,это делается для того чтобы вносить изменения,
если стили плагина будут идти после наших то, чтобы поменять настройки стилей плагина,
прийдется вносить изменения в саму таблицу стилей плагина,но это плохая идея,так как после
выхода новой версии плагина нам прийдется заменить эти стили новым файликом(из новой версии)

<link rel="stylesheet"  href="plugins/jquery-ui-1.11.4.custom/images/jquery-ui.min.css" >
<link rel="stylesheet"  href="css/styles.css" >
	
//Сначала идут стили плагина,а потом наши	

3)Прикрепляем javascript файлик
<script  src="plugins/jquery-ui-1.11.4.custom/jquery-ui.min.js"></script>
//Файл jQuery UI Не будет работать без библиотеки jQuery,поэтому сначала идет библиотека jQuery, а потом jQuery UI
 
	
	
	
							Создание диалогового окна с сообщением
1)Прикрепляем файлы(выше инструкции)
2)добавляем элемент div с атрибутом title - которое содержит слова заголовка	
	
<div class="news" title="Новости">
	<h1>Как-то так...</h1>
	<p>"Действительно наслаждаюсь своим временем здесь. Рад подписать контракт. Хорошо, что мы сделали это до открытия трансферного окна. У меня был отличный старт до травмы. Надеюсь, что вернусь и хорошо проведу оставшуюся часть сезона", — цитирует Джарвиса Sky Sports</p>
</div>

//Это необязательно должен быть div,все что угодно главное чтобы был класс или id и title  
3)Дабавляем функцию dialog()	
	
$(document).ready(function(){
	$(".news").dialog();	
});	
	
//И все!В результате вызовется диалоговое окно	
	
								Настройка свойст диалового окна
Мы можем настраивать различные свойства диалового окна,например высоту,ширину,способ 
появления и исчезновения с экрана,передав функции dialog() список имен и значений
Мы передаем обьект с понятными для плагина параметрами,когда вызываем функцию dialog()
Например,мы не хотим,чтобы посетители могли перетаскивать или изменять рразмер диалогового
окна.В этом случае мы просто передаем литерал обьекта с двумя параметрами:
$("#hello").dialog({
	draggable: false,
	resizable: false
});

Виджет Dialog предотвращает перетаскивание,когда для свойства draggable заданно значение
false,а resizable - предотвращает изменения размеров диалового окна.
Перечислены некоторые из самых полезных свойств:

------------------------------------------------------------------------------------------
draggable --- задайте для этого свойства значение false,чтобы зафиксировать диалоговое 
окно на экране и предотвратить его перетаскивание посетителями.	
------------------------------------------------------------------------------------------	
	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
resizable --- задайте для этого свойства значение false,чтобы сохранить размер размер 
диалового окна по умолчанию и запретить посетителям изменять размеры окна.	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	
	
------------------------------------------------------------------------------------------
height и width --- Обычно плагин jQuery UI задает для диалового окна такой размер,который
позволяет отобразить его содержимое.Однако мы можем управлять этим поведением,указав 
точное значение высоты и ширины в пикселях.Например,если мы хотим,чтобы ширина диалового
окна составила 600 пикселов,а высота 400 пикселов,можем добавить следующий код:
$(".news").dialog({
		width: 600,
		height: 400
	});	
Разрешается использовать только значения в пикселах(% или em - использовать нельзя).Если
мы зададим такие значения высоты и ширины при которых,содержимое диалогового окна в нем
не поместится,то плагин jQuery UI добавит внутри окна полосу прокрутки.Нам не обязательно
устанавливать оба свойства,можно задать только высоту или только ширину   	
------------------------------------------------------------------------------------------	
	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
minWidth и minHeight --- минимальная ширина и высота.Мы можем задать для диалогового окна
минимальные значения ширины и высоты,указав значения свойств minWidth и minHeight.Например
если мы хотим,чтобы ширина диалогового онка составляла,по крайней мере 600 пикселов,а
высота 400 то мы можем задать эти свойства следующим образом:

$(".news").dialog({
		minWidth: 600,
		minHeight: 400
	});

Когда мы устанавливаем минимальную высоту или ширину,алагин jQuery UI может задать для 
диалогового окна больше,но не меньшие значения.Если содержимое окна в нем не помещается 
то плагин увеличит его для отображение всего контента(не во всех случаях,бывает что не увеличивает)	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	

------------------------------------------------------------------------------------------
maxWidth и maxHeight --- максимальная ширина и высота.Мы можем задать максимальные 
значения высоты и ширины диалогового окна,используя свойства maxWidth и maxHeight.Например
если мы хотим,чтобы ширина диалогового окна не превышала 600 пикселов,а высота 400 
пикселов,то можем использовать эти свойства следующим образом:

$(".news").dialog({
		maxWidth: 600,
		maxHeight: 400
	});	

Диалоговое окно может быть меньшим, но не может быть больше данных значений 	
------------------------------------------------------------------------------------------	
	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
modal --- Модальное диалоговое окно используется для того,чтобы обратить внимание 
посетителя на сообщение,и предотвращает	какие-либо действия,пока тот его не закроет.Когда
модальное диалоговое окно открывается,посетитель не может щелкнуть кнопкой мыши на другом
месте страницы.На самом деле,на странице появляется темное прозрачное наложение,
затрудняющее чтение.Используйте модальное окно для того,чтобы посетитель сначала прочитал
сообщение,и возможно принял важное решение,например ответил на вопрос 
"Вы уверены что хотите удалить все эпизоды сериала 'Доктор зло'?".Чтобы окно стало 
модальным задайте для свойства modal значение true :

	$(".news").dialog({
		modal: true
	});	 
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	
	
------------------------------------------------------------------------------------------
show и hide --- Диалоговое окно появляется на экране,когда оно открыто и исчезает когда
закрывается.Однако vs мы можем добавить анимации,чтобы анимировать закрытие и откритие
окна,используя свойства show и hide.Эти свойства могут принимать различные значения.Если
мы зададим для них значение true,то диалоговое окно будет быстро отображатся и исчезать:

	$(".news").dialog({
		show: true,
		hide: true
	});	

Мы также можем предоставить численное значение,определяющее количество миллисекунд,в 
течении которых диалоговое окно станет появлятся или исчезать.Например,нам нужно,чтобы 
диалоговое окно появлялось очень быстро,скажем за 250 миллисекунд и исчезало в течении
2 секунд.В этом случае нам следовало бы установить эти свойства следующим образом:

$(".news").dialog({
		show: 250,
		hide: 2000
	});	

Мы можем передать в качестве значений этих свойств имя любого эффекта jQuery.Просто 
заключив в кавычки имя эффекта,например "slideDown" :

$(".news").dialog({
		show: "fadeIn",
		hide: "fadeOut"
	});	

мы также можем использовать эффекты,просто передав еще один литерал обьекта для имени 
эффекта.Например,мы хотим,чтобы при закрытии диалового окна после задержки 250 миллисекунд
оно взрывалось в течении 1 секунды,используя функцию "easyInQuad" :

$(".news").dialog({
		hide: {
			effect: "explode",
			delay: 250,
			duration: 1000,
			easing: "easeInQuad"
		}
	});

/*
	Также при закрытии есть эффекты вроде:
	hide: "explode" ---Диалоговое окно разлитается в стороны и исчезает
	hide: "bounce" --- Дергается(как бы дрожит) и потом исчезает
	hide: "drop" --- Сдвигается влево и плавно исчезает
*/	
------------------------------------------------------------------------------------------	
	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
position --- Обычно диалоговые окна появляются в центре браузера.Однако это необязательно
Мы можем настроить позиционированние  диалогового окна с помощью  свойства position.Как 
и свойства show и hide,оно может принимать несколько различных типов значений.Cначала 
способ его написания может показатся несколько странным,однако он довольно прост.У этого
свойства существует несколько параметров,наиболее важные из которых - my и at.
Например,если мы хотим переместить диалоговое окно в нижнее правое окно экрана:

$("#dialog").dialog({
	position: {
		my: "right bottom",
		at: "right bottom"
	}
});

Свойство my относится к диалоговому окну,а свойство at к окну браузера.Таким образом,
свойство my определяет,какая часть диалогового окна будет находится в том или ином 
положении в окне браузера(at).В данном примере код означает: 
"Помести нижний угол диалогового окна (my) в (at) нижнем правом углу окна браузера"
	
Мы используем синтаксис позиционирования CSS.Первое ключевое слово определяет положение
по горизонтали: left, right или center.Второе - положение по вертикали: top,center,bottom
Мы можем добавить третье свойство  of ,чтобы позиционировать диалоговое окно или подсказку
относительно другого  элемента страницы.Например,мы можем вывести диалоговое окно рядом
с полем "Вход",чтобы показать посетителям,где они могут авторизоватся. 

Свойство of принимает селектор или элемент jQuery.Допустим панель авторизации имеет
идентификатор login и мы хотим,чтобы диалоговое окно отображалось непосредственно под ним
В этом случае мы можем использовать следующий код:

$("#dialog").dialog({
	position: {
		my: "center top",
		at: "center bottom",
		of: "#login"
	}
});

Мы можем добавить больше контроля.Например,если мы хотим,чтобы диалоговое окно перекрывало
окно авторизации на 10 пикселов:

$("#dialog").dialog({
	position: {
		my: "center top-10",
		at: "center bottom",
		of: "#login"
	}
});

Мы можем прибавлять или вычетать численное или процентное значение(например, my: "center top+25%")
Нужно убедится чтобы не было пробелов иначе работать не будет
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	
	
	
						Открытие диалоговых окон с помощью событий
Чтобы скрыть диалоговое окно в момент его создания,необходимо передать функции dialog()
свойство autoOpen со значением false.Например,мы добавили на страницу элемент div с 
идентификатором login.Чтобы превратить этот элемент в диалоговое окно jQuery UI и сразу
скрыть его,добавим следующий код:

$("#login").dialog({
	autoOpen: false
});
	
При запуске страницы плагин jQuery UI превратит элемент div в обьект диаловогового окна и
скроет его на страницу.Чтобы сделать его видимым,мы должны передать функции dialog() 
аргумент open.Например,у нас есть кнопка "Вход на сайт",и мы ходим чтобы в ответ на 
нажитие этой кнопки открывалось диалоговое окно.Предположим,ссылка имеет идентификатор
loginLink.Мы можем выбрать эту ссылку,добавить обработчик события click и применить 
функцию,которая откроет диалоговое окно:

$("#loginLink").click(function(evt){
	evt.preventDefault();//Отменяет переход по ссылке
	$("#login").dialog("open");
});

Кроме того мы можем запрограммировать закрытие диаловогово окна.Например,если мы создадим
диалоговое окно с формой то скорее всего захотим сделать так,чтобы оно закрылось когда
посетитель отправит форму, вместо того,чтобы заставлять посетителя самостоятельно 
закрывать диалоговое окно после отправки формы.
Предположим что диалоговое окно имеет идентификатор #login которая содержит форму,нам
нужно чтобы это диалоговое окно закрывалось когда пометитель отправляет форму:

$("#login form").submit(function(){
	$("#login").dialog("close");
});

Чтобы закрыть диалоговое окно,просто выберем диалоговое окно и передаем  "close" и все!
	
	
							Добавление кнопок в диалоговое окно
Виджет Dialog jQuery UI позволяет нам добавлять кнопки в любое диалоговое окно.Кроме того,
затем мы можем запустить различные программы в зависимости от нажатой посетителем кнопки.
Например,если посетитель нажимает кнопку "Удалить" их списка удаляется один пункт,однако
если он нажимает "Отменить"	,то этот элемент остается на месте.Чтобы добавить кнопки, мы
передаем функции dialog() свойство buttons,значение которого является литерал обьекта,
содержащий имя и действие каждой кнопки.Например,нам нужно добавить в диалоговое окно
кнопки "Подтвердить" и "Отменить".Мы можем сделать это следубщим образом:
	
$("#dialog").dialog({
	buttons: {
		"Подтвердить" : function() {
			//Код выполняемый при нажатии кнопки "Подтвердить"
		},
		"Отменить" : function() {
			//Код выполняемый при нажатии кнопки "Отменить"
		}
	}//end of buttons
});//end of dialog	
	
	
//С помощью добавления кнопок,мы сможем сделать наши страницы интерактивными,сможем совершать
//любые действия в ответ на нажатие той или иной кнопки 	
	
	
В данном примере первая часть "Подтвердить"	 - это имя,то что будет отображено в качестве
текста на кнопке.
Вторая часть - это функция содержащий код,которым мы хотим выполнить при нажатии кнопки
Например чтобы закрыть окно с кнопкой "Подвердить" мосле нажатия кнопки и выполнения 
соответствующего кода, мы добавляете в конец анонимной функции фрагмент:

"Подтвердить" : function() {
	$(this).dialog("close");
}

							Удалить картинки из галерегии при нажатии
$(document).ready(function(){
	function gav() {
		$(".pust").dialog({
		autoOpen: false,
		hide: "explode",
		buttons: {
			"Подтвердить": function() {
				set.remove();
				$(this).dialog("close");
			},
			"Отменить" : function() {
				$(this).dialog("close");
			}
		}
	});
	var set;
	$("img").click(function ani(evt){
		set = $(this);
		evt.preventDefault();
		$(".pust").dialog("open");
	});	
	}
gav();
});




								Всплывающие подсказки 
1.Прикрепить файлы плагина к странице (css и js)
2.Добавить атрибут title к любому элементу,который должен иметь подсказку:

<a href="https://twitter.com/eksmo_live" title="Следуйте за нами в Twitter">
<img src="twitter.png">
</a>
	
Некоторые браузеры отображают подсказки сразу после добавления к элементу атрибута tittle
Однако,как и в случае с окном оповещения мы не можем изменить стиль подсказки,
предусмотренной браузером.Кроме того не все браузеры отображают подсказки,поэтому 
использование плагина jQuery UI обеспечивает максимальный контролдь и эффективность.
	
3.Выберим элементы и применим функцию tooltip()	
$(document).ready(function(){
	$("[title]").tooltip();//Находит все элементы с атрибутом title и применяет функцию tooltip()
});	

Или можем создать класс и применить функцию только к нему(но нужно поставить атрибут title в html)	
//И все всплывающие подсказки сами выплывут 

								Параметры всплывающих подсказок
Как и в случае с виджитом Dialog параметры всплывающих подсказок могут принимать свойства:

------------------------------------------------------------------------------------------
show --- Свойство show позволяет анимировать процесс появления всплывающей подсказки.Оно
работает подобно свойству show для диалоговых окон.Позволяет сделать так,чтобы подсказка
медленно появлялась. 									
------------------------------------------------------------------------------------------									
	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
hide --- Работает подобно свойству show, но контролирует процесс исчезновения подсказки.	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	

------------------------------------------------------------------------------------------
track --- Укажем для этого свойства значение true, и подсказка будет следовать за 
указателем мыши по экрану(при условии что указатель остается наведенным на HTML-элемент,
который ее вызывает):

track: true	

Движущаяся подсказка определенно будет заметной,однако она может отвлекать внимание,а 
текст в ней может быть трудночитаемым
------------------------------------------------------------------------------------------	
	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
tooltipClass --- Если мы хотим добавить имя класса для наших подсказок,мы можем 
предоставить значение этого свойства:

tooltipClass: "tooltip"

Это значение позволяет дополнить обычные тематические стили jQuery UI для всплывающих 
подсказок пользовательскими стилями с помощью созданного нами класса
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	
	
------------------------------------------------------------------------------------------
position --- Это свойство принимает обьект position и определяет местоположение подсказки
его относительно целевого элемента(на который посетитель наводит указатель мыши,чтобы 
увидеть подсказку)
/*
	Нужно быть осторожным со свойством Position.Всплывающие подсказки исчезают при наведении
на них указателем мыши.Если мы расположим подсказку над HTML-элементом связанным с ней,
то можем столкнутся с ситуацией при которой подсказка так и не появится.Это свзязанно с 
тем,что наведение указателя мыши на элемент,открывающий подсказку,означает наведение 
указателя на саму подсказку,что приводит к ее закрытию
*/
------------------------------------------------------------------------------------------	
	
							Использование в подсказке HTML-контента 
Добавлять всплывающие подсказки довольно легко.Однако если нам нужно чтобы подсказка 
имела больше контента,то мы не можем просто поместить HTML-код непосредственно в атрибут
title(из-за большого обьема текста например,подсказка будет показывать только половину текста).
Для более обьемных фрагментов контента виджит Tooltip предоставляет возможность указать
другой источник содержимого.

Свойcтво content позволяет указать содержимое,которое мы хотели бы добавить в подсказку.
Мы можем использовать это свойство несколькими способами.Самый простой заключается в 
передаче строки с HTML-кодом,который должен отображатся во всплывающей подсказке.Например,
у нас есть ссылка,указывающая на страницу с информацией о нас:

<a href="adress.html"  id="me">Обо мне</a> 

Если на нашем сайте есть фотография то мы можем отобразить ее в подсказке при наведении
указателя мыши на ссылку:

$("#me").tooltip({
	content: "<img src='me.png' alt='Посмотрите на меня!'>"
});	
	
Фрагмент $("#me") выбирает сылку,а часть tooltip() добавляет к этой ссылке подсказку.
Свойство content определяет HTML-контент,который должен появится внутри этой подсказки,
в данном примере это элемент img 	
	
	
Другой способ добавления HTML-кода в подсказку заключается в том,чтобы добавить HTML-код
на страницу,а затем использовать свойство content,чтобы поместить его во всплывающей
подсказке.Если мы добавляем на страницу HTML-код,он отображается в веб-браузере,а нам 
нужно,чтобы он отображался только во всплывающей подсказке.Для этого можно было бы 
использовать jQuery-метод hide(),чтобы скрыть HTML-код из поля зрения,а затем использовать
функцию tooltip(),чтобы взять этот скрытый HTML-код и отобразить его в виде всплывающей
подсказки.Однако есть другой,более простой способ, мы можем создать шаблон,поместив 
HTML-код между элементами <script>.Поскольку юраузер рассматривает содержимое элементов 
script в качестве кода JavaScript,он не будет отображать HTML-код.Однако мы можем 
использовать jQuery для получения доступа и использования этого HTML-кода во всплывающей
подсказке.Например,мы хотим поместить в подсказку элемент h2 и неупорядоченный список.
Мы можем создать шаблон с этим HTML-кодом между тегами элемента script:

<script id="tooltipTemplate" type="text/template">
	<h2>Обо мне</h2>
	<ul>
		<li>Я потрясающий</li>
		<li>Я чищу зубы 3 раза в день</li>
		<li><img src="me.png" alt="Посмотрите на меня!"></li>
	</ul>
</script>

	
Идентификатор можно использовать какой-угодно. type="text/template" - не обязателен,однако
без этого фрагмента в консоле будет показывать ошибку хотя код будет работать.Обычной
практикой является помещение этого фрагмента кода(шаблона) в нижней части страницы перед
закрывающим тегом </body>.После создания шаблона мы можем выбрать его и передать 
содержащийся в нем HTML-код виджету Tooltip:

$("#me").tooltip({
	content: $("#tooltipTemplate").html()
});

/*
	Пример со скрытым списком в HTML 
	$(document).ready(function(){
	$("#tooltipTemplate").hide();
	$(".submenu1").tooltip({
		content: $("#tooltipTemplate").show().html()
	});
});
*/


								Добавления панелей с вкладками
По сути нам необходимо включить три компонента:
1.Контейнер div.Вся коллекция вкладок и панелей должна быть заключена в элементе-контейнере.
Это необязательно должен быть элемент div,однако чаще всего исользуется именно он.Мы 
выбираем этот элемент с помощью jQuery, и затем он сообщает плагину jQuery UI,где найти
панели с вкладками.Просто предоставив идентификатор чтобы выбрать его
/*
	Если мы планируем создать более одного набора панелей с вкладками,то можим использовать
одно и тоже имя класса для каждого контейнера div.К примеру создали класс,для всех div 
контейнеров,а потом создаем вкладки с помощью $("selector").tabs();
*/
2.Вкладки.Для вкладок используем неупорядочный или упорядочный список.Каждая вкладка 
представлена одним элементом li.Внутри этого элемента li мы также должны включить элемент
"a" со значением href,которое указывает на идентификатор соответствующей панели.Например,
мы включили три вкладки,указывающие на три панели.HTML-код для этих вкладок может 
выглядеть следующим образом:

<ul>
	<li><a href="#details">Описание товара</a></li>
	<li><a href="#reviews">Отзывы</a></li>
	<li><a href="#order"></a>Заказать</li>
</ul>

3.Панели.Каждая панель предоставляет собой отдельный блочный HTML-элемент.Чаще всего это
элемент div,однако мы можем использовать article,section или любой другой блочный элемент
Включим идентификатор для этого элемента div,который соответствует # ссылки в панели.
Например:
	
	<div id="details">
		//HTML-код для панели 
	</div>

Идентификатор имеет большое значение.Плагин jQuery UI использует его,чтобы связать вкладку
с соответствующей панелью.Кроме того,это полезно для браузеров без JavaScript,поскольку
этот именной якорь позволяет перейти от ссылки в непорядовенном списке к соответствующему 
элементу div на странице.Внутри элемента панели мы можем поместить любой HTML-код панели
будет отображатся только при щелчке по вкладке.


Пример полной панели с вкладками:

<div id="tabbedPanel">
	<ul>
		<li><a href="#details">Описание товара</a></li>
		<li><a href="#reviews">Отзывы</a></li>
		<li><a href="#order"></a>Заказать</li>
	</ul>
	<div id="details">
		//HTML-код для панели 1
	</div>
	<div id="reviews">
		//HTML-код для панели 2
	</div>
	<div id="order">
		//HTML-код для панели 3
	</div>
</div>

//Мы можем использовать любые идентификаторы
//Навигация по понелям с вкладками может осуществлятся с помощью срелочек на клавиатуре 

Чтобы превратить этот HTML-код в панели с вкладками,мы выбираем контейнер,а затем 
вызываем функцию tabs() следующим образом:

	$("#tabbedPanels").tabs();//Это приведет к созданию простой панели с вкладками

								Параметры панели с вкладками
Как и другие виджеты jQuery UI,виджет Tabs предусматривает множество параметров для 
настройки принципа его работы.Чтобы изменить параметры панели с вкладками,просто передадим
литерал обьекта функции tabs(),содержащей имя свойства и значение,которое мы ходим для
него указать.

------------------------------------------------------------------------------------------
show и hide --- Эти два свойства контролируют то, как панели появляются и исчезают с 
экрана.Они принимают те же значения,что и свойсва виджета Dialog.Например,чтобы панель 
скользила при открытии и закрытии,нам нужно передать функции tabs() следующий свойства:

	show: "slideDown",
	hide: "slideUp"
------------------------------------------------------------------------------------------

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
active --- Обычно при загрузке страницы,содержащей панели с вкладками,выбирается первая
вкладка и отображается первая панель.Однако мы можем отобразить сначала вторую или 
последнюю панель.Для этого мы можем использовать свойсво active:

	active: 1

Как и в случае с массивами JavaScript,порядковый номера панелей начинаются с 0,поэтому 
передача функции active значения 1 приводит к открытию второй панели.Если вместо числа мы
передаем этому свойству значение false - active: false,мы скроем все панели.Панель 
откроется только тогда,когда посетитель щелкнет по одной из вкладок.Учтим,что этот 
параметр работает только при указании значения true для функции collapsible
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

------------------------------------------------------------------------------------------
collapsible --- Укажим  для свойства collapsible значение true,если хотим,чтобы 
пользователи могли скрыть все панели.Обычно по крайней мере одна панель видна постоянно,
однако когда для этого свойства указанно значение true, при щелчке по вкладке уже открытой
панели сама панель посностью закрывается, и мы видим только вкладки.Мы можем использовать
этот параметр,когда пространство на экране очень ограниченно,однако как правило так не 
делается и большинству посетителей нашего сайта такое положение вещей может оказатся 
незнакомым.Тем не менее мы должны указать для этого свойства значение true при присвоении
значения false свойству active,чтобы скрыть все панели при загрузке страницы 
------------------------------------------------------------------------------------------

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
event --- При щелчке по вкладке открывается связанная с ней панель.По крайней мере,так 
происходит при нормальной работе.Если мы хотим,чтобы панель вызывалась другим событием,
установим свойство event с именем нужного события.Например,чтобы панель плявлялась при
наведении на вкладку указателя мыши,мы можем использовать следующий код:

	event: "mouseover"
	
Тем не менее с данным параметром следуют быть осторожным.Люди привыкли к определенным
правилам,наиболее распостраненное из которых подразумевает то,что если мы щелкним по
элементу веб-страницы,то что-то произойдет.Если людям приходится дважды щелкнуть по
вкладке(dblclick) чтобы открыть панель,то они могут не так понять как открыть содержимое
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

------------------------------------------------------------------------------------------
heightStyle --- Свойство heightStyle определяет высоту каждой панели и может принимать 
одно из трех возможных значений: content,auto,fill.Обычно используется значение content
при котором высота панели определяется ее содержимым.Если в одной панели содержится много
абзацев текста,а в другой толькоодна фраза,то при переключении между панелями изменяется 
общая высота виджета.При существовании по-настоящему большой разницы в обьеме содержимого
наших панелей этот визуальный эффект может показатся нашим посетителям раздражающим.
Значение auto задает одну и ту же высоту для каждой панели, основываясь на панели с
наибольшим обьемом контента.Оно предотвращает изменение высоты группы панелей,но также
означает,что в нижней части панели с небольшим обьемом содержимого будет много пустого
места.Наконец значение fill заставляет группу панелей заполнить доступную область 
родительского элемента.Обычно оно создает много пустого места на каждой панели и приводит 
к трате ценного пространства экрана,поэтому его использования лучше избегать.
------------------------------------------------------------------------------------------

								
								Открытие на определенной вкладке
Панели с вкладками работают хорошо,однако существует одна проблема:страница всегда 
открывается либо на первой вкладке либо на той,которую мы указали с помощью свойства active
Но что если мы захотим отправить ссылку с определенной вкладкой?Например 
mycompany.com/productA.html#specs  ,при переходе по которой открывалась бы вкладка с
техническими характеристиками.Мы можем это сделать с помощью JavaScript.Секрет заключается
в выборе фрагмента #specs из URL-адреса и его использовании в качестве элемента-триггера для панели

/*
	Окно браузера предусматривает то,что называется обьектом location. Этот обьект 
содержит много информации об URL-адресе текущей страницы,в том числе имя хоста(location.hostname),
полный URL-адрес (location.href) и другие свойства(https://developer.mozilla.org/en-US/docs/Web/API/Location)
*/ 


Свойство  location.hash возвращает только часть URL-адреса, включающую фрагмент #
Например, мы посетили страницу mycompany.com/productA.html#specs .Свойство location.hash
для этого URL-адреса имеет значение #specs .Мы будем использовать свойство hash для 
загрузки панели с соответствующим значением hash.
К примеру у нас есть код HTML:

<div id="tabContainer">
				<ul>
				  <li><a href="#panel1">Вкладка 1</a></li>
				  <li><a href="#panel2">Вкладка 2</a></li>
				  <li><a href="#panel3">Вкладка 3</a></li>
				  </ul>
				<!-- Панель 1 -->
				<div id="panel1">
				  <h2><img src="images/robot.jpg" style="float:right" height="150" alt="robot">Содержимое панели 1</h2>
				  <p>Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</p>
				</div>
				<!-- Панель 2 -->
				<div id="panel2">
				  <h2>Содержимое панели 2</h2>
				  <p>Вы можете поместить в панель любой HTML-код</p>
				  <ul>
						<li>Избранное...</li>
						<li>Заголовки...</li>
						<li>Изображения...</li>
						<li>Другое...</li>
				  </ul>
				</div>
				<!-- Панель 3 -->
				<div id="panel3">
				  <h2>Содержимое панели 3</h2>
				  <p>Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</p>
				</div>
			</div>

И код jQuery:
			
$(document).ready(function() {
	$("#tabContainer").tabs({
		show: "fadeIn",
		hide: "fadeOut"
	});
}); // end ready

Добавляем управляющюю инструкцию:

$(document).ready(function() {
	$("#tabContainer").tabs({
		show: "fadeIn",
		hide: "fadeOut"
	});
	
	var hash = location.hash;
	if (hash) {
		$("#tabContainer").tabs("load", hash)
	}
}); // end ready

Этот код сначала проверяет наличие значения hash,например если посетитель посещает 
страницу tabs.html, то никакого значения hash не существует,так что мы можем пропустить
оставщуюся часть кода и просто позволить первой панели загрузится в обычном режиме.Однако
при наличии значения hash,например, #panel1 выполняется следующий фрагмент кода.Он просто
снова выбирает контейнер ($("tabContainer")),вызывает tabs() и передает два аргумента.
Первый из них load --- это команда,встроенная в программу jQuery UI,приказывающая функции
tabs() загрузить панель.Второй аргумент - hash ---это панель,которая должна быть загружена,
в данном примере это панель #panel1 , #panel2 , #panel3


								События jQuery UI 
Программы виджетов предусматривают собственные события,которые несколько отличаются от
привычных для нас событий браузера.(click,mouseover,focus,resize)События виджетов 
представляют собой просто моменты создания,использования или завершения компонента виджета. 
Например, виджет tabs предусматривает событие beforeActivate, которое позволяет выполнить
код непосредственно перед тем,как плагин jQuery UI отобразит скрытую панель.Это может
пригодится,если нам нужно выполнить другие действия при каждом щелчке по вкладке.Например,
мы можем применять пользовательское событие beforeActivate для обновления URL-адреса в
адресной строке браузера при каждом щелчке по вкладке,чтобы URL-адрес добавлял фрагмент #
соответствующей панели к имени файла,например, tabs.html#panel3 .При использовании в
сочетании с управляющей инструкцией,мы можем предоставить пользователям возможность 
добавить в закладки пользовательский URL-адрес,который бы отображал нужную панель при 
каждой загрузке закладки. Чтобы сделать это мы добавляем свойство beforeActivate к функции
tabs() с функцией в качестве значения следующим образом:
	
$("#tabContainer").tabs({
	beforeActivate: function(evt) {
		location.hash = $(evt.currentTarget).attr("href");
	}
});

Мы находим атрибут href вкладки,по которой щелкнул посетитель(#panel1 , #panel2 , #panel3)
и сохраняем его в свойстве hash обьекта location. 


Полный код: 

$(document).ready(function() {
  $('#tabContainer').tabs({
  	beforeActivate : function(evt) {
  		location.hash=$(evt.currentTarget).attr('href');
  	},
		show: 'fadeIn',
  	hide: 'fadeOut'
  });
  var hash = location.hash; 
	if (hash) { 
		$('#tabContainer').tabs("load", hash) 
	} 
	
}); // end ready


								Вкладки с удаленным содержимым
								
Плагин jQuery UI позволяет использовать в качестве содержимого панели с вкладками контент
других веб-страниц.Другими словами вместо создания неупорядоченного списка сылок,связанных
с элементами div в рамках страницы,мы можем создать неупорядоченный список ссылок, 
указывающих на другие страницы(или на контент).Мы можем использовать этот подход если 
содержимое каждой вкладки постоянно меняется(цены на акции,отзывы,сообщения форума).
Чтобы загрузить содержимое панели с других страниц или запросов веб-сервера,просто 
создадим элемент-контейнер div,неупорядоченный список,содержащий ссылки на другие страницы
и визовим функцию tabs().Например,нам нужно,чтобы каждая панель включала содержимое,взятое
из разных страниц.Эти страницы имеют имена panel1.html ,panel2.html ,panel3.html
В этом случае нам нужно добавить на страницу следующий HTML-код:

<div>
	<ul>
		<li><a href="panel1.html">Вкладка 1</a></li>
		<li><a href="panel2.html">Вкладка 2</a></li>
		<li><a href="panel3.html">Вкладка 3</a></li>
	</ul>
</div>

Если мы ссылаемся на динамические данные,мы можем указать не на веб-страницу,а на контент
генерируемый серверным языком например PHP:

<div>
	<ul>
		<li><a href="reviews.php?id=1298">Последние отзывы</a></li>
		<li><a href="forum.php?id=1298">Обсуждения на форуме</a></li>
	</ul>
</div>

Когда мы ссылаемся на внешние веб-страницы,нам не нужно включать элементы div панели.
Плагин автоматически создаст эти элементы при создании панели с вкладками.Для создания 
панели с вкладками просто выберем элемент-контейнер div и вызовим функцию tabs():

$("#tabContainer").tabs();

При выполнении этого кода плагин jQuery UI будет извлекать HTML-код из веб-страницы,
которая связана с первой видимой панелью.Например,в случае с вышеприведенным кодом при
загрузке страницы jQuery UI загрузит HTML-код из файла panel1.html и отобразит его в
панели под вкладками.Когда пользователь щелкнет по второй вкладке,плагин jQuery UI 
запросит HTML-код у второй ссылки и создаст новую панель,в которой этот HTML-код будет 
помещен.
	
В большенстве случаев мы можем сослатся даже на Google,Wikipedia или на какой-то сервер,
Но сайты могут блокировать этот процесс,что может предотвратить загрузку такого 
содержимого как веб-шрифты,изображения,видео.У этого подхода существует еще одна проблема,
в панели станет отображатся все содержимое связанной страницы.И в конечном счете у нас 
получится страница на странице.Если мы хотим поместить в панель только фрагмент HTML-кода
то для этого мы можем использовать два подхода:

1.Самый простой заключается в создании фрагментов страницы - HTML-файлов,содержащих только
те части HTML-кода,которые мы хотим поместить в панели.Мы можем легко создать фрагмент,
если загружаете данные с сервера динамически - наш серверный сценарий должен предоставлять
только тот контент,который должен отобразится в панели(то есть за исключение таких 
фрагментов как элемент head,который требуется для отображения полной веб-страницы)

2.Мы можем позволить панели загрузить всю веб-страницу и извлечь только то содержимое,
которое мы хотим отобразить в панели с помощью пользовательского события.
Вот как это работает: панели с вкладками jQuery UI предусматривают событие load.Это 
событие позволяет запускать функцию сразу после того,как плагин jQuery UI загрузит контент
из удаленного источника.Мы можем использовать jQuery для нахождения только необходимого
нам содержимого его извлечения и размещения внутри панели.Этот метод несколько сложен,но 
он не требует большого обьема кода.Во вторых мы должны убедится в существовании способа 
выбора конкретного содержимого из удаленной страницы.Самый простой способ это сделать 
заключается в том,чтобы обернуть содержимое,которое должно отобразится в панели в тег div 
с идентификатором,наример <div id="panelContent">.Теперь у нас есть возможность выбрать 
только это содержимое,исключив ненужный HTML-код,вроде элементов head или title  
Теперь нам нужно передать параметр load функции tabs().Параметр load представляет собой
пользовательское событие и мы предоставляем анонимную функцию,которая говорит плагину
jQuery UI,что делать после получения содержимого с удаленной страницы и его помещения в
панель.К моменту срабатывания события load плагин jQuery UI уже создаст новую вкладку и
вставит в нее HTML-код удаленной страницы.В данный момент новая панель содержит весь 
дополнительный HTML-код,который нам не нужен.Тем не менее мы можем использовать jQuery
для быстрого удаления этого нового HTML-кода и его замены сокращенной версией.Это 
происходит так быстро,что замена содержимого даже не отображается в браузере
	
Пример:

	$("#tabContainer").tabs({
		load: function(evt,ui) {
			var newHTML = ui.panel.find("#panelContent").html();
			ui.panel.html(newHTML);
		}
	});
	
//Насколько я понял код не будет рабоать если мы используем file:// или C:/ ,нужно чтобы было http:// 	
/*	
evt --- это обычный	обьект события jQuery.
Нас интересует второй обьект переданный анонимной функции события load: ui.
Обьект ui представляет собой обновленный элемент пользовательского интерфейса.
Для панели с вкладками существуют обьекты ui.panel и ui.tab 
Обьект ui.panel --- представляет вновь созданную панель(элемент div,создаваемый плагином
jQuery UI при загрузке внешней веб-страницы)

var newHTML = ui.panel.find("#panelContent").html(); --- мы создаем переменную которая
будет содержать итоговый контент панели(без лишних элементов вроде head).Когда плагин
создает новую панель,он загружает весь HTML-контент запрашиваемой страницы,так что мы 
можем заглянуть в эту панель и получить только нужный HTML-код.  	
ui.panel.find("#panelContent") --- получает HTML-код новой панели и ищет в нем элемент 
с идентификатором  panelContent (метод find() будет описан позже).Затем html() извлекает
HTML-код только из этой конкретной части страницы.Другими словами мы влязи нужый нам
фрагмент HTML-кода и сохранили его в переменной newHTML 

ui.panel.html(newHTML); --- мы просто заменяем старый HTML-код панели, новым HTML-кодом
(убираем все лишнее и оставляем новый тот который нам нужен,вырезая тем самым все лишнее)
Этот код выполняется так быстро,что браузер даже не отображает всей веб-страницы внутри 
панели и посетитель увидит только сокращенную версию HTML-кода	
*/	


						Экономия пространства с помощью аккордеонов
Аккордеоны jQuery UI,как панели с вкладками,являются еще одним элементом пользовательского
интерфейса,позволяющим экономить место.В любой момент может быть открыта только одна панель
аккордеона.Как правило,аккордеоны работают так же,как вкладки.Большинство параметров 
совпадает и функционируют подобно вкладкам,однако структура HTML-кода имеет много отличий.
В случае с аккордеономм нам нужны всего три компонента:

1.Элемент div,содержащий аккордеон.Нам нужно выбрать элемент div с помощью jQuery,так что
добавьте ему идентификатор или класс и примените к нему виджет Accordion

2.Заголовок,содержащий текст.Этот заголовок является интерактивным элементом управления,
который открывает и закрывает панели аккордеона.Не имеет значения,заголовок какого уровня
мы используем - h2,h3 или любой другой.Просто используем тот же самый уровень заголовка
для каждой группы аккордеона(технически мы даже не обязаны использовать элемент заголовка,
в данном случае подойдет любой блочный элемент,однако заголовки используется чаще всего) 

3.Блочный элемент,следующий сразу после заголовка.Обьчно это элемент div с содержиым,
которое мы хотим показать и скрыть.Этот элемент div должен идти сразу после заголовка
Заголовок и следующий за ним элемент div представляют собой одну часть аккордеона.Чтобы
добавить больше элементов аккордеона,добавьте больше пар заголовок/элемент div.Например,
базовая структура HTML-кода аккордеона,состоящего из трех панелей,выглядит так:

<div id="accordion">
	<h3>Триггер для первой панели аккордеона</h3>
	<div>
		//Содержимое первого аккордеона
	</div>
	<h3>Триггер для второй панели аккордеона</h3>
	<div>
		//Содержимое второго аккордеона
	</div>	
	<h3>Триггер для третьей панели аккордеона</h3>
	<div>
		//Содержимое третьего аккордеона
	</div>
</div>


После создания HTML-кода и прикрепления файлов CSS и JavaScript библиотеки jQuery и плагина
jQuery UI применение виджета Accordion будет сводится в выбору элемента-контейнера и вызову
функции accordion():

$("#accordion").accordion();

Параметры Аккордеона:

-------------------------------------------------------------------------------------------
active --- Параметр active работает подобно аналогичному параметру панели с вкладками.
Укажим числовое значение ,соответствующей панели аккордеона,которая должна открыться при
загрузке страницы.Например,чтобы открыть вторую панель мы можем использовать следующий код:

actve: 1

Как и в случае с массивами,отсчет панелей аккордеона начинается с 0.Если мы укажем для 
этого параметра значение false,а для свойства collapsible - значение true, то сможем
загрузить страницу с закрытыми аккордеонами
-------------------------------------------------------------------------------------------

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
collapsible --- Укажем для данного свойства значение true, а для active - значение false,
и при загрузке страницы все панели аккордеона будут закрыты.Кроме того,если мы укажем 
для данного свойства значение true,то заголовки аккордеона станут работать подобно 
переключателю: щелкните по заголовку и если панель под этим заголовком открыта,то она 
закроется.Если панель под этим заголовком открыта то она закроется.Если панель под этим
заголовком закрыть в момент щелчка,то она откроется.Другими словами по умолчанию если мы 
нажмем на открытый заголовок то блок не исчезнет,чтобы он спрятался нужно указать true
для данного свойства(collapsible) 
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

-------------------------------------------------------------------------------------------
animate --- Обычно при открытии и закрытии панелей аккордеона используется эффект 
скольжения.Мы можем отменить это поведение и заставить панели мгновенно открыватся и 
закрыватся,указав для данного свойства значение false:

animate: false

Мы также можем предоставить несколько других значений для разных типов поведения.Численное
значение сообщает jQuery UI длительность анимации(в миллисекундах).Например,чтобы взбесить
посетителя мы можем заставить панели аккордеона открыватся и закрываться в течении 5 секунд:

animate: 5000

Мы также можем предоставить строку,соответствующую имени функции easing,функция easing 
контролирует воспроизведение анимации: мы можем сделать так,чтобы воспроизведение анимации
началось очень медленно,а под конец ускорялось.Например,чтобы использовать функцию 
easeInElastic,мы може написать свойство animate так:

animate: "easeInElastic"

Тем не менее любое значение параметра easing,кроме того,которое используется по умолчанию
производит ужасный эффект
-------------------------------------------------------------------------------------------

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
event --- указывает событие которое приводит к открытию панели аккордеона.Работает так же
как и параметр event панели с вкладками,описанный выше.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

-------------------------------------------------------------------------------------------
heightStyle --- Аналогичен параметру с вкладками
-------------------------------------------------------------------------------------------

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
icons --- Плагин прикрепляет маленькие значки слева от заголовков аккордеона.Небольшая 
стрелка,направленная вниз отображается в заголовках относящихся к открытым панелям 
аккордеона.В заголовках,относящихся к закрытым панелям,отображается стрелка направленная 
вправо.Плагин jQuery UI включает большой выбор значков в качестве части каждой темы
(полный список мы можем найти на сайте api.jqueryui.com/theming/icons/),мы можем заменить 
значки передав параметр icons и значение,включающее литерал обьекта:

icons: {
	header: "ui-icon-plus",
	activeHeader: "ui-icon-minus"
}

Литерал обьекта передает два знака,которые должен использовать плагин jQuery UI.Свойство 
header устанавливает значок,используемый в заголовках относящихся к закрытым панелям 
аккордеона,а свойство activeHeader определяет значек,используемый для заголовков открытых 
панелей.В приведенном выше примере символы + и - используются для обозначения различных
состояний заголовков.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	
	
	
								Добавления меню на страницу 
Плагин jQuery UI также включает в себя виджет Selectmenu,который позволяет очень легко 
превратить неупорядоченный вложенный список ссылок в меню с вылетающими подменю.Этот виджет
предназначен для создания вертикальной строки меню,где пункты расположенны друг над другом,
а подменю отображается справа.С помощью него можно также создать и горизонтальное меню.
Самое сложное структурировать HTML-код,система как у плагина SmartMenus,чтобы добавить
в выпадающее меню к одной из этих кнопок просто вложим другой неупорядоченный список в тег
li кнопки верхнего уровня.Например меню с тремя меню верхнего уровня и подменю,которое
отображается при наведении на него указателем мыши:

<ul id="mainMenu">
	<li><a href="about.html">О нас</a></li>
	<li><a href="contact.html">Контакты</a></li>
	<li><a href="products.html">Продукты</a>
		<ul>
			<li><a href="a.html">Продукт А</a></li>
			<li><a href="b.html">Продукт Б</a></li>
			<li><a href="c.html">Продукт С</a></li>
		</ul>
	</li>
</ul>	
	
Когда HTML-код преобразуется в меню,посетители могут навести указатель мыши на пункт меню
"Продукты",чтобы отобразить подменю с тремя вариантами продуктов.Как и в случае с другими
виджетами jQuery UI,для элемента содержащего виджет следует предоставить идентификатор.
В данном случае это элемент ul поскольку он является контейнером для всег пунктов меню
и подменю. 	
	
Применение:

1.Прикрепите файлы CSS jQuery UI,jQuery
2.Вставим неупорядоченный список ссылок и дополнительные неупорядоченные списки для подменю
3.Добавим код CSS,чтобы ограничить размер кнопок меню и подменю.CSS-код,предусмотренный
для меню jQuery UI не ограничивает ширину кнопок поэтому наше главное навигационное меню
может содержать необычайно широкие кнопки.Чтобы указать размер кнопок основного меню,
создадим стиль .ui-menu со свойством width: 

	.ui-menu {
		width:10em;
	}

Класс ui-menu применяется автоматически плагином jQuery UI,когда он создает виджет меню
Этот класс применяется к каждому элементу ul в меню(в главном меню и в любом подменю)
Мы можем использовать любые единицы измерения - em,px,%, однако нужно быть осторожным при
использовании процентных значений.Подменю принимает свое % значение от своего родительского
элемента,поэтому каждое следующее подменю будет становится все тоньше.Чтобы обойти эту
проблему укажим 100% в качестве значения ширины подменю(элемент ul внутри ul),чтобы она
соответствовала ширине родительского меню.Например:

	.ui-menu {
		width: 25%;
	}	
	
	.ui-menu .ui-menu {
		width: 100%;
	}
//ОЧЕНЬ ВАЖНО ВСТАВИТЬ ЭТОТ КОД В CSS,ИНАЧЕ НЕ БУДЕТ ВИДНО ПОДМЕНЮ  
Добавим этот код CSS в наш CSS-файл нашего сайта,а не в CSS-файл плагина jQuery UI.Если мы
решим изменить тему или обновить плагин jQuery UI до более новой версии,то любые изменения
внесенные в CSS-файл jQuery UI,будут потеряны в процессе обновления.

4.Выберим внешний элемент ul и применим функцию menu():

	$("#mainMenu").menu();

 	
Параметры виджета меню:

-------------------------------------------------------------------------------------------
icons --- от любой кнопки справа отображается небольшой значек,котороя прикрепляется к 
подменю.Этот значек показывает что посетителям,что под этой кнопкой есть еще одно меню
Плагин jQuery UI предусматривает большой выбор значков в каждой теме(api.jqueryui.com/theming/icons/) 
Мы можем заменить параметр icons и значение:

	icons: {
		submenu: "ui-icon-circle-triangle-e"
	}
	
Можно использовать только один значек,поэтому значки совпадают что в главном меню то и в
подменю
-------------------------------------------------------------------------------------------	
	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
position --- Параметр position определяет положение подменю относительно их родительского 
элемента.Обычно подменю размещаетя непосредственно справа от своей родительской кнопки,
однако мы можем изменить это с помощью обьекта jQuery UI position.Например,если мы хотим
поместить подменб непосредственно под кнопкой,которая его открывает мы можем использовать
данный параметр следующим образом:

	position: {
		my: "center top",
		at: "center bottom"
	}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	
	
	
						Cоздание горизонтальной панели навигации
Меню jQuery UI не предназначены для создания классической навигационной панели,подобно тем,
что мы видим в верхней части большинства веб-сайтов.Если нам нужны такие меню,то лучше 
воспользоваться плагином SmartMenus.Тем не менее с помощью виджета меню мы можем создать
горизонтальное меню с одним выпадающим меню,применив небольшой фрагмент кода CSS					
Многоуровневые выпадающие меню работают не очень хорошо,поскольку виджет jQuery UI 
помещает все подменю в одном и том же положении,относительно родительского элемента.В 
случае с вертикальным меню виджет работает нормально:подменю выпадает справа от 
родительской кнопки(и каждое подменю как бы на ступеньку ниже становится,не плохо смотрится)
Однако в случае с горизонтальным меню первое подменю обычно отображается под родительской 
кнопкой(просто ниже появляется и так далее,ужасно смотрится) 	
	
1.Чтобы создать горизонтальное меню начните с неупорядоченного списка ссылок,но добавим
только один уровень вложенных неупорядоченных списков.(если добавить больше ужасно смотрится)
2.Добавим CSS-код,чтобы кнопки меню верхнего уровня отображались горизонтально.Мы должны 
поместить этот CSS-код в основную таблицу стилей для нашего сайта,а не в CSS-файл jQuery UI

	#mainMenu > li {
		width: 10em;
		float:left;
	}

Селектор CSS #mainMenu > li выбирает все элементы li которые являются прямыми потомками 
элемента с идентификатором #mainMenu(#mainMenu- это имя которое мы дали элементу контейнеру
например, ul="mainMenu")

3.Теперь нужно указать ширину подменю.Добавим еще один стиль CSS:

	.ui-menu ui-menu {
		width: 10em;
	}

Этот стиль задает ширину подменю.Плагин jQuery UI добавляет в каждое меню класс ui-menu
поэтому селектор .ui-menu .ui-menu выбирает только те элементы ul,которые находятся в 
другом элементе ul.Другими словами этот стиль относится только к подменю и задает ширину

4.Добавляем последний стиль
	
	#mainMenu {
		float:left;
	}

Этот стиль исправляет ситуацию escaping float,при которой высота родительского элемента 
схлопывается,когда его дочерние элементы размещаются с использованием свойства float.
 
5.Вызовим функцию menu(),однако добавим несколько параметров,чтобы контролировать 
расположение подменю и значка:

	$("#menu").menu({
		position: {
			my: "center top",
			at: "center bottom"
		},
		icons: {
			submenu: "ui-icon-triangle-1-s"
		}
	});

//position помещает выпадающее меню сразу под главным меню
//так как по умолчанию стоит значок в виде стрелочки вправо мы меняем ее на на стрелочку вниз


								
									Стилизация форм
								Стильный способ выбор даты
Многие формы предусматривают возможность выбора даты.Однако если мы просто попросим 
посетителей ввести дату в поле,мы можем получить слишком много различных результатов.
Прежде всего мы будем расчитывать на то что наши посетители не допустят ошибок.А поскольку
люди часто пишут даты по разному(в США,например даты указываются в порядке: месяц,день,год,
а во многих других странах используется порядок: день,месяц,год),даты введенные вручную
могут быть неточными или вводить в заблуждение.
К счастью,виджет jQuery UI DatePicker упрощает процесс выбора даты.Вместо того чтобы,
вручную вводить дату,посетители просто щелкают по элементу формы,а затем используют 
визуальный календарь для выбора нужной даты.Этот виджет просто в использовании и его 
легко настроить 

Применение:

1.Нужно прикрепить файлы jQuery,и файлы jQuery UI, CSS и JavaScript
2.Добавим на страницу форму и текстовое поле input для выбора даты.И добавим идентификатор:

<input type="text" name="birthdate" id="birthdate">

Если форма предусматривает несколько элементов для выбора дат(например,прибытия и отьезда),
то мы можем использовать имя класса для определения всех элементов формы,которые должны 
использовать виджет DatePicker следующим образом:

<input type="text" name="arrival" id="date">
<input type="text" name="departure" id="date">

3.Добавим на страницу функцию $(document).ready():
$(document).ready(function(){
	
});
	
4.Используем jQuery для выбора входного элемента(ов) и вызовим функцию datepicker():
	
$(document).ready(function(){
	$("#birthdate").datepicker();
});
	
Если мы использовали класс для идентификации более одного входного элемента,как в примере 2,
то можем написать следующее:

$(document).ready(function(){
	$(".date").datepicker();
});	
	
Это все что необходимо для создания панели выбора даты	
	
									Параметры:

-------------------------------------------------------------------------------------------
changeMonth --- Как правило,посетители могут изменить месяц,отображаемый в панели выбора 
дат Datepicker,щелкнув по значкам в виде стрелок влево и вправо в верхней части календаря 
Эти кнопки отображают либо предыдущий (слеева стрелочка) либо следующий месяц 
(справа стрелочка).Тем не менее это очень утомительный способ  выбора даты,которая наступит 
например через девять месяцев.Укажите значение true для параметра changeMonth,и появится
раскрывающийся список позволяющий посетителям быстро выбрать новый месяц
-------------------------------------------------------------------------------------------

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
changeYear --- Как и в случае с changeMonth,при указании значения true для этого параметра
плагин jQuery UI отображает раскрывающийся список для выбора нового года для календаря.Мы 
будем часто использовать этот параметр c параметром yearRange(описание ниже),чтобы указать
количество лет,отображаемых в раскрывающемся списке:

changeYear: true
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

-------------------------------------------------------------------------------------------
dateFormat --- Представляет строку,определяющую формат который должен использоватся 
плагином jQuery UI при выводе выбранной даты в элементе формы.Для определения различных 
вариантов выходных данных мы можем использовать предопределенные коды.Например, код dd 
используется для указания для месяца, mm - для указания месяца,а yy - для указания года.
Мы также можем вставить в качестве части строки такие символы как пробел, / или - 
Допустим,посетитель выбирает дату "27 января 2015" во всплывающем календаре,а мы хотим,
чтобы в формате эта дата отобразилась в формате 01-27-2015 .В этом случае нам нужно 
настроить параметр dateFormat следующим образом:

dateFormat: "mm-dd-yy"

Плагин jQuery UI предусматривает множество различных кодов для форматирования даты.
Полный список форматов,принимаемых выджетом Datepicker jQuery UI мы можем найти по адрессу:
api.jqueryui.com/datepicker/#utility-formatDate
//В примеру если поставить M - короткое имя месяца,а MM полное имя месяца
-------------------------------------------------------------------------------------------

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
monthNames --- Предоставим массив,содержащий 12 строк,чтобы заменить названия месяцев на 
английском языке.Например,чтобы отобразить названия месяцев на русском языке,добавим 
следующий код к литералу обьекта,переданного функции datepicker() :

monthNames: ["Январь", "Февраль", "Март", "Апрель", "Май", "Июнь", "Июль", "Август", "Сентябрь", "Октябрь", "Ноябрь", "Декабрь"]
//Но этот формат будет выден только после указания dateFormat: "dd-MM-yy" и при выборе даты  
//вместо како-го нибудь 21/01/2016 будет выводится 21-Январь-2016
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
	
-------------------------------------------------------------------------------------------
numberOfMonths --- Укажим численное значение для данного параметра,чтобы определить 
количество месяцев,отображаемых в панели выбора даты.Обычно отображается один месяц,но мы
можем обеспечить отображение нескольких месяцев.Если мы укажем значение больше чем 3, то
виджет Datepicker станет немного громаздким.ПАнели выбора дат всегда отображаются бок о бок,
так что если их больше трех или четырех,то нам придется пользоватся горизонтальной 
прокруткой,чтобы увидеть другие месяцы,доступные для выбора.Таким образом,для данного 
параметра рекомендуется использовать значения 1,2,3	
-------------------------------------------------------------------------------------------	
	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
maxDate --- Устанавливает последнюю доступную дату,которую посетитель может выбрать во 
всплывающем окне календаря Datepicker.Например,мы можем использовать данный параметр в 
системе бронирования номера в отеле.Многие отели не позволяют забронировать номер раньше,
чем за один год до прибытия,поэтому мы можем ввести ограничение так,чтобы посетитель не мог
указать дату,отстоящую от текущей более чем на год.Одним из способов является присвоение
числового значение определяющего количество дней в будущем.Например,чтобы предотвратить 
возможность выбора даты,отстоящей от текущей более чем на 30 дней,мы можем настроить 
параметр maxDate следующим образом:

maxDate: 30

В качестве альтернативы мы можем передать этому параметру строку,содержащую	специальные 
символы,которая указывает продолжительность: y - соответствует количеству лет, m - месяцев,
w - недель, d - количеству дней.Например, чтобы ограничить выбор до одного год используем:

maxDate: "+1y"

Разделим символы пробелом.Например,если мы хотим ограничить выбор даты тремя месяцами,двумя
неделями и пятю днями,мы можем сделать так:

maxDate: "+3m +2w + 5d" 
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	
	
-------------------------------------------------------------------------------------------
minDate --- Это противоположность параметра maxDate.Он указывает самую ранюю дату,доступную
для выбора.Этот параметр очень полезен для форм,предназначенных для планирования.В конце
концов,нет никакого смысла в том,чтобы позволить посетителю указать дату до сегодняшнего 
дня.Для указание самой ранней даты мы используем те же символы,что и в случае с параметром 
maxDate.Например,чтобы предотвратить выбор даты до текущего дня,укажим для данного 
параметра значение 0:

minDate: 0

Положительные значения этого параметра означают,что посетитель должен выбрать день в 
будущем.Например,если номер в отеле заказан на следующие три недели,то мы можем 
предотвратить выбор даты в этом диапазоне:

minDate: "+3w"//Грубо говоря мы к текущей дате добавляем 3 недели,и тогда можем выбрать дату	

Используем отрицательные значения для определения самой ранней доступной для выбора даты
в прошлом.Например,мы создали форму для осуществления поиска по базе данных нашей компании,
в которой содержится архив электронной почты.Чтобы предотвратить переполнение этой базы
данных,компания хранит переписку только за два последних года,поэтому нет смысла 
предоставлять возможность выбора дат,относящих от текущей на три,четыре или пять лет,
эти письма давным давно стерты.Вот как можно ограничить поиск последними двумя годами:

minDate: "-2y"

Мы можем комбинировать даты,месяцы и годы.Например,код для определения даты,относящей от 
текущей на один год,два месяца и три дня:

minDate: "-1y -2m -3d"
-------------------------------------------------------------------------------------------	
	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
yearRange --- Этот параметр используется с параметром changeYear и определяет,сколько лет
отображается в раскрывающемся списке.Например,мы хотим,чтобы пользователь предоставил свою 
дату рождения.Мы указываем значение true для параметра changeYear, чтобы посетитель легко 
мог вернуться на 20,30 или 50 лет назад.Как правило,параметр changeYear обеспечивает 
отображение в раскрывающемся списке 10 лет в прошлом и 10 лет в будущем.Но было бы лучше 
перечислить больше прошедших лет вместо будущих.Чтобы сделать это,мы передаем параметру 
yearRange положительное или отрицательное числовое значение,за которым следует двоеточие 
и еще одно положительное или отрицательное число.Первое число представляет собой первый 
год,указанный в раскрывающемся списке,а второе число- последний год.Например,нам нужно 
перечислить скажем 120 прошедших лет и ни одного будущего:

yearRange: "-120:+0"

Этот код создаст список годов который легко листать и можно быстро и удобно выбрать год
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	
	
-------------------------------------------------------------------------------------------
monthNamesShort --- Задает имя для списка месяцов которым мы создаем свойством changeMonth,
Чтобы поменять месяц нужно создать массив:

monthNamesShort: ["Январь", "Февраль", "Март", "Апрель", "Май", "Июнь", "Июль", "Август", "Сентябрь", "Октябрь", "Ноябрь", "Декабрь"],	
-------------------------------------------------------------------------------------------	
	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
dayNamesMin --- Позволяет менять сокращенные дни,для этого нужно создать массив.Если
написать дни полностью то все структура распадается и бни вылазят наружу,за пределы 
календаря,так что лучше сокращенный вариант


dayNamesMin: [ "Вс", "Пн", "Вт", "Ср", "Чт", "Пт", "Сб" ]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


Примерно так выглядит нормальные настройки для виджета Datepicker:	
	
$(".dateOfBirth").datepicker({
		changeMonth: true,
		changeYear: true,
		yearRange: "-100:+0",
		monthNames: ["Январь", "Февраль", "Март", "Апрель", "Май", "Июнь", "Июль", "Август", "Сентябрь", "Октябрь", "Ноябрь", "Декабрь"],
		monthNamesShort: ["Январь", "Февраль", "Март", "Апрель", "Май", "Июнь", "Июль", "Август", "Сентябрь", "Октябрь", "Ноябрь", "Декабрь"],
		dateFormat: "dd-mm-yy",
		dayNamesMin: [ "Вс", "Пн", "Вт", "Ср", "Чт", "Пт", "Сб" ]
	});	
	
	
	
								
								Cтилизация раскрывающихся списков	
Каждый браузер предусматривает собственный способ отображения раскрывающихся списков,
кроме того браузеры не позволяют применять к раскрывающимся спискам каждое свойство CSS	
К счастью,плагин jQuery UI предусматривает удобный виджет Selectmenu,превращающий обычный
HTML-код в привлекательный раскрывающийся список,внешний вид которого соответствует 
внешнему виду других виджетов jQuery UI.Виджет Selectmenu буквально воссоздает меню в виде
неупорядоченного списка и серии элементов span,которые можно лече стилизовать с помощью 
CSS.
 
Способ применения:

1.Прикрепляем файлы jQuery,файлы плагина jQuery UI, CSS и JavaScript
2.Добавим на страницу форму и раскрывающийся список то есть элемент select, содержащий
элементы option:

<select name="meal" id="meal">
	<option>Нет</option>
	<option>Для веганов</option>
	<option>Без глютена</option>
	<option>Для вегетарианцев</option>
	<option>Для мясоедов</option>
</select>	
	
Мы должны предусмотреть способ выбора раскрывающегося списка с помощью jQuery.Для этого
нужно указать идентификатор,а при наличии нескольких раскрывающихся списков в форме 
применим к ним один и тот же класс,например class="select" 	
	
3.Добавим на страницу jQuery-функцию $(docement).ready():

$(document).ready(function(){
	
}); 	
	
4.Используем jQuery	для выбора раскрывающегося списка и вызова функции selectmenu():

$(document).ready(function(){
	$("#meal").selectmenu();
});	
	
Если мы использовали класс для идентификации более одного раскрывающегося списка,мы можем 
написать следующий код:

$(document).ready(function(){
	$(".select").selectmenu();
});	
	
5.Так как слова в списке иногда не влазят полностью,нужно устанавливать ширину:
	
$(document).ready(function(){
	$(".select").selectmenu({
		width: 200
	});
});		

	
Параметры виджета selectmenu:

-------------------------------------------------------------------------------------------
width --- Этот параметр практически всегда является обязательным.Обычно плагин jQuery UI
создает раскрывающийся список,который недостаточно широк,чтобы отобразить весь текст пункта
списка.Нам нужно сделать его достаточно широким,чтобы мы могли увидеть весь пункт 
раскрывающегося списка.Кроме того,если раскрываюийся список не достаточно широк,чтобы 
отобразить параметр,который состоит более чем из одного слова,то плагин jQuery UI отобразит
этот параментр на двух строках.Для указания ширины в пикселях:

width: 300

Мы также можем задать ширину в процентах или единицах em,используя строку,содержащую число
и символ % или em.Например,чтобы раскрывающийся список соответствовал своему родительскому
элементу мы можем указать 100% в качестве значения его ширины:

width: 100%

Для em:

width: 6em	
-------------------------------------------------------------------------------------------	
	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
icons --- Мы также можем отобразить один из значков jQuery UI справа от раскрывающегося 
списка.Плагин jQuery UI предусматривает большой набор значков в каждой теме(api.jqueryui.com/theming/icons/)
Мы можем добавить значки,передав параметр icons и значение:

icons: {
	button: "ui-icon-circle-triangle-s"
}	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	
	
-------------------------------------------------------------------------------------------
position --- С	помощью данного параметра мы можем контролировать положение раскрывающегося
списка.Как правило,раскрывающийся список появляется непосредственно под его элементом 
управления - это обычный принцип его работы.Тем не менее при желании мы можем заставить 
всплывающий список пунктов раскрывающегося списка отобразится слева или справа от элемента
укравления.Для этого мы можем установить параметр position с помощью jQuery UI обьекта 
position.Поскольку позиционирования раскрывающегося списка в любом месте,кроме как под
элементов управления формой,является необычным поведением,нужно быть осторожным с этим 
свойством поскольку мы можем привести в замешательство посетителя.Например,поместить 
раскрывающийся список радом(справа):

position: {
	my: "left top",
	at: "right top"
} 
-------------------------------------------------------------------------------------------	
	
	
	
					Выполнение действия при выборе пункта раскрывающегося списка	
Когда посетитель выбирает пункт раскрывающегося списка,что-то должно произойти.Например,
у нас есть форма онлайн-заказа одежды с раскрывающимся списком,в котором перечислены все 
доступные цвета.Когда посетитель выбирает из раскрывающегося списка цвет,мы можем обновить
изображение предмета одежды,чтобы показать его в новом цвете.Другими словами выбор пункта
раскрывающегося списка приводит к изменению изображения на странице.Плагин jQuery UI 
позволяет вызвать функцию при каждом выборе пункта раскрывающегося списка.
Для этого мы используем параметр change.Он работает подобно другим параметрам,мы помещаем 
его внутри литерала обьекта,передаваемого функции selectmenu().В качестве значения 
параметра мы передаем параметру change функцию.Например,у нас есть раскрывающийся список
с идентификатором colors.Теперь нам нужно превратить этот раскрывающийся список в виджет 
Selectmenu jQuery UI и добавить параметр change:

$("#colors").selectmenu({
	width: 300,
	change: function(event, ui) {
		//программный код
	}
});
	
	
Всякий раз,когда посетитель делает выбор(в раскрывающимся списке),выполняется эта функция.
Функция предусматривает два параметра: event и ui.Параметр event содержит обьект события 
jQuery UI.Нам вероятно не понадобится использовать этот параметр в функции - он содержит 
только информацию о событии,наример X и Y координаты указателя мыши и другие данные,которые
не относятся к работе с пунктами раскрывающегося списка.
Тем не менее параметр ui содержжит полезную информацию о раскрывающем списке.В частности,
он может сообщить нам значение индекса вновь выбранного пункта.То есть его место в 
раскрывающемся списке(индекс первого пункта имеет значение 0).Параметр ui также содержит 
метку и значение выбранного варианта.Параметр ui сам по себе является обьектом,состоящим 
из различных свойств,к которым мы можем получить доступ,используя точечную нотацию
	
Свойства ui:

-------------------------------------------------------------------------------------------
ui.item.index --- содержит значения индекса выбранного пункта раскрывающегося списка.
Варианты в раскрывающемся списке нумеруются как элементы массива: первый элемент 
раскрывающегося списка индекс 0, второй 1 ...	
-------------------------------------------------------------------------------------------	
	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
ui.item.label --- содержит метку выбранного пункта раскрывающегося списка.Метка - это слово
или слова,которые посетитель видит в раскрывающемся списке.Она находит в HTML-коде внутри 
элемента option.Поэтому если у вас на страницу находится такой раскрывающийя список:

<select id="colors">
	<option>Красный</option>
	<option>Зеленый</option>
	<option>Синий</option>
</select>		

то метками для пунктов этого раскрывающегося списка являются: Красный,Зеленый,Синий
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	
	
-------------------------------------------------------------------------------------------
ui.item.value --- содержит значение выбранного пункта раскрывающегося списка.Это значение 
устанавливается с помощью атрибута value элемента option.Часто метка и значение бывают 
одинаковыми.В этом случае нам не не нужно указывать атрибут value в нашем HTML-коде.
Однако иногда нам может захотется передать на обрабатывающий данные формы сервер другое 
значение.Например,компания может предусмотреть специальные коды,соответствующие цвету.
Посетителю может понадобится "красная" рубашка,но в компании по производству одежды,
котороя использует несколько оттенков красного для различных типов одежды,красный цвет 
рубашки может обозначатся специальным кодом,например R785
В этом случае форма будет включать в себя значения в дополнение к меткам:

<select id="colors">
	<option value="R785">Красный</option>
	<option value="G101">Зеленый</option>
	<option value="B498">Синий</option>
</select> 	

Для данного раскрывающегося списка значениями являются "R785","G101","B498",а метками 
по-прежнему Красный,Зеленый,Синий
-------------------------------------------------------------------------------------------	
	
								Пример сменяемых изображений
	
<div class="forMeal"><img src="images/krasnii.jpg"></div>
<div>
	<select name="meal" id="meal">
		<option value="R785">Красный</option>
		<option value="G101">Зеленый</option>
		<option value="B498">Синий</option>
	</select>	
</div>	
	
	
$("#meal").selectmenu({
	width: 200,
	icons: {
		button: "ui-icon-circle-triangle-s"
	},
	change: function(event, ui) {
		var newImage;
		if(ui.item.label === "Красный") {
			newImage = "images/krasnii.jpg";
		}else if (ui.item.label === "Зеленый") {
			newImage = "images/green.jpg";
		}else {
			newImage = "images/blue.jpg";
		}
		$(".forMeal img").attr("src", newImage);
	}
});
	
	
Мы можем изменять изображение каждый раз,когда в раскрывающемся списке выбирается новый пункт

	
									Cтилизация кнопок
Плагин jQuery UI предусматривает виджет,позволяющий обеспечить согласованность поведения 
элементов форм,имеющих вид кнопок.Виджет Button может использоватся для стилизации кнопки 
отправки,кнопки сброса или элемента input,имеющего тип button: <input type="button">.
Кроме того,мы можем использовать его для стилизации HTML-элемента button,чтобы его внешний
вид соответствовал CSS-теме jQuery UI
Виджет Button позволяет быстро и легко превратить невзрачные элементы формы,например 
переключатели,флажки,кнопки отправки или обычные кнопки в элегантные жлеменнты интерфейса.	

Способ применения:

1.Прикрепить файлы jQuery,CSS и javascript плагина jQuery UI	
2.Добавим на страницу кнопку.Это может быть кнопка сброса,отправки или элемент button.
Например:

	<input type="submit" id="submit" value="Отправить форму!">
	<input type="reset" id="reset" value="Очистить форму">
	<input type="button" id="inputButton" value="Кнопка ввода">
	
Мы также должны дать идентификатор для выбора элемента.Либо при наличии нескольких кнопок
в форме применить к ним один и тот же класс,например class="button"

3.Добавим на страницу jQuery-функцию $(document).ready():

$(document).ready(function(){
		
});
	
4.Используем jQuery,чтобы выбрать кнопку и вызвать функцию button():

$(document).ready(function(){
	$("#submit").button();	
});	
	
Если мы использовали класс для идентификации более одной кнопки:
	
$(document).ready(function(){
	$(".button").button();	
});		
	

										Настройка кнопок:
Виджет jQuery UI Button не предусматривает большого количества параметров для настройки.
Текс,который мы видим на кнопке определяется значением атрибута value в случае с такими 
элементами input, как кнопки отправки и сброса.В случае с элементом button,включающим 
в себя открывающий и закрывающий теги <button>Я кнопка</button>	- текст который мы видим
на кнопке определяется содержимым,заключенным между тегами.Тем не менее мы можем настроить
кнопки несколькими способами,передав значения параметров методу button():

-------------------------------------------------------------------------------------------
icons --- Мы можем отобразить один из значков jQuery UI слева от кнопки и еще один значок
справа.Плагин jQuery UI включает в себя большой набор значков в каждой теме(api.jqueryui.com/theming/icons/)
Например:

icons: {
	primary: "ui-icon-gear",
	secondary: "ui-icon-triangle-1-s"
}	

Первый значек отображается слева,а второй - справа.Нам не нужно указывать два значка,
поскольку это,как правило выглядит довольно странно.Обычно мы будем указывать только один
их двух.Например,для отображения стрелки вправо на всех элементах button на страницу мы 
можем написать следующий код:

$("button").button({
	icons: {
		secondary: "ui-icon-circle-arrow-e"
	}
});

МЫ НЕ МОЖЕМ ПРИМЕНИТЬ ПАРАМЕТР icons К КНОПКЕ,СОЗДАННОЙ С ПОМОЩЬЮ ЭЛЕМЕНТА input,ТО ЕСТЬ
К КНОПКАМ ОТПРАВКИ ИЛИ СБРОСА,- ТОЛЬКО В ЭЛЕМЕНТУ button(<button></button>)
-------------------------------------------------------------------------------------------	
	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
text --- Если мы используем элементы button и применяем к этим кнопкам параметр icons,то
мы можем полностью скрыть текст на кнопке и отобразить только значок.Указав значение false
для параметра text, мы скрываем метку кнопки и отображаем только значек.Например,у нас
есть кнопка с меткой "Далее":

<button>Далее</button>

Мы можем превратить эту кнопку в кнопку jQuery UI,добавив к ней значек в виде стрелки 
вправо и удалить с кнопки слово "Далее" следующим образом:

$("#next").button({
	icons: {
		secondary: "ui-icon-circle-arrow-e"
	},
	text: false
});	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	
	
	
	
							Стилизация переключателей и флажков
Переключатели и флажки - это элементы формы,которые в своем исходном виде смотрятся не 
очень хорошо.Браузеры отображают их в виде предусмотренном операционной системой для кнопок
и флажков,которые нельзя настроить с помощью кода CSS так же,как другие HTML-элементы	
К счастью,плагин jQuery UI предусматривает виджет,позволяющий привести внешний вид 
переключателей и флажков в хорошее состояние.Всю работу делает метод .buttonset()
На самом деле он просто применяет метод button() к каждому переключателю или флажку.
Все что нам нужно сделать это настроить HTML-код: поместить группу кнопок в некоторый 
контейнер,например в элемент div,чтобы иметь возможность выбрать его с помощью jQuery
Например,мы создаем форму для бронирования авиабилета,в которой покупатели могут указать 
количество багажа - 0,1 или 2. Наш HTML-код может быть организован следующим образом:

<div id="radio">
	<p class="label">Количество багажа</p>
	<input type="radio" id="none" name="bags" checked="ckecked">
	<label for="none">0</label>
	<input type="radio" id="one" name="bags">
	<label for="one">1</label>
	<input type="radio" id="two" name="bags">
	<label for="two">2</label>
</div>
	
$("#radio").buttonset();

Вот и все. Код $("#radio") выбирает элемент div,содержащий переключатели.
Фрагмент .buttonset() находит каждый переключатель или флажок внутри этого элемента div 
и превращает его в кнопку.Уникальность функции buttonset() заключается в том, что она 
группирует все эти элементы так,чтобы они казались одним блоком.Если мы хотим чтобы
кнопки были не впритык то просто можем сделать так:

$("#radio input").button();
	
Этот код применяет функцию button() отдельно к каждой кнопке внутри элемента div	
	
	
Та же самая техника применяется к флажкам.Просто сгруппирируем флажки,добавим им контейнер
(элемент div) выберем этот контейнер и применим функцию buttonset();Главное правильно 
сделать HTML-код,нужно чтобы было id у input и чтобы в label for на него ссылался,пример:
 
    <input type="checkbox" id="aisle" name="aisle">
    <label for="aisle">У прохода</label>

//Если этого не сделать код работать не будет.	
		
Переключатели и флажки ведут себя по разному.В случае с флажками мы можем выбрать любое
количество флажков в группе(или вообще ниодного),а из переключателей одновременно может 
быть выбрана только одна кнопка в группе	
	
	
	
					Предоставление подсказок с помощью функции автозаполнения
Многие сайты содержащие строку поиска предусматривают полезную функцию,которая предлагает
вырианты тому что мы ввели в эту строку.Например,мы ввели слово "Лампы" и увидим 
раскрывающийся список где перечислены категории продуктов,которое содержит слово "Лампы"
Вместо того чтобы вводить остальную часть запроса,мы можем щелкнуть по одному из 
предложенных вариантов или использовать клавиши "вверх" "вниз",чтобы сделать выбор

Эта функцию называется "автозаполнением" и плагин jQuery UI предусматривает полезный виджет
который позволяет добавить эту функцию на наш сайт.Мы можем добавить функцию автозаполнения
к любому текстовому полю в форме.Например,мы создаем систему для бронирования авиабилетов,
и клиенту необходимо указать аэропорт из которого он собирается вылететь.Когда он начинает
вводить название аэропортов,появляется раскрывающийся список с вариантами,которые 
соответствуют нескольким веденным буквам.Затем пользователь может выбрать из пунктов
раскрывающегося списка вместо того чтобы вводить полное название.

Чтобы использовать виджет Autocomplete,необходимо предоставить плагину jQuery UI данные,
которые он может использовать для поиска соответствий,отображаемых в раскрывающемся списке
автозаполнения.Например,нам нужен  список названий аэропортов,чтобы плагин jQuery UI мог
найти соответствие тому,что посетитель ввел в поле формы.Существуют два способа сделать 
это: создать массив с помощью javaScript или отправить поисковый запрос на веб-сервер,
используя технологию Ajax, и дождатся от веб-сервера списка с соответствующими данными.


Способ применения:

1.Нужно прикрерит файлы jQuery,а также файли плагина jQuery UI, CSS и javaScript
2.Добавим на страницу форму и тектовое поле:

<input type="text" id="airoport" name="airoport">

3.Добавим на страницу функцию $(document).ready():

$(document).ready(function(){
		
});

4.Используем jQuery для выбора текстового поля и вызова функции автозаполнения:

$(document).ready(function(){
	$("#airport").autocomplete();	
});

По край немере мы должны передать функции autocomplete() обьект,содержащий свойство source,
а также либо массив элементов,либо URL-адрес серверной программы,которая может возвратить
список вариантов,соответствующих тому,что ввел посетитель.


						Использование массива с виджетов Autocomplete
Виджет Autocomplete требует наличия перечнятерминов,которые используются плагином jQuery UI
для поиска совпадений с тем,что ввел посетитель.Самый простой способ заключается в передаче
массива элементов которые будет использовать jQuery UI.Например,у нас есть вопрос:
"Какой нш любымый оттекнок красного?".Мы можем создать массив с названиями цветов и 
передать его функции autocomplete() следующим образом:

var colors = ["Barn Red", "Beetroot", "Brick", "Bright Maroon", "Burgundy"];
$("#redInput").autocomplete({
	source: colors
});
 
После того как этот код будет выполнен,а посетитель введет в текстовое поле латинскую букву 
"B",появится раскрывающийся список,содержащий все элементы массива "Barn Red", "Beetroot", "Brick", "Bright Maroon", "Burgundy"
Однако если затем посетитель введет букву "r",то есть в поле будет введено "Br",то он 
увидит только два цвета в названии которых присуцтвуют буквы "Br": "Brick" и "Bright Maroon"

/*
	Хорошей идеей является создание отдельного файла javaScript,который содержит те данные,
которые мы хотим использовать в качестве параметра source для виджета.Например,нам нужно
названия для аэропорта.Для этого мы создаем отдельный файл airports.js, потом создаем там
один единственный массив где перечислены все названия аэропортов 
	Этот файл оказался бы очень большим,и нам не потребовалось бы использовать этот массив
на каждой странице нашего сайта,поэтому его лучше было бы поместить в отдельный файл и 
состаться на него только на странице на которой используется виджет Autocomplete.Этот файл
прикрепляется к странице так же,как и любой другой файл javaScript.Например:

	<script src="airport.js"></script>
	
Мы должны убедится,что этот файл прикреплен к странице до того как использовать виджет 
Autocomplete,поскольку нам необходимо загрузить массив до вызова функции autocomplete()
Например:

<link rel="stylesheet"  href="plugins/jquery-ui-1.11.4.custom/css/jquery-ui.min.css" >
<link rel="stylesheet"  href="css/styles.css" >
<script src="js/jquery-1.11.3.min.js"></script>
<script src="js/jquery-ui.min.js"></script>
<script>
	$("#airport").autocomplete({
		source: airports  //airports - это названия массива,который хранится в отдельном файле airports.js
	});
</script>

Файл airports.js загружается перед выполнением функции autocomplete(),что позволяет 
гарантировать то,что массив сначала создается ,а затем передается виджету
*/


							Использование отдельных меток и значений
Выбор варианта из раскрывающегося списка автозаполнения дает jQuery UI инструкцию вписать
этот вариант в текстовое поле.Мы можем дать плагину jQuery UI инструкцию написать что-то
отличное от того,что отображается в раскрывающемся списке автозаполнения.Например,если 
посетитель выберет "Abilene Regional Airport",то мы можем приказать плагину написать 
в текстовом поле код ABI.
Чтобы это сделать мы предоставляем массив обьектов.Каждый обьект содержит два свойства:
label и value.

Метка(label) --- это то,что видит посетитель во всплывающей форме автозаполнения
value --- это то,что фактически добавляет плагин jQuery UI в элемент формы после того,как
посетитель сделает выбор.

Например,массив со значениями будет начинатся так:


var airports = [
{
	label: "Abilene Regional Airport, Aberdeen, South Dakota",
	value: "ABR"
},
{
	label: "Abilene Regional Airport, Abilene, Texas",
	value: "ABI"
},
{
	label: "Abilene Lincoln Capital Airport",
	value: "SPI"
},
{
	label: "Adak Airport, Adak Island, Alaska",
	value: "ADK"
},
{
	label: "Adirondack Regional Airport, Saranca Lake, New York",
	value: "SLK"
}
]; //Здесь могут быть перечислены другие аэропорты,это просто пример,реальный файл был бы огромным


Мы точно так же передаем массив функции autocomplete(),плагин jQuery UI запрограммирован 
так,что он изменяет свой принцип работы,когда получает массив обьектов:

$("#airport").autocomplete({
	source: airports
});

Теперь когда мы вводим в поле поиска то видим поле label,а когда выбыраем то в результате
появляется поле value 


	

					Получение данных для функции автозаполнения с сервера
Виджет Autocomplete наиболее полезен,когда у вас есть много данных среди которых мы можем
произвести поиск.Создать файл с очень большим массивом не так просто,а во многих случаях
просто невозможно.Такой файл был бы огромным и на его загрузку из Интернета уходилобы очень
много времени.Так что на многих сайтах которые включают функцию автозаполнения используется
программний код на стороне сервера для отправки гараздо меньшего списка с вариантами для
автозаполнения.Вот как это работает:

1.Посетитель начинает вводить запрос в текстовом поле

2.Введенные посетителем данные отправляются на сервер.Используя технологию Ajax,браузер 
отправляет данные на сервер и ожидает ответа.В этом случае браузер отправляет текст,
который успел ввесли посетитель.

3.Сервер отправляет обратно массив поисковых запросов,которые соответствуют тому,что ввел					
посетитель.Сервер предоставляет список подходящих терминов.Как правило,это обеспечивается
программным кодом на стороне сервера,который производит поиск по базе данных,получает 
результаты в виде массива,коотрый посылается обратно

4.Список соответствующих терминов отображается в раскрывающемся списке автозаполнения.
Большая часть этого волшебства обеспечивается благодаря технологии Ajax,которая позволяет
использовать код javaScript для отправки и получения информации с веб-сервера без 
необходимости перезагрузки новой веб-страницы.

Вместо того чтобы предоставлять массив возможных поисковых запросов для свойства source 
мы предоставляете URL-адрес указывающий на серверный сценарий.Например,у нас есть текстовое
поле которое посетители используют для выполнения поиска в нашем каталоге,содержащем 
описание 250 000 товаров.И для облегчения поиска мы решили добавить функцию автозаполнения.
Однако наш каталог слишком большой чтобы поместить его в один массив в отдельном файле .js
Вместо этого мы создаем программу на стороне сервера products.php,расположенную в корневом
каталоге нашего сайта.Затем мы указываем путь к этому файлу,используя свойство source.
Предположем что мы присвоили элементу формы идентификатор "productSearch":

<input type="text" id="productSearch" name="productSearch">


В коде javaScript нашей страницы мы можем применить виджет Autocomplete к этому элементу
и указать на серверную страницу так:

$("#productSearch").autocomplete({
	source: "/products.php"
});

Мы можем предоставить полный URL-адрес, включая протокол и доменное имя:

$("#productSearch").autocomplete({
	source: "http://myCompany.com/products.php"
});

Когда мы предоставляем массив элементов для параметра source,плагин jQuery UI фильтрует 
этот массив с целью нахождения элементов,содержащих текст,введенный посетителем и 
отображает только соответствующие этому тексту элементы массива. Виджет Autocomplete ведет
себя немного по-другому,когда для параметра source передается URL-адрес.Плагин jQuery UI
отображает все данные ,возвращенные сервером, и не фильтрирует эти данные с целью 
нахождения соответствий.Например,если посетитель ввел текст "Светлый",а сервер возвратил
массив,содержащий элементы "Темный", "Артишок", "Страус", то jQuery создаст раскрывающийся
с соответствующими пунктами.Другими словами,возвращение корректных данных полностью зависит
от сервера.Это означает что мы(или другой программист) должны написать всю логику для 
генерирования надлежащего списка и его отправки браузеру.Чтобы помочь в решении этой задачи
плагин jQuery UI добавляет параметр URL,чтобы сообщить серверу,что ему нужно искать.Этот
параметр называется term и его значением является то,что посетитель ввел в поле.В примере
с поиском товара,если бы посетитель ввел слово "свет",то плагин отправил бы запрос на 
сервер следующим образом:

http://myCompany.com/products.php?term=light

Затем страница products.php выполняет над этими данными некоторые действия,например,
производит в базе данных поиск товаров которые так или иначе связаны с лампами.Это может
быть буквальный поиск,в результате которого отображаются только товары,в названиях которых
присуцтвует слово "свет": "светильник", "светодионная лента"...Более полная программа,
предоставляющая список товаров,имеющих отношение к понитию света,может предоставить такие
варианты,как "люминесцентные лампы","антигравитационные машины"...Программист решает,как 
обрабатывать поисковый запрос и какие данные отправлять обратно

Программа на стороне сервера должна вернуть список элементов отформатированных в виде массива:

[
	"светильник",
	"светодионная лампа",
	"светодионная лента"
]

Кроме того,сервер может возврать данные в виде массива обьектов,но эти данные должны 
использовать формат JSON:

var airports = [
{
	label: "Abilene Regional Airport, Aberdeen, South Dakota",
	value: "ABR"
},
{
	label: "Abilene Regional Airport, Abilene, Texas",
	value: "ABI"
},
{
	label: "Abilene Lincoln Capital Airport",
	value: "SPI"
},
{
	label: "Adak Airport, Adak Island, Alaska",
	value: "ADK"
},
{
	label: "Adirondack Regional Airport, Saranca Lake, New York",
	value: "SLK"
}
];


Параметры автозаполнения:
Параметров,контролирующий работу виджета Autocomplete немного.Самым важным(и обязательным)
яляется параметр source описан ранее.Тем не менее существует несколько других полезных
параметров:

-------------------------------------------------------------------------------------------
source --- Наиболее важный и единственный обязательный параметр.Используется для передачи
массива или URL-адреса страницы на стороне сервера.Массив содержит либо значение либо
обьекты со свойствами label и value.В случае с URL-адресом программа на стороне сервера 
должна превратить данные,отформатированные в виде массива
-------------------------------------------------------------------------------------------

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
delay --- При использовании программы на стороне сервера в качестве источника данных для 
автозаполнения плагин jQuery UI посылает запрос на сервер каждый раз,когда посетитель 
вводит что-либо в поле.Многочисленные быстрые запросы могут замедлить работу сервера и
скорость отклика виджета Autocomplete.Мы можем настроить небольшую задержку,чтобы снизить
нагрузку на веб-сервер,передав численное значение этого параметра в миллисекундах.Например,
чтобы подождать полсекунды перед отправкой мы можем настроить данный параметр:

delay: 500
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

-------------------------------------------------------------------------------------------
minLength --- Этот параметр определяет минимальное количество букв,которое необходимо 
ввести прежде чем виджет Autocomplete начнет предлагать варианты.Если источники данных 
для автозаполнения содержат сотни тысяч записей то мы вероятно,решим установить в качестве
минимальной длины три символа.В конце концов,если посетитель введет в поле букву "а",то он
может получить тысячи подсказок из крупного источника данных.

minLength: 3
-------------------------------------------------------------------------------------------



							Знакомство с приложением ThemeRoller
Команда jQuery UI создала онлайн-инструмент под названием ThemeRoller.Этот инструмент 
позволяет выбрать одну из 24 тем,разработанных дизайнерами для использования с плагином
jQuery UI.Он также предусматривает инструменты для изменения существующей темы,позволяя
нам выбрать шрифты и цвета,которые соответствуют внешнему виду нашего сайта

Чтобы использовать приложение ThemeRoller посетим страницу(http://jqueryui.com/themeroller/)
Мы можем просмотреть коллекцию заранее разработанных тем щелкнув по вкладке "Gallery"
Там же мы можем выбрать готовые темы и даже редактировать их "Edit"

Если мы хотим добавить плагин jQuery UI на сайт который мы уже создали мы можем 
использовать приложение ThemeRoller для создания собственной темы,которая соответствует 
дизайну нашего сайта.Щелкнув по вкладке "Roll Your Own"(Создайте собственную тему).
Теперь о категориях и что они делают:

-------------------------------------------------------------------------------------------
Font Settings --- Эта категория позволяет указать шрифты,а также их размер и начертание.
Введем название шрифта(ов),которые мы хотим использовать в поле "Family".Обычно шрифты 
указываются в виде группы,включающей три варианта: шрифт,который мы хотим загрузить первым,
резервный шрифт,а затем запасной шрифт.Если первый шрифт недоступен на компьютере нашего 
посетителя,то используется второй шрифт.Если недоступен и этот шрифт,то выбирается шрифт 
общего типа (serif,sans-serif,monospace или fantasy).Нужно использовать теже шрифты,
которые мы используем на своем сайте.Например,если на нашем сайте в качестве основного 
шрифта используется "Helvetica Neue",то мы можем ввести следующее:
"Helvetica Neue", Arial, sans-serif.(При использовании шрифта,название которого состоит
более чем из одного слова,например, "Helvetica Neue",мы должны заключить название шрифта
в кавычки).Плагин jQuery UI применит один и тот же шрифт ко всем виджетам и их составляющим
 
Параметр Weight --- определяет начертание шрифта и может принимать такие значения,как
"normal" или "bold".Выбор значения bold не приведет к тому,что весь текст внутри виджетов
jQuery UI окажется выделен полужирным начертанием,оно будет примененно только к 
определенным элементам,например к тексту на вкладках,кнопках в раскрывающихся списках и 
заголовках аккорденов.К остальному тексту будет применено нормальное начертание.
-------------------------------------------------------------------------------------------	
	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
Corner radius --- Большинство виджетов jQuery UI имеет углы,а данный параметр позволяет 
сделать эти углы более или менее скругленными.Значение 0 создает прямые углы,более высокие
значения делают углы более округлыми.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	
	
-------------------------------------------------------------------------------------------
Категория Header/Toolbar --- позволяет задать цвета и узоры для заголовка панели выбора
даты или диалогового окна,а также цвет в панели прогресса или слайдере.Эта категория 
предусматривает шесть различных параметров: цвет фона,текстура фона,непрозначность текстуры
фона,цвет границы,цвет текста и цвет значка.	
-------------------------------------------------------------------------------------------	
	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
Content --- Данная категория позволяет установить фон,границы и цвета текста для областей
контента  виджетов,к которым относится панели аккорденов и панели с вкладками,пункты меню
в виджете Selectmenu и календарь виджета Datepicker.Содержащиеся в данной категории 
параметры аналогичны параметрам категории Header/Toolbar:цвет фона,текстура фона,
непрозначность текстуры фона,цвет границы,цвет текста и цвет значка	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	
	
-------------------------------------------------------------------------------------------
Clickable items --- Это три категории интерактивных элементов,по которым мы можем щелкнуть
чтобы совершить какие-то действия: заголовки аккорденов,вкладки,кнопки,даты на календаре
виджета DatePicker,значки,кнопки в диалоговом окне и пункты раскрывающегося списка.
Вообщем три вкладки	соостветствуют трем состояним: по умолчанию,при наведении,Активное 
состояние(при клике и выборе вкладки).К каждому из этих состояний мы можем добавить 
следующие параметры:цвет фона,текстура фона,непрозначность текстуры фона,цвет границы,
цвет текста и цвет значка	
-------------------------------------------------------------------------------------------	
	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
Категории Highlight(выделение) и Error --- на самом деле сами по себе не форматируют 
виджеты.Тем не менее они создают два класса CSS: .ui-state-highlight и
.ui-state-error которые мы можем применить к виджетам или к любому элементу на странице
Например,виджет Dialog позволяет назначить имя класса диалоговому окну.Поэтому,если бы нам
понадобилось открыть особое диалоговое окно со стилем Highlight мы бы просто передали имя 
класса(без точки) функции dialog():

$("#dialogDiv").dialog({
	dialogClass: "ui-state-highlight"
}); 

//Своего рода подсказка или что-то вроде того

Кроме того мы можем использовать стиль  .ui-state-error,чтобы отформатировать элемент 
страницы,который необходимо выделить.Например,если кто-то неправильно заполнил элемент
формы,мы можем выбрать метку этого элемента и динамически применить к нему класс error:
	
$("#userNameLabel").addClass("ui-state-error");	

В данном случае мы даже не используем виджет jQuery,только класс.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	
	
-------------------------------------------------------------------------------------------
Modal Screen for Overlays --- 	При открытии модального окна плагин затемняет остальную
часть экрана и не позволяет ничего выбрать кроме вызванного диалогового окна.Мы можем
управлять внешним видом этого экрана с помощью таких параметров, как цвет фона,текстура
и непрозрачность.Другими словами настраивать,вид модального окна(вместо полупрозрачного 
цвета,можем к примеру поставить крассный цвет)
-------------------------------------------------------------------------------------------	
	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
Drop Shadows (Тени) --- Не обращаем внимания на эту категорию,она не применяется к виджетам
jQuery UI,и даже к виджету Tooltip у которого есть тень.Странно,но факт	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	
	
/*
	При использовании приложения ThemeRoller, URL-адрес в адреснойстроке меняется,
каждая модификация темы сопровождается изменением URL-адреса,для того чтобы мы легко могли
скопировать ссылку и отправить скажем другу для доработки новой темы.
*/	
	
После создания новой темы.Нажимаем Download и скачиваем тему.Мы можем заново все 
переустановить,а если мы просто хотим обновить внешний вид - все что нам нужно это 
новые стили.Главное нужно убедится что мы выбрали теже варанты при скачивании(виджеты,
взаимодействия и эффекты) которые используются в данный момент.Например,если на сайте мы
используем все виджеты jQuery UImно на странице конструктора загрузки сбрасываем флажок
соответствующий виджету Dialog,то мы не скачаем CSS-код,необходимый для стилизации данного
виджета.Точно также если мы используем только виджет Dialog,но загружаем весь набор функций
jQuery UI, то в новом файле CSS будет содержатся намного больше CSS-кода,чем нам на самом 
деле нужно,а это значит что посетителям придется тратить время на скачивание ненужного 
кода CSS.После скачивания нам нужно заменить только папку images и файлы CSS:

1.Заменим старый файл или файлы CSS плагина jQuery UI новой темой.(jquery-ui-min.js)
2.Заменим старую папку images новой папкой images.В разных темах используются различные
цветные значки,а также различные стили фоновых узоров.Значки и графика новой темы,вероятно 
не будут соответствовать нашей старой теме,поэтому нам придется заменить старые изображения
 
	
При згрузке новой темы следует убедится в том,что версия jQuery UI не изменилась.Если
плагин jQuery UI обновился к новой версии,то нужно заменить не только стили но и сам файл
javaScript(jquery-ui-min.js)	
	
	
Стили меняются в зависимости от темы.Эти стили находятся в файле query-ui-theme.css	
	
						Правильное переопределение стилей jQuery UI	
Темы jQuery UI хорошо выглядят но не всегда могут нам подходит.Например при использовании
ThemeRoller у нас есть только один вариант задавания шрифтов для диалоговых окон,панелей 
выбор дат,вкладках...Но если нам нужно использовать один шрифт для вкладки,а другой для 
содержимого панели то возникает проблема.Существует несколько подходов к решению этой
проблемы,однако мы не должны редактировать сами CSS-файлы плагина jQuery UI.Потому что
CSS-стили изменяются при выходе новой версии jQuery UI.Поэтому после выхода новой версии
и обновления все наши изменения пропадут.Даже если мы не обновляете плагин мы не сможем
использовать приложение ThemeRoller для создания нового дизайна без необходимости 
скопировать внесенные нами изменения в новый файл темы.
Вместо этого нужно добавть изменения в новый файл со стилями.Это может быть скопированные 
стили плагина jQuery UI,но проще всего будет добавить стили в главную таблицу стилей нашего
сайта.Для этого следует поместить нашу таблицу со стилями после стилей плагина jQuery UI

<link href="css/jquery-ui.min.css" rel="stylesheet">
<link href="css/site.css" rel="stylesheet">

Созданный нами стиль будет иметь приоритет,поскольку он создан после такого же стиля в таблице
	


						Добавления виджета Droggable на веб-страницу
Мы можем превратить в перетаскиваемый элемент любую часть страницы.Конечно,перемещение того
или иного элемента должно иметь смысл.Например,обеспечение подвижности абзацев текста не 
имеет смысла.Однако обеспечение подвижности всплывающих диалоговых окон имеет смысл.

Способ применения:

1.Нужно прикрепить файлы jQuery,а также файлы плагина jQuery UI, CSS и javaScript
2.Добавить функцию $(document).ready():

$(document).ready(function(){
	
});
	
3.Используем jQuery,чтобы выбрать элемент страницы и применить к нему виджет Draggable:
	
$(document).ready(function(){
	$("#dialog").draggable();
});	

В данном случае мы выбираем один элемент используя селектор идентификатора.Если нужно 
выбрать несколько элементов и сделать их подвижными,нужно создать класс и дать его 
нужным обьектам которые должны быть подвижными и применить функцию .draggable()

4.Сохраним.Вот и все что нужно сделать
	
	
									Параметры виджета Draggable:
Draggable --- Это очень мощный виджет предусматривающий множество параметров.

------------------------------------------------------------------------------------------
axis --- С помощью данного свойства мы можем ограничить перемещение перетаскиваемого 
элемента только направлениями влево и вправо или вверх вниз.Например,нам нужно перетащить
элемент вдоль временной шкалы.Нам необходимо,чтобы перетаскиваемый элемент оставался 
расположенным вдоль этой шкалы и не смещался с нее.Используем значение "x"(чтобы элемент
передвигался только влево и вправо) или "y"(чтобы элемент мог быть перемещен только 
вверх и вниз по странице):

axis: "x"
------------------------------------------------------------------------------------------
	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
cancel --- Этот параметр позволяет	предотвратить перетаскивание при щелчке по конкретному
элементу.Например,мы создали окно с обьявлением,которое посетители могут перетаскивать по
экрану.Это окно имеет заголовок и несколько абзацев текста,содержащих такую важную 
информацию,как адрес и номер телефона.Обычно,если посетитель пытается выбрать почтовый 
адресс(например,чтобы скопировать и вставить в строку сервиса Google Maps),то вместо этого
он в конечном итоге перетаскивает обьявление в окне.Мы можем предотвратить перетаскивание
этих абзацев с помощью параметра cancel:

cancel: "p"

Теперь если кто-то щелкнет по абзацу внутри обьвления,он не будет инициировать 
перетаскивание и сможет легко выбрать и скопировать текст.(Если мы ставим .draggable() 
скажем на "p" то мы не сможем выделить этот текст и скопировать,поэтому нужно поставить
отмену перетаскивания на текст)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	
	
------------------------------------------------------------------------------------------
connectToSortable --- Данный параметр позволяет нам указать набор сортируемых элементов
к которым можно добавить перетаскиваемый элемент.Плагин jQuery UI предусматривает 
взаимодействие sortable,позволяющий нам сгруппировать элементы,которые можно сортировать,
например список дел.Чтобы использовать этот параметр просто укажим идентификатор для 
элемента,который мы уже превратили в сортируемую группу:

connectToSortable: "#toDoList"	
------------------------------------------------------------------------------------------	
	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
containment --- Мы можем предотвратить возможность перетаскивания элемента за пределы 
контейнера.Например,мы создаем действие "Магнит на холодильник" позволяющее посетителю
перетаскивать слова,чтобы составить предложение.Мы можем добавить множество небольших
перемещаемых элементов div,содержащих слова и определить область страницы,где посетитель 
может построить фразу.Нам нужно убедится,что он не сможет перетащить слова,например,на
навигационную панель,заголовок или нижний колонтитул.Параметр containment позволяет 
ограничить взаимодействие небольшой областью страницы.Данный параметр может принимать
несколько значений:

1.Селектор.Если мы укажим имя селектора,то плагин jQuery UI будет удерживать 
перетаскиваемый обьект в границах этого элемента.Например,если на нашей странице есть 
элемент div с идентификатором refrigerator,то мы можем удерживать перетаскивыемый 
элемент внутри этого элемента div используя следующий код:

containment: "#refrigerator"

2. parent,document или window --- Чтобы удерживать перетаскиваемый элемент внутри его
родительского элемента,используйте в качестве значения фрагмент parent.Например,если 
перетаскиваемым элементом является div внутри другого элемента div,и мы хотим ограничить
перемещение областью этого внешнего элемента div, используем значение parent:

containment: "parent" 

Значения document и window практически одинаковы за исключением того, что 
document - ограничивает область перетаскивания площадью документа,а значение 
window - позволяет перетаскивать элемент частично за пределы окна 

3.Массив координат.Мы можем предоставить массив координат,которые соответствуют левой
верхней и правой нижней точкам контейнера.Мы предоставляем значения в пикселях 
относительно верхнего левого угла окна браузера.Например,нам нужно чтобы перетаскивание 
происходило только в области котороя начинается в точке находящейся в 50 пикселах от 
левого края и 100 пикселов от верхнего края и заканчивается в точке,находящейся в 500
пикселах от левого края и 600 пикселов от верхнего края.В этом случае мы зададим эти 
значения следующим образом:

containment: [50, 100, 500, 600]
/*
	грубо говоря 1е значение(50) -это от левого край отступ
	2е значение 100 - это отступ от верхнего края(top)
	3е значение 500 - это доступные пиксели по горизонтали
	4е значение 600 это вниз доступные пиксели по вертикали	
*/
Поскольку такое использование координат требует передачи точных значений,это не очень 
хорошо подходит для резинового дизайна.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	
	
------------------------------------------------------------------------------------------
cursor --- Мы можем обеспечить изменение внешнего вида указателя мыши при перетаскивании.
Обычно он имеет вид стрелки(если мы щелкаем по пустому месту элемента) или тектового 
курсора(если мы щелкнули по тексту в заголовке).Тем не менее мы можем приказать плагину 
jQuery UI использовать другой вид курсора при перетаскивании элемента,передав параметр 
cursor с действительным значением CSS.Полный список(developer.mozilla.org/en-US/docs/Web/CSS/cursor)
однако чаще всего при перетаскивании используются такие значения как pointer,crosshair,
default (стрелка):

cursor: "pointer" 
------------------------------------------------------------------------------------------	
	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
cursorAt --- Мы можем контролировать положение указателя мыши  при перетаскивании элемента.
Обычно он остается в том месте,на которое посетитель изначально его навел.Например,если
мы захватите перетаскиваемый элемент div за его нижнюю часть,то указатель мыши останется 
в нижней части этого элемента div в процессе его перемещения по экрану.Тем не мене мы 
можем захотеть,чтобы курсор находился в определенном месте,например,на изображении маркера
который мы добавили к перетаскиваемому элементу.В этом случае нам следует предоставить 
параметру cursorAt обьект.Этот обьект может содержать значение,относящиеся к свойствам 
left,right,top,bottom.Например,для того чтобы при перемещении элемента указатель мыши 
находился в верхнем левом углу элемента,укажим свойства left и top следующим образом:

cursorAt: {
	left: 5,
	top: 5
}

Мы не можем одновременно установить свойства left и right,поскольку они соответствуют 
разным положениям на одной и той же оси.По этой же причине мы не можем одновременно 
использовать свойства top и bottom.Тем не менее мы можем использовать по одному значению
на каждой оси(left или right и top или bottom).Можно также указывать одно значение:

cursorAt: {
	top: 5
}	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	

------------------------------------------------------------------------------------------
disabled --- Определяет,является ли элемент перетаскиваемым.Если значение этого свойства 
является true,то мы не сможем перетащить элемент.Этот параметр можем пригодится после того
как кто-нибудь притащит элемент.Например,мы можем позволить посетителю перетащить элемент
в корзину покупок,но не из нее.В этом случае мы можем применить данный параметр после 
завершения оперпции перетаскивания.	
------------------------------------------------------------------------------------------	

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
grid --- Обычно при перетаскивании элемента	 он свободно перемещается в окне.Тем не менее
мы можем захотеть,чтобы элемент перемещался на определенное количество шагов по 
горизонтали и вертикали.Например,представьте онлайн-игру в шашки.У нас есть сетка 
площадью 8 х 8 клеток.Шашки можно перетаскивать в границах этой сетки,однако,если бы их 
можно было перетащить в любое место,это выглядело бы неаккуратно.Нам нужно,чтобы шашки 
передвигались по клеткам на доске.Плагин jQuery UI позволяет обеспечить перемещение 
элемента по горизонтали и вертикали на конкретное расстояние.Параметр grid принимает,
массив состоящий из двух чисел.Первое число соответствует расстоянию по горизонтали,а
второе - по вертикали.Например,нам нужно чтобы при перетаскивании влево или вправо
элемент перемещался на расстояние 50 пикселов,а при перетаскивании вверх или вниз - на 
расстояние 100 пикселов.В этом случае мы можем настроить параметр grid следующим образом:

grid: [50,100]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	
	
------------------------------------------------------------------------------------------
handle --- Мы можем ограничить область,по которой может щелкнуть посетитель для 
перетаскивания элемента.Как правило,мы можем щелкнуть в любом месте элемента,чтобы 
перетащить его.Тем не менее мы можем огранчить эту область только заголовком или 
визуальным индикатором перемещения.Испольщуем параметр handle,чтобы определить селектор 
в перетаскиваемом элементе,который будет выступать в качестве маркера перетаскивания.
Например,мы можем сделать так,чтобы перетащить элемент можно было щелкнув по его заголовку,
например по элементу h2:

handle: "h2"

//пример https://jqueryui.com/resources/demos/draggable/handle.html	
------------------------------------------------------------------------------------------	
	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
helper --- 	Возможно мы не хотим,чтобы пользователь перемещал по страницу сам 
перетаскиваемый элемент.Например,мы создали страницу с покупательской корзиной.На этой
странице отображаются изображения товаров,и посетители могут добавить эти товары в корзину
перетаскивая соответствующие изображения на значок в виде корзины покупок.В этом случае,
мы не хотим чтобы покупатель перетаскивал в корзину сами изображения товаров,поскольку это
привело бы к перемещению изображения по странице.Вместо этого нам нужно чтобы покупатель 
просто перетащил копию изображения,не затрагивая исходное изображение.В этом случае мы 
можем указать для параметра helper значения "clone":

helper: "clone"

Более сложный вариант заключается в передаче параметра helper функции,генерирующей 
HTML-код,который плагин jQuery UI должен отобразить при перетаскивании мыши.Например,для
отображения пользовательского вспомогательного элемента div(вместо перетаскивания 
фактического HTML-элемента) мы можем задать параметр helper следующим образом:

helper: function(event) {
	return $("<div class='ui-widget-header'>Я пользовательский вспомогательный элемент</div>");	
}

То что мы предоставим в качестве возвращаемого значения,плагин jQuery UI отобразит под 
указателем мыши пользователя.Мы должны возвратить обьект jQuery,поэтому для создания 
помощника мы должны использовать функцию $().Простая строка HTML-кода не сработает
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
opacity --- При перетаскивании элемента мы можем изменить степень его прозрачности.
Например,мы можем задать значение 50% чтобы придать элементу призрачный вид.Эта техника 
является популярным способом показать,что мы перемещаем элемент с места на место.
Используем значение от 0 до 1.Этот параметр работает так же как свойство CSS opacity:

opacity: 0.5
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

	
------------------------------------------------------------------------------------------
revert --- Этот параметр определяет,возвращается ли перетаскиваемый элемент в исходное
положение,после того как пользователь прекращает его перемещение.Как правило,для этого 
параметра устанавливается значение false,а это значит,что после того как мы перетащили
элемент,он остается там где мы его оставили.Это обычно хорошо для перетаскиваемых или 
диалоговых окон,поскольку позволяет перетащить окно и освободить место на странице для
чего-то другого.Тем не менее иногда нам требуется вернуть перетаскиваемый элемент в 
исходное положение.Например,если мы используем виджет Droppable,то мы возможно захотим,
чтобы перемещаемый элемент вернулся в исходное положение,если он не попал в определенное
место.Мы можем перетащить эскизы изображений в разные папки на странице или значок в виде
мусорной корзины.Тем не менее пользователь может перетащить изображение вверх на заголовок 
страницы или в нижний колонтитул,а не в одну из предназначенных папок или в корзину.В этом
случае нам нужно,чтобы изображение вернулось в иходное место на странице,а не загораживало 
заголовок или нижный колонтитул.
Параметр revert принимает несколько различных значений:значение true - заставляет 
перетаскиваемый элемент всегда возвращаться в исходное положение.
Значение invalid - заставляет перетаскиваемый элемент возвращатся в исходное положение 
только в том случае если он не был помещен на допустимый бросаемый элемент(виджет Droppable):

revert: "invalid"

Наконец мы можем передать этому параметру функцию.Если эта функция возвратит значение true,
то элемент вернется в исходное положение.Мы можем использовать функцию в основанной на 
javaScript игре шашки,например:если игрок перемещает фигуру и бросает ее на другую клетку 
доски,функция может проверить был ли этот ход действительным(например,не занята ли клетка 
другой фигурой и не передвинута она дольше чем это допустимо).В этом случае функци 
возвратит значение true, и плагин jQuery UI переместит фигуру в исходное положение:

revert: function() {
	//выполнить тестирование в этой функции и возвратить значение true,чтобы вернуть 
	//элемент в исходное положение или false,если элемент может остатся там,где 
	//пользователь оставил его 
}
------------------------------------------------------------------------------------------	
	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
revertDuration --- Когда плагин jQuery UI возвращает бросаемый элемент(перемещает его в 
исходное положение),он анимирует его передвижение.По умолчанию применяется значение 500
миллисекунд или полсекунды.Это выглядит здорово,но мы можем ускорить анимацию или 
замедлить ее.Параметр revertDuration принимает числовое значение соответствующее 
количеству миллисекунд:

revertDuration: 250
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	
	
------------------------------------------------------------------------------------------
scope --- Позволяет сгруппировать перетаскиваемые и бросаемые элементы в наборы.Например,
на нашей странице есть календарь.Пользователи могут перетаскивать событие с одного дня 
на другой.Все перетаскиваемые события принадлежат календарю,поэтому мы можем указать для 
данного параметра значение calendar:

scope: "calendar"
 
Строка "calendar" в данном случае не относится к селектору или элементу на странице.Это 
просто имя,используемое для группировки перетаскиваемых и бросаемых элементов.Мы можем 
использовать любой термин,просто нужно убедится в том,что мы используем то же имя для 
параметра scope примененного к бросаемому элементу(виджет Droppable)
Нам нужно устанавливать параметр scope только в том случае,если на странице присутствуют 
разные типы перетаскиваемых и бросаемых элементов.Например,если на странице с календарем 
у нас есть еще и мозаика, то мы не захотим,чтобы пользователи перетаскивали события из 
календаря на мозаику,а кусочки мозаики - на календарь.Указав различные параметры scope 
для каждой группы,мы можем контролировать какие перетаскиваемые элементы могут быть 
брошены на другие элементы.	
------------------------------------------------------------------------------------------	
	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
snap --- Мы можем сделать так,чтобы перетаскиваемый элемент привязался к другому элементу 
страницы или к другому перетаскиваемому	элементу.Например,мы создали игру,в которой 
необходимо составить исходную фотографию из дюжины фрагментов.Мы можем сделать так,чтобы 
один фрагмент головоломки привязывался к другому фрагменту,используя данный параметр,
который может принимать одно из двух возможных значений:

Значение true - сообщает плагину о том,что перетаскиваемый элемент должен привязатся к 
другому перетаскиваемому элементу на странице.Это хорошо работает в случае с мозаикой,
состоящей из множества отдельных фрагментов.

Имя селектора.Имя любого селктора на странице.Например,если мы хотим,чтобы перетаскиваемый
элемент привязывался к элементу div с идентификатором photoholder,мы можем использовать 
следующий код:

snap: "#photoholder" 

//Странное свойство,работает как пазл из мозайки https://jqueryui.com/resources/demos/draggable/snap-to.html
//Просто при наведении на указанный нам обьект,он как пазл становится четко на него
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	
	
------------------------------------------------------------------------------------------
snapMode --- Этот параметр работает только при использовании параметра snap и принимает 
одно из трех ключевых слов: inner,outer,both.Если мы хотим,чтобы перетаскиваемый элемент 
привязывался только тогда,когда он находится внутри элемента,используем ключевое слово 
inner,которое заставляет перетаскиваемый элемент привязываться к любому из внутренних 
краев элемента,предусмотренного параметром snap

Используем ключевое слово outer,если мы хотим,чтобы элемент привязывался к внешнему краю
другого элемента.Этот параметр идеально подходит для таких вещей как мозаика,фрагменты
которой должны привязыватся друг к другу.

Мы можем обеспечить привязку элемента к внешнему или внутреннему краю другого элемента,
используя значение both:

snapMode: "both" 
------------------------------------------------------------------------------------------	
	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
snapTolerance --- определяет,насколько близко должен распологатся перетаскиваемый элемент,
чтобы произошла привязка.Чем больше значение данного параметра,тем дальше может быть 
расположен элемент,прежде чем он попытается привязаться к другому элементу.Для данного 
параметра следует указывать значение в пикселах:

snapTolerance: 30  	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	
	
------------------------------------------------------------------------------------------
zIndex --- 	Данный параметр позволяет задать значение zIndex для перетаскиваемого элемента.
Свойство CSS zIndex определяет порядок размещения элементов на странице.Элемент с более 
высоким параметром значением zIndex будет находится поверх всех элементов страницы,которые
он перекрывает.Это свойство очень удобно,когда мы хотим удостоверится в том,что при 
перемещении элемента по странице он всегда будет распологаться поверх остального 
содержимого:

zIndex: 100
------------------------------------------------------------------------------------------	
	
//api.jqueryui.com/draggable/ --- Полный список	параметров виджета Draggable

	
								События виджета Draggable	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
create --- Это событие 	запускается каждый раз,когда мы используем функцию draggable() 
для создания нового перетаскиваемого элемента.Мы можем использовать это событие для вызова
всплывающего диалогового окна с инструкцией "Перетащите этот товар в свою корзину".Это 
событие срабатывает только один раз при создании виджета Draggable.Мы можем использовать 
это событие,передав свойство create с функцией методу draggable():

$(".product").draggable({
	create: function(event) {
		//Код
	}
}); 
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	
	
------------------------------------------------------------------------------------------
start --- Данное событие срабатывает,как только пользователь начинает перетаскивать 
элемент.Мы назначаем это событие в качестве свойства обьекта,содержащего параметра виджета
Draggable.Имя собырия, start представляет собой имя свойства,а значением должна быть 
функция,которая выполняется,когда посетитель начинает перетаскивать элемент.Например,у нас
есть элемент div с идентификатором raceCar.Мы можем превратить этот элемент в 
перетаскиваемый и назначить ему событие start следующим образом:

$("#raceCar").draggable({
	start: function(event, ui) {
		//Код
	}
});

Функция назначенная для собития start предусматривает два параметра: event и ui.Параметр 
event - является обьектом события jQuery и содержит подробную информацию об элементе,
которому назначено событие,экранные координаты указателя мыши и прочие данные.
Параметр ui - это обьект с четырьмя свойствами:

1.Свойство ui.helper --- является обьектом jQuery,содержащим ссылку на элемент который 
перетаскивается по экрану.Как правило, это тот же элемент к которому мы применили метод 
draggable().Тем не менее  так бывает не всегда.Если мы указали для параметра helper 
значение "clone" или передали ему функцию для генерирования вспомогательного HTML-кода,
то свойство ui.helper ссылается на элемент,отличный от перетаскиваемого: либо на его 
копию,либо на обьект jQuery,созданный в качестве  вспомогательного элемента.Это полезно,
например, в случае с корзиной покупок,когда перемещение товара с одного места в корзину 
нарушает макет страницы.Вместо этого,покупатель должен перетащить в корзину копию 
изображения товара.Используем свойство ui.helper, когда мы хотим выполнить действие над 
элементом,который визуально перетаскивается по странице.Например,нам нужно чтобы при 
перетаскивании размер элемента увеличивался в два раза.В этом случае мы можем задать 
свойство CSS для обьекта ui.helper следующим образом:

$("#photo").draggable({
	start: function(event, ui) {
		ui.helper.css("transform", "scale(2)");
	}
}); 


2.Свойство ui.position --- представляет x и y координаты левого верхнего угла элемента 
helper(который перетаскивается по экрану).Это значение свойства CSS position и на него 
может повлиять положение родительского элемента.Например,если у нас есть перетаскиваемый 
элемент внутри div,и этот div абсолютно позиционирован на странице,то значение свойств 
left и top перетаскиваемого элемента будут указаны относительно левого верхнего угла 
позиционированного предка.Свойство ui.position является обьектом javaScript, состоящим из 
двух свойств top и left.Свойство top - это положение верхнего элемента,расстояния в 
пикселях.Свойство left - это положение левого края.Мы можем получить доступ к этим 
значением так: ui.position.top и ui.position.left.
//Например,можем ui.position.top взять в переменную и показывать ее значения,просто высчитывает расстояние

3.Свойство ui.offset --- также представляет обьект с двумя свойствами.Местоположение 
рассчитывается относительно левого верхнего угла окна браузера.Свойство ui.position и
ui.offset будут иметь одинаковые значения,если перетаскиваемый элемент не находится внутри
какого-либо другого элемента,чье свойство CSS position имеет значение absolute или 
relative.Свойство ui.offset.top определяет,на каком расстоянии от верхнего края находится
верхний край вспомогательного элемента.Свойство ui.offset.left определяет,на каком 
расстоянии в пикселах от левого края окна браузера находится перетаскиваемый обьект.


4.Свойство ui.originalPosition ---содержит те же два свойства top и left,как и ui.position,
и ui.offset.Тем не менее свойство ui.originalPosition указывает начальное положение 
перетаскиваемого элемента,то есть точку,в которой находился элемент перед тем,как 
пользователь начал его перетаскивать.Как и ui.position свойство ui.originalPosition 
зависит от позиционированных предков.
------------------------------------------------------------------------------------------
	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
drag --- перетаскиваемые элементы также активируют событие drag при их перемещении по 
экрану.Мы можем создать функцию,которая работает постоянно в процессе перетаскивания 
элемента.Например,это событие можно использовать,чтобы оставить искрящий след от обьекта
при его перемещении в окне.Поскольку это событие срабатывает множество раз при 
перетаскивании элемента,лучше попытатся ограничить обьем работы выполняемой функции.
Если в ответ на событие drag выполняется много сложных операций,то работа браузера может 
змедлится.Функцию события drag принимает те же два параметра,что и событие start,описанное 
ранее,event и ui.
Допустим мы хотим отобразить текущее положение перетаскиваемого элемента при его 
перемещении по экрану.Предположим,что для отображения этих значений на странице 
присутствуют два элемента span и идентификаторами left и top.В процессе перетаскивания 
элемента мы можем постоянно обновлять эти значения следующим образом: 

$("#raceCar").draggable({
	drag: function(event, ui) {
		$("#left").text(ui.position.left);
		$("#top").text(ui.position.top);
	}
});
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	
	
------------------------------------------------------------------------------------------
stop --- Событие stop виджета Draggable работает так же,как событие start за исключением 
того,что оно срабатывает когда пользователь прекращает перетаскивать элемент и отпускает 
кнопку мыши.Это не обязательно означает,что пользователь бросил элемент на соответствующее 
целевое место.Это также не означает что пользователь полностью завершил процесс 
перетаскивания элемента.Наример,пользователь мог щелкнуть по перетаскиваему элементу и 
начать его перемещение(срабатывает событие start),продолжить перемещать его по странице
(постоянно срабатывает событие drag),прекратить перетаскивание(срабатывает событие stop),
а затем щелкнуть по этому элементу снова и опять перетащить его,запустив все те же 
события.Мы можем использовать событие stop так же,как и событие start.Например,мы 
использовали  вышеприведенный код,чтобы обеспечить удвоение размера жлемента при его 
перетаскивании.Мы можем восстановить нормальный размер элемента при прекращении его 
перемещения с помощью следующего кода:

$("#photo").draggable({
	stop: function(event, ui) {
		ui.helper.css("transform", "scale(1)");
	}
}); 	
------------------------------------------------------------------------------------------	
	
									
									Виджет Droppable
Виджет Draggable бывает полезен для диалоговых окон или других,элементов страницы,которые 
мы можем перемещать по экрану.Тем не менее добавив виджет Droppable,мы можем создать 
интерактиваные приложения,в которых пертаскивание одного элемента на другой может привести
к некоторому результату.Выджеты Droppable полезны только в сочетании с виджетами Draggable.
Виджет Droppable работает как "область бросания" для перетаскиваемых элементов.Когда 
элемент бросается в эту область,виджет Droppable может также активировать дополнительный 
программный код.Мы можем превратить бросаемый элемент любой элемент страницы.Главное 
нужно дать посетителю понять что и куда бросать.
	
Способ применения:

1.Добавить файлы jQuery,а также файлы CSS javaScript плагина jQuery UI 
2.Добавим функцию $(document).ready():

$(document).ready({
	
});	

3.Используем jQuery,чтобы выбрать один или несколько элементов страницы и применить к ним 
виджет Draggable:
	
$(document).ready({
	$(".product").draggable();
});		
	
4.Используем jQuery,чтобы выбрать область бросания и применим к ней виджет Droppable:

$(document).ready({
	$(".product").draggable();
	$("#cart").droppable();
});		
	
Элемент страницы #cart теперь является областью бросания.Однако это только начало.Мы 
должны установить различные параметры бросаемого элемента для того,чтобы что-то произошло,
например,расчет общей суммы заказа при добавлении очередного товара в корзину.

5.Добавим параметры в функцию droppable():

$(document).ready({
	$(".product").draggable();
	$("#cart").droppable({
		activeClass: "highlight",
		drop: function(event, ui) {
			alert("Товар добавлен");
		}
	});
});		
	

								Параметры виджета Droppable	
Главная роль виджета Droppable - заключается в том,чтобы принимать элементы и самое 
главное,запускать при этом функции.

------------------------------------------------------------------------------------------
accept --- Данный параметр определяет,какие перетаскиваемые элементы могут быть добавлены 
в виджет Droppable.Мы можем назанчить селектор или функцию.Селектор соответствует 
селектору перетаскиваемого элемента.Например,если у нас множество изображений с классом 
photo и мы хотим иметь возможность бросить их на определенный элемент,то мы можем задать 
данный параметр следующим образом:

accept: ".photo"

//Другими словами мы разрешаем переносится только элементам с классом photo,никакие другие
//элементы не смогут переноится
------------------------------------------------------------------------------------------
	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
activeClass --- Мы можем выделить область бросания в прецессе перемещения перетаскиваемого 
элемента.Например,мы создали файловую систему,которая позволяет пользователям расматривать
файлы на сервере,перемещать их в другие папки,переменовывать их...Также предусмотрена 
возможность перетащить в корзину,чтобы удалить его.Мусорная корзина представляет собой 
виджет Droppable,а файл - виджет Draggable.Когда посетитель начинает перетаскивать файл,
мы можем применить класс который выделит муссорную корзину(например,меняет картинку на 
изображение муссорной корзины с открытой крышкой).Просто назначив имя класса(без точки):

activeClass: "highlight"	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	
	
------------------------------------------------------------------------------------------
disabled --- Данный параметр определяет,является ли элемент активной областью бросания.
Если значение этого свойства является true,то мы ничего не можем бросить на элемент.
Например,у нас есть область бросания,и мы хотим,чтобы пользователи могли бросить в нее 
только 5 элементов.После того как в области появится 5 элементов,мы отключаем эту область
чтобы пользователи больше не могли ничего в нее поместить(мы можем использовать событие 
drop,которая откчает область бросания):

$("#dropZone").droppable({
	disabled: true
});
------------------------------------------------------------------------------------------	

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
hoverClass --- Мы также можем применить класс,когда над областью бросания оказывается 
допустимый перетаскиваемый элемент.Например,мы можем добавить класс к мусорной корзине,
только когда над ней оказывается перетаскиваемый файл:

hoverClass: "openTrashcan"	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	
	
------------------------------------------------------------------------------------------
scope --- Данный параметр работает аналогично параметру Draggable(scope).Он позволяет 
группировать связанные виджеты Draggable и Droppable.

scope: "calendar"

Используемое в данном примере имя "calendar" не имеет особого значения.Мы можем выбрать 
любое имя,только нужно использовать то же самое имя для связанных виджетов Draggable и
Droppable 	
------------------------------------------------------------------------------------------	
	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
tolerance --- 	Этот параметр определяет,когда перетаскиваемый элемент считается 
находящимся над областью бросания,и предусматривает четыре возможных значения:

1. "fit" ---перетаскиваемый элемент должен полностью находится в пределах области бросания

2. "intersect" --- перетаскиваемый элемент должен перекрывать область бросания не менее 
чем на 50% в обоих направлениях.Другими словами,большая часть перетаскиваемого элемента 
должна находится в нутри бросания.Это значения является нормальным для виджета Droppable 

3. "pointer" --- в пределах области бросания должен находится только указатель мыши

4. "touch" --- перетаскиваемый элемент должен всего лишь касатся одной из сторон области 
бросания.

Параметр "fit" хорошо подходит для подтверждения того,что пользователь действительно хочет 
поместить перетаскиваемый элемент в область бросания,однако он требует,чтобы 
перетаскиваемый элемент был меньше размера области в которую мы перетаскиваем.Наиболее 
распостраненным значением является "intersect" поскольку он не требует от пользователя 
чрезмерной точности:

tolerance: "intersect"
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	

//api.jqueryui.com/droppable/ --- Полный список параметров виджета Droppable


								Cобытия виджета Droppable 
Самое интересное при работе с виджетами Droppable состоит в том,чтобы  выполнить некоторые 
действия,когда элемент попадает в область бросания,перемещается на нее или из нее.Например,
мы можем расчитывать и отображать общую стоимость покупки каждый раз,когда покупатель 
помещает товар в корзину,а затем пересчитывать эту стоимость если покупатель вытаскивает 
товар из нее.

------------------------------------------------------------------------------------------
drop --- Данное событие вызывает функцию,когда элемент помещается в области бросания.
Бросаемый элемент должен быть допустимым обьектом,то есть обьектом который указан в 
параметре accept или имеет тот же параметр scope, что и область бросания.Например,у нас 
есть элемент div с идентификатором trashcan.Мы можем превратить этот элемент div в область
бросания и назначить ему событие drop следующим образом:

$("#trashcan").droppable({
	drop: function(event, ui) {
		//Код
	}
});

Функция,назначенная событию drop,имеет два параметра: event и ui.
Параметр event - является обьектом события.
Параметр ui соответствует параметру,используемому в событиях виджета Draggable и имеет 
свойства:

1.Свойство ui.helper --- является обьектом jQuery,содержащим ссылку на элемент,который 
визуально перетаскивается по экрану и соответствует свойству ui.helper,описанному в 
разделе "Событие start" ранее.Используем свойство ui.helper,когда мы хотим выполнить 
действие над предметом,который визуально перетаскивается по странице.Например,если нам 
нужно чтобы элемент "взрывался" при попадании в мусорную корзину:

$("#trashcan").droppable({
	drop: function(event, ui) {
		ui.helper.hide("explode");
	}
});

Значение "explode" в данном коде,делает элемент взрываемым

2.Свойство ui.draggable --- является обьектом jQuery,содержащим ссылку на элемент,к 
которому применен метод draggable().Во многих случаях значение данного свойства совпадает 
со значением свойства ui.helper.Однако если мы укажем для свойства helper значение "clone"
то по экрану станет перемещатся клонированный элемент,а исходный элемент будет оставатся 
на месте.Данное свойство также может пригодится в случае со страницей оформление заказа.
Допустим,мы создали систему,которая отслеживает запас товара.Страница каталога может 
отображать фотографию товара и метку с указанием оставшегося количества,например 10.Когда
покупатель щелкает по изображению товара,он перетаскивает в корзину его клон.Когда он 
помещает этот клон в корзину,функцию drop может обновить элемент ui.draggable,чтобы 
количество оставшегося товара уменьшилось на единицу(и в тоже время нужно использовать 
технологию Ajax).

drop: function(event, ui) {
	ui.draggable.hide("explode");
}
//К примеру этот код удалит как клонированный элемент так и оригинал и он исчезнет со страницы


3.Свойство ui.position --- предоставляет x и y координаты положение верхнего левого угла 
вспомоготельного элемента,когда он помещается в целевую область.Оно анологично свойству 
описаному в разделе "События start" ранее.

4.Свойство ui.offset --- анологично свойству описаному в разделе "События start" ранее

5.Свойство ui.originalPosition --- анологично свойству описаному в разделе "События start" ранее

К примеру игра в шашки,мы после перетаскивани фыгуры нельзя ее вернуть обратно,мы можем 
отключить перетаскивание после его попадания в область бросания:

$(".square").drop({
	drop: function(event, ui) {
		ui.helper.draggable({
			disabled: true
		});
	}
});
------------------------------------------------------------------------------------------

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
activate --- Когда пользователь начинает перетаскивать элемент,являющийся допустимым для 
области бросания(accept и scope), срабатывает событие activate.Мы можем добавить 
программный код для обеспечения реакции на это событие.Например,мы создали веб-приложение,
которое позволяет пользователю перетащить одну или несколько фотографий на элемент div,а 
затем щелкнуть по кнопке "Отправить",чтобы отправить эти фотографии друг другу по 
электронной почте.Мы можем обеспечить появление в области бросания метки 
"Бросьте фотографию сюда",когда пользователь начинает перетаскивать фотографию.Мы можем 
добавить в событие activate функцию,которая будет создавать в области бросания надпись 
"Бросьте фотографию сюда".Если предпложить,что область бросания являет элемент div с 
идентификатором photoZone,то мы можем добавить сообщение в область бросания перетаскивании 
фото следующим образом:

$("#photoZone").droppable({
	activate: function(event, ui) {
		$(this).append("<p id='dropMessage'>Бросьте фотографию сюда!</p>");
	}
});
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

------------------------------------------------------------------------------------------
deactivate --- это противоположность события activate.Оно запускает функцию,когда 
пользователь прекращает перетаскивание допустимого элемента,то есть отпускает кнопку мыши.
Мы можем использовать это событие,чтобы отменить действие выполняемое событием activate.
Например,чтобы добавить сообщение в область бросания в процессе перетаскивания элемента,
а затем удалить это сообщение,когда пользователь прекращает перетаскивание,мы можем 
использовать следующий код: 

$("#photoZone").droppable({
	activate: function(event, ui) {
		$(this).append("<p id='dropMessage'>Бросьте фотографию сюда!</p>");
	},
	deactivate: function(event, ui) {
		$("#dropMessage").remove();
	}
});
------------------------------------------------------------------------------------------
								
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
over --- Мы можем запустить функцию,когда посетитель перетаскивает элемент над областью
бросания.Событие over срабатывает,как только перетаскиваемый элемент оказывается над 
областью бросания перед тем,как посетитель бросит его там.Например,мы можем использовать 
это событие,чтобы добавить сообщение,отображаемое если нерешительный покупатель делает 
паузу,прежде чем бросить товар в корзину: "Вы знаете,что будете отлично смотрется в этих туфлах.Купите их"
Или допустим,мы создали мусорную корзину, и при наведении на музорную корзину,она 
открывается.После бросания элемента в корзину мы можем использовать событие drop,чтобы 
заменить изображение пустой корзины изображением корзины,заполненной мусором.

$("#trashcan").droppable({
	over: function(event, ui) {
		$("#trashCanImage").attr("src", "images/open-lid-can.png");
	}
});

//В данном примере мы просто заменяем одно изображение другим
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

------------------------------------------------------------------------------------------
out --- Мы можем запустить функцию,когда посетитель удаляет элемент из области бросания.
Например покупатель бросил товар в корзину,и в этот момент мы рассчитываем общую стоимость 
покупки.Затем,когда покупатель решает,что он больше не заинтересован в этом товаре,он 
вытаскивает его из корзины.Событие out позволяет вычесть стоимость удаленного товара из 
общей суммы покупки:

$("#shoppingCart").droppable({
	drop: function(event, ui) {
		//выполнить вычесления,чтобы обновить общую сумму
	},
	out: function(event, ui) {
		//вычесть стоимость товара из общей суммы
	}
});
------------------------------------------------------------------------------------------


	
							Сортировка элементов страницы
Плагин jQuery UI также предусматривает виджет для работы со списками,например,со списками 
дел,музыкальными плейлистами,а также со списками внутри списков,вроде каталогов внутри 
папок.Виджет Sortable позволяет легко изменить порябок элементов в группе,просто перетащив
элемент на новое место.Этот виджет может пригодится,например,для управления списком 
воспроизведения,пользователи могут создать свой собственный плейлист,перетащив композиции
в список,а также изменить их порядок,перетащив элемент списка на новое место.	
	
Способ применения:

1.Нужно добавить на страницу jQuery,а также файлы CSS и javaScript плагина jQuery UI	
2.Добавим на веб-страницу элемент контейнер.Это может быть неупорядоченный список или 
элемент div:

<ul id="playlist">
	
</ul>
	
3.Добавим элементы в контейнер.В случае	с неупорядоченным или упорядоченным списком это 
будет серия элементов li.Элементы,содержащиеся в контейнере,можно перетаскивать на новое 
место в списке.В элемент div мы можем поместить изображения,абзацы или другие элементы 
div,которые станут сортируемыми элементами виджета:

<ul id="playlist">
	<li>My Way -- Frank Sinatra</li>
	<li>Like a Rolling Stone -- Bob Dylan</li>
	<li>Respect -- Aretha Franklin</li>
</ul>

4.Добавим $(document).ready() на нащу страницу:

$(document).ready(function(){
	
});

5.Выбираем элемент-контейнер добавленного в шаге 2:

$(document).ready(function(){
	$("#playlist").sortable();
});

Этот фрагмент кода выбирает элемент-контейнер(тег ul,в шаге 3) и делает все содержащиеся
в нем элементамы сортируемыми.

6.Добавляем параметры в функцию sortable().Например:

$(document).ready(function(){
	$("#playlist").sortable({
		opacity: 0.5,
		placeholder: "ui-state-highlight"
	});
});

								Параметры виджета Sortable
------------------------------------------------------------------------------------------
axis --- С помощью свойства axis мы можем ограничить перемещение сортируемого элемента
только направление слева направо или сверху вниз.Например,мы создали горизонтальную группу
элементов div,которую пользователь может переупорядочить в процессе игры.Мы можем сделать 
так,чтобы эти элементы перемещались только слева направо.Используем значение "x" чтобы 
задать значение слева направо или "y" чтобы задать направление сверху вниз:

axis: "x" 			
------------------------------------------------------------------------------------------			

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
cancel --- Данный параметр позволяет предотвратить перетаскивание обьекта при щелчке по 
конкретному элементу.Например,у нас есть список воспроизведения(неупорядоченный список).
Рядом с названием каждой песни есть значок в виде мусорной корзины,по которому 
пользователи могут щелкнуть,чтобы удалить песню из списка.Однако если пользователь 
захватит этот значок,то он сможет перетащить песню в новое место в списке вместо ее 
удаления.Чтобы элемент внутри сортируемого виджета не мог использоватся в качестве маркера 
перемещения,передадим селектор параметру cancel:

cancel: ".trashcan"

Теперь,если пользователь щелкнет по значку в виде мусорной корзины(trashcan- значок),он не 
сможет инициировать перетаскивание.Мы также можем указать несколько элементов,разделив их 
запятыми:

cancel: ".trashcan, .addToFavorites" 
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
			
------------------------------------------------------------------------------------------
connectWith --- Позволяет указать селектор других сортируемых элементов(другого списка),
в которые мы можем перетащить элемент.Например,у нас есть на странице два списка: список 
пожеланий,содержащий товары,которые мы хотели бы купить и список товаров,помещенных в 
корзину,которые мы намерены приобрести.Мы можем решить переупорядочить список пожеланий,
например,переместить самые желанные товары в верхнюю часть списка, и при этом иметь 
возможность перетащить элемент из списка пожеланий в список товаров,находящихся в корзине.
В этом случае у нас будут два разных списка,к каждому из которых применена функция 
sortable().Тем не менее с помощью параметра connectWith мы можем позволить пользователям 
перетащить элемент из одного списка в другой:

$("#wishList").sortable({
	connectWith: "#shoppingCart"
});  

/*еще нужно чтобы shoppingCart был как минимум примененна виджет sortable(),тогда из 
wishList мы будем перемещать только в shoppingCart но не наоборот,если нужно в обе стороны
то нужно добавать такой код:

$("#wishList").sortable({
	connectWith: "#shoppingCart"
});

$("#shoppingCart").sortable({
	connectWith: "#wishList"
}); 

*/
Параметр connectWith работает только в одном направлении.Позволяя перетащить из одной 
таблицы в другую но не наоборот.Для соединения обоих списков нам нужно применить параметр 
connectWith к каждому из них:

$("#shoppingCart").sortable({
	connectWith: "#wishList"
}); 
------------------------------------------------------------------------------------------

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
containment --- Мы можем предотвратить возможность перетаскивания элемента за пределы 
элемента-контейнера.Этот параметр работает аналогично параметру виджета Draggable.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

------------------------------------------------------------------------------------------
cursor --- Соответствует параметру cursor для перетаскиваемых элементов(более подробно 
описанно в виджете Draggable)
------------------------------------------------------------------------------------------

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
cursorAt --- Соответствует параметру cursorAt для перетаскиваемых элементов(болееs подробно 
описанно в виджете Draggable)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

------------------------------------------------------------------------------------------
delay --- Продолжительность задержки при перетаскивании сортируемого элемента
(в миллесекундах).Такая задержка может пригодится,если мы считаем,что при перемещении 
указателя мыши по странице можно случайно перетащить элемент списка.Значение данного 
параметра определяет,сколько времени посетитель должен удерживать нажатой кнопку мыши,
прежде чем у него появится возможность перетащить элемент:

delay: 100
------------------------------------------------------------------------------------------

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
distance --- Растояние в пикселях,на которое необходимо переместить элемент списка до 
начала сортировки.Этот параметр может пригодится в тех случаях,когда посетителям 
необходимо щелкнуть по сортируемому элементу с целью,отличной от перетаскивания.Например,
если сортируемый элемент предусматривает кнопку для удаления,то мы можем установить 
параметр distance,чтобы предотвратить перетаскивание элемента,когда посетитель случайно 
перемещает указатель мыши после щелчка по кнопке для удаления.Используем небольшое 
численное значение для данного параметра(иначе посетителям прийдется перетащитьэлемент на 
достаточно большое расстояние,прежде чем произойдет сортировка):

distance: 10 
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

------------------------------------------------------------------------------------------
grid --- Позволяет привязать элемент списка к сетку.Данный параметр работает,если у нас 
группа одинаковых по размеру фотографий или элементов div:мы можем сделать так,чтобы при 
перетаскивании элемента списка он перемещался на расстояние,точно сответствующее ширине 
остальных элементов списка.Данный параметр работает аналогично параметра для виджета 
Draggable
------------------------------------------------------------------------------------------

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
handle --- Определяет часть элемента,по которой пользователь должен щелкнуть,чтобы 
перетащить элемент на другое место в списке.Как правило,пользователи могут перетаскивать 
обьекты,щелкнув в любой точке сортируемого элемента.Тем не менее мы можем решить,что 
пользователи должны щелкнуть по определенной части элемента,например,по вкладке.Этот 
параметр работает аналогично параметру виджета Draggable 
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

------------------------------------------------------------------------------------------
items --- Мы можем определить какие элементы сортируемой группы могут быть отсортированы.
Например,у нас есть вложеные списки(то есть списки внутри списков,пример: <li>Папка<ul><li>Подсписок</li></ul></li>)
И нам не нужно чтобы список верхнего уровня был сортируемым.Нам нужно чтобы сортируемыми 
элементами оказались пункты вложенного списка.В этом случае мы можем использовать параметр 
items со значением "li li",которое обеспечивает возможность сортировки только пунктов 
списка,находящегося в другом списке.Списки верхнего уровня не затрагиваются:

items: "li li"   //Но элементы верхнего списка не будут перемещатся

//чтобы все элементы списков перемещались нужно написать  items: "li"
------------------------------------------------------------------------------------------

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
opacity --- При перетаскивании элемента мы можем изменить степень его прозрачности.
Например,мы можем сделать элемент на 50% непрозрачным,чтобы придать ему призрачного вида.
Изменение степени непрозрачности является распостраненным способом показать,что элемент 
перемещается с одного места в другое:

opacity: 0.5
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

------------------------------------------------------------------------------------------
placeholder --- Имя класса,который плагин jQuery UI применяет к пустуму месту,на которое 
может быть перемещен пункт списка.Мы можем использовать один из собственных классов 
jQuery UI чтобы выделить это место:

placeholder: "ui-state-highlight"

//Теперь то место куда мы перемещаем элемент подсвечивается белым фоном
------------------------------------------------------------------------------------------



									События виджета Sortable
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
create --- Это событие генерируется каждый раз,когда мы используем функцию sortable() для 
создания нового сортируемого списка.Мы можем использовать это событие для отображения 
диалогового ока с инструкцией: "Перетащите композиции,чтобы переупорядочить свой список воспроизведения"
Это событие	срабатывает толкьо один раз - при создании виджета Sortable
В отличие от остальных событий виджета Sortable,событие create не принимает обьект ui.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	
	
------------------------------------------------------------------------------------------
start --- Генерируется кода пользователь начинает перетаскивать элемент списка.Функция,
которую мы назначаем этому событию принимает два аргумента: обьект event и обьект ui.
Обьект ui содрежит другие важные обьекты:

1. ui.helper --- Обьект helper является обьектом jQuery,который представляет собой элемент,
перемещаемый пользователем.Плагин jQuery UI создает клон исходного элемента,пожтому при 
перетаскивании сортируемого обьекта задействуются два различных элемента HTML-кода:
вспомогательный клон и фактический элемент,который является частью списка.По окончании 
перемещении вспомогательный элемент удаляется из документа.Поскольку helper является 
обычным	обьектом jQuery,мы можем применить к нему такие методы как css(),animate(),find()

2. ui.item --- Представляет фактический сортируемый элемент,по которому посетитель щелкнул 
чтобы перетащить например,элемент li.Это реальный элемент HTML-кода, и он будет помещен в 
надлежащее место в списке,как только пользователь закончит перетаскивать вспомогательный 
элемент.Этот элемент также является обьектом jQuery,поэтому к нему применимы все обычные 
методы этой библиотеки. 

3. ui.position --- Предоставим x и y координаты левого верхнего угла вспомогательного 
элемента(элемента,который визуально перетаскивается по экрану) относительно его ближайшего
позиционированного предка.Если виджет Sortable находится внутри относительного или 
абсолютного позиционированного элемента,то свойство ui.position предоставит координаты его 
верхнего левого угла относительно верхнего левого укгла позиционированного элемента.
ui.position.top и ui.position.left

4. ui.originalPosition --- Исходное положение сортируемого элемента,то есть место,где он 
находился прежде чем пользователь начал его перемещать.C двумя свойствами: top,left

5. ui.offset --- это обьект с двумя свойствами: top и left.Однако в данном случае позиция 
определяется относительно левого верхнего угла окна браузера.Свойство ui.offset.top 
указывает,как далеко верхняя часть вспомогательного элемента находится от верхней части 
окна.Свойство ui.offset.left определяет на сколько пикселов перетаскиваемый обьект стоит
от левого края окна браузера.

6. ui.sender --- Данное свойство применяется только при перетаскивании элемента из одного 
сортируемого виджета в другой.Свойство ui.sender содержит обьект для сортируемого виджета 
из которого перетаскивается элемент. 
------------------------------------------------------------------------------------------	
	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
activate --- Срабатывает непосредственно после события start,но практически одновременно 
с ним.Мы можем использовать это событие,чтобы добавить вторую функцию,которую мы хотим 
запустить после функции start  
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	
	
------------------------------------------------------------------------------------------
sort --- Событие sort срабатывает при каждом перемещении указателя мыши в процессе 
перетаскивания сортируемого элемента.Другими словами это событие срабатывает постоянно,
поэтому не назначаем для него задач,требующих много времени или вычислительных ресурсов.
В противном случае многочисленные вызовы функции приведут к снижению отзывчивости страницы
и скорее всего усложнят процесс перетаскивания 	
------------------------------------------------------------------------------------------	
	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
change --- Данное событие срабатывает,как только сортируемые элементы перемещаются на 
новое место.Когда элемент перетаскивается с первой позиции списка вниз,а второй пункт 
перетаскивает на его место,срабатывает событие change.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	
	
------------------------------------------------------------------------------------------
beforeStop --- Событие beforestop срабатывает после того как пользователь отпускает 
сортируемый элемент.Это последнее событие,имеющее доступ к обьекту ui.helper.После 
срабатывания данного события обьект ui.helper(клон перетаскиваемого обьекта удаляется)	

beforeStop: function(event, ui) {
	ui.item.css("background", "blue");
	ui.helper.css("color", "red");
}
------------------------------------------------------------------------------------------	
	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
update --- После размещения сортируемых элементов по местам и обновления DOM срабатывает
событие update
//ui.item.css("background", "blue"); - работает,а ui.helper.css("color", "red"); - не работает 	
//Я так понял из-за того что ui.item - это фактический обьект,а ui.helper - копия котороя потом удаляется 
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	
	
------------------------------------------------------------------------------------------
deactivate --- Когда сортировка закончена,после события update срабатывает событие 	
deactivate
//ui.item.css("background", "blue"); - работает,а ui.helper.css("color", "red"); - не работает 	
//Я так понял из-за того что ui.item - это фактический обьект,а ui.helper - копия котороя потом удаляется 
------------------------------------------------------------------------------------------	
	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
stop --- Когда сортируемый элемент элемент будет помещен на новую позицию,сработает 
событие stop.Это событие является последним и всегда следует после событий stop и 
deactivate.Назначим этому событию функцию,которая соответствует последнему действию,
которое должно быть выполнено над элементом,после того как мы расположим его на новом 
месте.Например,мы можем использовать событие stop,чтобы проверить соответствует ли 
состояние списка некоторому заранее определенному порядку.
	
//ui.item.css("background", "blue"); - работает,а ui.helper.css("color", "red"); - не работает 	
//Я так понял из-за того что ui.item - это фактический обьект,а ui.helper - копия котороя потом удаляется 
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	
	
------------------------------------------------------------------------------------------
out --- Cобытие out срабатывает,когда сортируемый элемент перемещается за пределы виджета
Sortable,например,если мы перетаскиваем элемент из соответствующего виджета Sortable на 
пустое место на странице.Данное событие также срабатывает при перемещении обьекта из 
одного виджета в другой. 	
------------------------------------------------------------------------------------------	
	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
over --- Срабатывает при перемещении сортируемого элемента над связанным списком.Например,
если у нас есть два связанных списка,и мы перетаскиваем элемент из первого списка во 
второй,то на втором списке срабатывает событие over.Это событие также срабатывает,когда 
мы перемещаем элемент из группы сортируемых элементов,а затме обратно  	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	
	
------------------------------------------------------------------------------------------
receive --- Используем событие receive при использовании нескольких соединенных виджетов 
(connectWith).Когда виджет Sortable получает элемент из другого виджета,срабатывает 
событие receive.Мы можем использовать это событие в сочетании с обьектом ui.sender,чтобы 
определить откуда взялся новый элемент:

$("#playlist").sortable({
	connectWith: "#playlists"
	});

$("#playlists").sortable({
	receive: function(event, ui) {
		ui.sender = $("#playlist"); 
		ui.item.css("background", "blue");
	}
});
------------------------------------------------------------------------------------------	
	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
remove --- Это событие срабатывает когда элемент удаляется из текущего сортируемого 
виджета.Например,у нас есть два виджета: список пожеланий и корзина.Если покупатель 
перетащил элемент из списка пожеланий в корзину,то на списке пожеланий сработает событие 
remove(а также событие out).

//Кстате не плохое событие,при переносе элемент выделяется,и сразу видно что мы перенесли	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	
	
	
								Методы виджета Sortable
Виджет Sortable предусматривает несколько различных методов или функций которые можно к 
нему примерить.Мы просто передаем стороку.Например,мы используем метод destroy:

$("#sortableItems").sortable("destroy");

------------------------------------------------------------------------------------------
cancel --- Этот метод отменяет любые изменения в текущем порядке сортируемого списка.
Другими словами,он прекращает процесс переупорядочивания этого списка.Мы можем 
использовать эту функцию совместно с методом receive,чтобы отклонить элемент списка,
перемещенный в другой виджет Sortable.Кроме того в качестве события stop мы можем создать 
функцию,которая проверяет местоположение добавленного элемента и отвергает изменение,если 
этот элемент не отвечает определенным условиям.Например,если пользователь пытает 
перетащить задачу в верхнюю часть списка,но первой должна быть выполнена другая задача, то
мы можем отменить действие этого пользователя и отобразить диалоговое окно с обьеснением 
причины отмены.
//Отменяет только последнее действие,если мы перенесли 3 элемента из одного списка в 
//другой,то данный метот вернет обратно только последнее изменение(последний из 3)  							
------------------------------------------------------------------------------------------							
					
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
destroy --- Превращает сортируемый набор элементов списка в обычный список элементов,
которые нельзя перетаскивать.Чтобы полностью удалить возможность сортировки виджета,
используем метод destroy 	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	
	
------------------------------------------------------------------------------------------
disable --- Для временного отключения возможности сортировки виджета вызовим метод disable
Используем его,если нам нужно запретить сортировку до возникновения некоторого условия.Мы 
можем включить возможность сортировки,используя метод enable 	
------------------------------------------------------------------------------------------	
	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
enable --- Включим возможность сортировки виджета к которому ранее был применен метот 
disable	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	
	
------------------------------------------------------------------------------------------
serialize --- Этот метод полезен для отправки данных о порядке следования элементов в 
списке обратно на веб-сервер с помощью технологии Ajax или передачи формы.Нам может 
потребоватся это сделать при необходимости хранения этой информации на сервере для 
последующего использования.Например,если менеджер упорядочивает список задач для 
сотрудников,то информация об из порядке может быть отправлена на сервер,хранится в базе 
данных и извлекатся,когда сотрудник зайдет в систему,чтобы увидеть какие задачи и в каком 
порядке должны быть выполнены.Нам необзодимо особым образом отформатировать сортируемые 
элементы: 

1.Каждый элемент списка должен иметь идентификатор 
2.Каждый идентификатор должен начинатся со слова,используемого в качестве идентификатора 
группы для списка,за которым следует символ нижнего подчеркивания.
3.За символом _ в имени идентификатора должен следовать уникальный идентификатор для 
элемента списка.Например у нас есть список воспроизведения.HTML-код может выгладеть 
следующим образом:

<ul id="playlist">
	<li id="song_1">My Way -- Frank Sinatra</li>
	<li id="song_2">Like a Rolling Stone -- Bob Dylan</li>
	<li id="song_3">Respect -- Aretha Franklin</li>
</ul>

Обратим внимание на то,что идентификатор для каждого элемента списка начинается с 
фрагмента "song_" и заканчивается уникальным числом.Это необязательно должно быть число,
это может быть слово или уникальный идентификатор из базы данных.Идея состоит в том,чтобы 
обеспечить способ передачи серверу данных о порядке следования элементов списка.Мы можем 
использовать метод serialize для сохранения текущего порядка элементов списка:

var listOrder = $("#playlist").sortable("serialize");

Метод serialize возвращает строку,которая выглядит примерно так:

song[]=2&song[]=3&song[]=1 

Это строка сообщает браузеру порядок следования элементов в списке.В данном случае числа 
2,3,1 указывает на то,что первый элемент списка был перемещен в конец.Мы можем поместить 
строковое значение,возвращенное методом serialize URL-адресу,как часть запроса Ajax. 
//api.jqueryui.com/sortable/#method-serialize	
------------------------------------------------------------------------------------------	
	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
toArray --- Подобно методу serialize,метод toArray является способом извлечения 
упорядоченного списка элементов виджета Sortable.Чтобы его использовать,необходимо 
добавить идентификатор для каждого пункта сортируемого списка.Однако в отличие от метода 
serialize,он не требует использования какого-либо специального формата.Этот метод просто 
возвращает массив с перечнем идентификаторов всех элементов виджета Sortable в порядок их 
следования в списке.Например,у нас есть виджет Sortable с идентификатором colorList.Внутри 
него находится три элемента списка с разными цветами:

<ul id="colorList">
	<li id="red">Красный</li>
	<li id="green">Зеленый</li>
	<li id="blue">Синий</li>
</ul>

Допустим,пользователь изменил порядок следования цветов,поэтому "Синий" теперь идет первым
"Красный" - вторым,а "Зеленый" - последним.В этом случае мы можем использовать метод 
toArray следующим образом:

var colors = $("#colorList").sortable("toArray");

Переменная colors будет содержать такой массив: ["blue", "red", "green"]
Результатом является простой массив javaScript.Другими словами просто извлекает массив 
Метод toArray может применятся,например,для проверки соответствия порядка элементов в 
списке некоторому предопределенному порядку.Например,мы создали игру,которая отображает 
список цветных блоков в случайном порядке.Игрок должен расположить блоки в порядке цветов 
радуги.Мы можем назначить функцию событию stop,которое извлекает текущий порядок 
следования блоков с помощью метода toArray и затем сравнивает его с другим массивом,
содержащим ответ. 
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
	

									Эффекты jQuery UI
Плагин jQuery UI включает набор визуальных анимированных эффектов,которые можно 
использовать для оживления веб-приложений.Эффекты предназначены для того,чтобы отобразить,
скрыть или выделить элемент,например,щаставить его загоратся или дрожать.Для применения 
эффектов мы используем jQuery-функции как раньше лбо функцию effect().Например,чтобы 
использовать эффект drop плагина jQuery UI,при которой элемент как бы падает на страницу,
мы можем применить метод show() с именем эффекта и значением продолжительности:

$("#pageElement").show("drop", 1000);
	
------------------------------------------------------------------------------------------
show() --- Плагин jQuery UI расширяет возможности функции show(), позволяя использовать 
один из 15 различных эффектов для отображения скрытого элемента.Мы должны уведится что 
элемент скрыт.	
------------------------------------------------------------------------------------------	

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
hide() --- Чотбы применить один из эффектов jQuery UI при сокрытии элемента используем 
метод hide().Он заставляет элемент исчезнуть с применение специального эффекта.Но нужно 
убедится что элемент отображен на странице.	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	
	
------------------------------------------------------------------------------------------
toggle() --- Метод toggle()	отображает или скрывает элемент.Если элемент скрыт,то мето 
toggle() заставляет его появиться с использованием выбранного эффекта.Если элемент видим,
то метод toggle() скрывает его 
------------------------------------------------------------------------------------------	
	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
effect() --- Большинство эффектов jQuery UI создано с целью обеспечения	зрелищного 
отображения или сокрытия элемента.Некоторые эффекты,например, bounce,highlight,pulsate,
snake могут быть использованы для выделения уже видимого элемента,не заставляя его 
исчезать.Эффект highlight,например,на мгновение выделяет элемент с помощью яркого цвета,
что позволяет привлечь внимание посетителя к определенному месту на странице.Функция
effect() является уникальной для плагина jQuery UI и не является стандартной функцией 
библиотеки jQuery
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	
	
								
										Эффекты
Некоторые эффекты имеют по нескольку параметров,а некоторые - вообще их не имеют.Плагин 
jQuery UI предусматривает множество эффектов.

------------------------------------------------------------------------------------------
blind --- Эффект blind отображает или скрывает элемент,имитируя поднятие или опускания 
шторки.Данный эффект принимает один параметр - direction,указывающий направление движения
шторки: up(вверх),down(вниз),left(влево),right(вправо).Мы передаем этот параметр в 
качестве обьекта - имени параметра,а значение в качестве второго аргумента функции.
Например,чтобы заставить определенный элемент исчезнуть с экрана:

$("#element").hide("blind", {diretion: "left"}, 1000);	
------------------------------------------------------------------------------------------	
	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
bounce --- Эффект bounce можно применить при сокрытии или отображении элемента.Мы также 
можем использовать эффект bounce с функцией effect(),чтобы видимый элемент просто 
отскакивал вверх и вниз.Данный эффект предусматривает два параметра:

1. distance --- Максимальное расстояние(в пикселах),на которое перемещается элемент при 
отскоке.Чем больше число,тем дальше он отскакивает и тем больше внимание привлекает.

2. times --- Число отскоков,совершаемых элементом.

Например,чтобы элемент совершал 20 отскоков на расстояние 100 пикселов при каждом щелчке 
по нему,мы можем использовать следующий код:

$("#theElement").click(function(){
	$(this).effect("bounce", {
		distance: 100,
		times: 20
	},1000);
});
//Сначала прыгает на 100 пикселов,2й раз уже вдвое меньше,3й раз еще на половину меньше ...	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	
	
------------------------------------------------------------------------------------------
clip --- Эффект clip применяет атрибут CSS clip к элементу,чтобы он отображался 
вертикально или	горизонтально.Этот эффект принимает только один параметр - direction со 
значением vertical или horizontal:

$("#element").effect("clip", {direction: "vertical"}, 2000);	
------------------------------------------------------------------------------------------	
	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
drop --- Эффект drop постепенно отображает или скрывает элемент,сдвигая его вверх,вниз,
влево,вправо.Он предусматривает единственный параметр - direction,который принимает одно 
из следующих четырез значений: up,down,left,right.

$("#element").effect("drop", {direction: "up"}, 2000);	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	
	
------------------------------------------------------------------------------------------
explode --- Эффект explode разделяет элемент на несколько фрагментов,разлетающихся в 
разные стороны и исчезающих из вида.При использовании с функцией show() взрыв происходит в 
обратном направлении,то есть элемент собирается из отдельных фрагментов.Этот эффект 
предусматривает только один параметр - pieces,определяющий количество фрагмент,на которые 
должен быть разделен элемент.Это количество должно являться квадратом целого числа: 1,4,9,16,25...
(однако не следуют давать число больше 25,чтобы не замедлять работу эффекта):

$("#element").hide("explode", {pieces: 16}, 2000);
------------------------------------------------------------------------------------------

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
fade --- Работает подобно функциям fadeIn() и fadeOut().Не самый впечатляющий эффект
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

------------------------------------------------------------------------------------------
fold --- Эффект fold отображает или скрывает элемент,сворачивая его.Для этого интригующего 
визуального эффекта предусмотренно два параметра.Параметр size - это размер в пикселях(или 
в %),до которого должен уменьшится элемент перед сворачиванием.Параметр horizFirst 
принимает логическое значение,которое определяет,как элемент должен сворачиваться сначала,
по ввертикали(по умолчанию) или по горизонтали:

$("element").hide("fold",{size: "50%",horizFirst: false },3000 );

//Сначала сворачивается 50% по горизонтале,а потом 50% по вертикали и исчезает  
------------------------------------------------------------------------------------------

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
highlight --- Эффект highlight моментально меняет цвет фона элемента,чтобы привлечь к нему 
внимание.Мы можем изменить цвет фона с помощью параметра color.Например,чтобы выделить 
элемент на 1 секунду изменив цвет фона на крассный,мы можем применить метод effect() :

$("element").effect("highlight",{color: "red"}, 1000 );
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

------------------------------------------------------------------------------------------
puff --- Этот эффект заставляет элемент изменяться в размере и исчезать из вида(или 
появлятся).Он предусматривает единственный параметр percent,который определяет размер 
элемента при его отображении или сокрытии:

$("element").effect("puff",{percent: 200}, 2000 );
------------------------------------------------------------------------------------------

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
scale --- Используем этот эффект для масштабирования элемента.Мы можем применить этот 
эффект с методом hide() или show().Обычно,если мы используем метод show(),чтобы отобразить
скрытый элемент,то этот элемент увеличивается с размера небольшого пятна на странице до 
своего нормального размера.Если элемент является видимым,и мы используем метод hide(),то
элемент уменьшится и исчезнет.

$("element").hide("scale", 2000 );
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

------------------------------------------------------------------------------------------
shake --- Этот эффект можно применить к элементу,отображенному на странице,используя 
функцию effect().Этот эффект заставляет элемент трястись определенное количество раз в 
конкретном направлении и на определенное расстояние.Это еще один из эффектов,позволяющих 
привлечь внимание к элементу,однако он может служить и более важной цели,например,указать 
на ошибку: этот эффект может обеспечить дрожание диалогового окна,если посетитель не 
установил в форме регистрации флажок "С условием использования ознакомлен".Этот эффект 
предусматривает три параметра:

1.Параметр direction --- задает направление в котором начинается дрожание элемента: up,
down,left,right.
2.Параметр distance,чтобы указать количество пикселов,на которое должен перемещаться 
элемент.Чем больше число тем более заметно дрожание.
3.Параметр times --- определает сколько раз должен дрожать элемент.

$("element").effect("shake",{direction: "up", distance: 10, times: 2}, 1000 );
------------------------------------------------------------------------------------------

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
size --- Этот эффект изменяет размер элемента до заданной ширины и высоты.Он принимает три 
параметра: 

1.Свойство to --- обьект со свойствами width и height,которые определяют ширину и высоту 
элемента при сокрытии или отображении элемента.
2.Свойство origin --- определяет точку исчезновения при использовании эффекта size для 
скрывания элемента.Это массив,содержащий два числа: первое соответствует позиции top,
второе - позиции left.
3.Свойсво scale --- используется для указания того,что должно быть отмасштабированно.
Допустимыми значениями являются both,box,content.Например,чтобы увеличить или уменьшить 
только размер внешней рамки(граница,фон,ширина,высота) используем значение box.При этом 
содержимое элемента (например,текст) не масштабируется.

$( "element" ).effect( "size", {to: { width: 200, height: 60 } }, 1000 );
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

------------------------------------------------------------------------------------------
slide --- Этот эффект заставляет элемент скользить из области просмотра(при сокрытии) или 
в область просмотра(при отображении).Передайте параметр direction - left,right,up,down, 
чтобы задать направление скольжения:

$("element").effect( "slide",{direction: "right"}, 3000 );
//Скажем можно сделать эффект как будто идет загрузка,или зарядка батареи
------------------------------------------------------------------------------------------


									Параметры easing
Плагин jQuery UI предусматривает набор параметров easing,которые контролируют скорость 
изменений в процессе анимации.Параметр easing не изменяет общую продолжительность анимации, 
но изменяет скорость,с которой происходят ее отдельные фрагменты.Например,если мы 
используем эффект bounce, мы можем применить параметр easing,который обеспечивает 
медленное начало и дальнейшее ускорение отскока.

Для использования параметра easing вместе с эффектом нам нужно передать его в качестве 
свойства обьекта options.Названием свойств является easing,а значением является одна из 
возможных функций - easeInOutQuart, easeInSine....(api.jqueryui.com/easings/ - полный список параметров easing)  
Например,мы хотим использовать эффект bounce,чтобы элемент отскакивал каждый раз,когда по 
нему щелкают кнопкой мыши.Нам нужно,чтобы жлемент отскакивал 20 раз на максимальное 
растояние 100 пикселов(это два параметра bounce).Мы также хотим,чтобы эффект easing 
выглядел более реалистично,замедлялся по мере истощения энергии.В этом случае мы можем 
добавить параметр easing к обьекту options:

$("element").click(function(){
	$(this).effect("bounce", {distance: 100, times: 20, easing: "easeOutBounce"},2000);
});


Нам необязательно использовать параметры easing только с эффектами jQuery UI.Мы можем
Использовать эти параметры также с анимацией jQuery UI.


									Анимация изменения класса
Плагин jQuery UI включает несколько функций,которые позволяют анимировать изменения 
значений свойств CSS элемента при добавлении или удалении класса.Эти функции фактически 
являются продолжением существующий jQuery-функций: addClass(),toggleClass(),removeClass()
Плагин jQuery UI просто анимирует изменения,поэтому при добавлении или удалении класса 
jQuery UI анимирует визуальные изменения,которые происходят из-за добавления или удаления 
свойств CSS.

/*
	Переходы CSS являются лучшим вариантом,поскольку они работают более плавно и не 
требуют какой-либо работы от интерпритатора javaScript.Тем не менее переходы CSS не 
подерживаются браузером Internet Explorer 9 или более ранней версией,поэтому нам может 
понадобится использовать функцию анимации изменения класса jQuery UI,чтобы обеспечить тот 
же эффект в этих браузерах.Однако если нам не нужно подерживать устаревшие версии 
Internet Explorer используем переходы CSS вместо этих функций jQuery UI/	
*/	

Каждая из функций анимации изменения класса jQuery UI принимает до четырех аргументов,
контролирующих принцип их работы.Первый аргумент - это имя класса,который мы хотим 
добавить или удалить.Следующие три включают длительность,параметра easing и функцию 
завершения.Это те же аргументы,кторые мы передаем методу effect().Например,чтобы выбрать 
элемент с идентификатором feature,добавим имя класса highlight и анимировать визуальные 
изменения,вызванные добавлением этого класса,мы можем использовать следующий код:

$("#feature").addClass("highlight", 1000, "easeOutBack", function(){//имя класса может быть любое
	alert("Анимация завершена");
});

 	
Этот код добавляет класс highlight к выбраному элементу и анимирует визуальное изменение 
элемента на протяжении 1 секунды,используя метод easeOutBack.После запускается функция 
с оповищением. 	
//Другими словами мы можем создать стили CSS,дать комуто с помощью jQuery и анимировать через jQuery UI	
	
Плагин jQuery UI предусматривает четыре функции для анимации изменения класса:

1.Метод addClass() позволяет добавить класс к одному или нескольким элементам и 
анимировать визуальные изменения в течение определенное периода времени. 	
	
	
/*
	Если мы не передадим аргумент продолжительности времени то плагин jQuery UI просто
использует стандартный вид jQuery-функции без анимации.Например:
	$("#feature").addClass("highlight");
	Этот код добавляет класс но не анимирует его
*/	
	
2.Метод removeClass() работает так же как и метод addClass().Мы передаем имя класса,
продолжительность,дополнительное значение параметра easing и дополнительную функцию 
обратного вызова

3.Метод toggleClass() удаляет или добавляет класс.Мы можем использовать эту функцию вместе
с событием click(),чтобы добавить класс при первом щелчке по элементу,а затем удалить 
этот класс при следующем клике.Таким образом мы можем создать элемент переключатель либо
включен либо выключен.

4.Метод switchClass() является единственным методом jQuery UI,который не имеет эквивалента
jQuery.Он принимает два имени класса: первый соответствует классу,который плагин jQuery UI
удаляет из выбранных элементов,а второй представляет собой класс,добавляемый плагином 
jQuery UI.Это подобно обьединению методов removeClass() и addClass(),но позволяем нам 
анимировать замену удаляемого класса добавляемым.Например,если мы удаляем класс с крассным 
фоном и добавляем класс с зеленым фоном,то плагин jQuery UI анимирует изменения цвета фона 
с красного на зеленый:

$("#feature").switchClass("defaultStyles", "highlight", 1000);
	
	


									Что такое Ajax
Ajax - это аббревиатура от Asynchronous JavaScript и XML.Ajax не является официальной 
технологией вроде HTML,javaScript или CSS.Под этим термином следует понимать сочетание 
ряда технологий - языка javaScript,браузера и веб-сервера - для получения и отображения
обновленной информации без загрузки новой страницы.Браузеры позволяют с помощью кода 
javaScript посылать запрос на веб-сервер,который в ответ присылает браузеру некоторые 
данные.Есть много простых вещей которые позволяет делать технология Ajax:

1.Отображение нового HTML-контента без перезагрузки страницы. 
2.Отправка формы и немедленный показ результата
3.Авторизация без ухода со страницы 
4.Назначение рейтинга (www.wbotelhos.com/raty/)
5.Обзор информации базы данных.Если прокрутить до конца страницы появится больше 
информации,прокрутим снова в конец страници и появится еще больше информации.Без 
необходимости загружать новую страницу.И кажется что страница никогда не закончится.
Так и используется технология Ajax.
(Без Ajax пришлось бы клацать на следующую новую страницу с информацией)


Среди приведенных выше задач нет ничего революционного за исключением упомянания об 
отсутствии необходимости загружать новую страницу.Таких же результатов можно достичь
с помощью серверного программирования.Однако технология Ajax повышает интерактивность 
веб-страниц и улучшает впечатление посетителя от использования сайта.

/*
	При традиционом способе обращения браузера с веб-сервером происходит постоянные 
загрузки и перезагрузки веб-страниц.При использовании технологии Ajax браузер запрашивает
только новую информацию не перезагружая страницы
*/

Ajax нельзя расматривать как самостоятельную технологию,так как это смесь ряда технологий,
функционирующих совместно для повышения эффективности работы пользователя.Ajax сводит 
вместе три разных компонента:

1.Браузер - он необходим для просмотра веб-страниц и применения кода javaScript.Есть 
тайный "ингредиент",встроенный в большенство современных обозревателей и делающий 
использование Ajax возможным - обьект XMLHttpRequest.За этим термином стоит как раз то,что
позволяет коду javaScript общаться с веб-сервером и получать в ответ информацию 

2.Код javaScript выполняет главные функции Ajax: посылает запрос на веб-сервер,ожидает 
ответ,обрабатывает его и (как правило) обновляет страницу,добавляя новые данные или 
изменяя облик страницы определенным образом.В зависимости от того,что мы хотим от своей 
программы,код JavaScript может посылать данные заполненной формы,запрашивать 
дополнительные записи из базы данных или просто отправлять фрагмент информации(вроде 
рейтинга,только что присвоенного).После отправки данных на сервер программа javaScript
будет готова принять ответ,например,дополнительные записи из базы данных или просто 
сообщения вроде "Ваш голос учтен".Получив информацию,код JavaScript обновляет страницу - 
представляет новые записи базы данных или,например,сообщает посетителю,что он успешно 
авторизован.

3.Веб-сервер получает запросы от браузера и отправляет ему информацию.Сервер может просто
вернуть определенный HTML-код или простой текст,а может документ XML или данные JSON.
Например,если сервер получает информацию из формы,он может добавить ее в базу данных и 
отослать обратно сообщение,подтверждающее,что данные добавлены.

/*
	Для работы с серверной частью нужны:
1)сервер приложения - PHP,Java,Ruby,C#....позволяет решить такие задачи как,отправка эл.почты,
проверка цен на книге,или хранение информации в базе данных
2)сервер базы данных - MySQL,PostgreSQL и SQL Server,дает возможность хранить такую информацию,
как имена,адреса...
*/
 
							
							Взаимодействие с веб-сервером
Главный компонент программы Ajax - это обьект XMLHttpRequest,иногда называемый просто XHR
Он встроен в большинство современных браузеров и обеспечивает коду javaScript возможность
посылать информацию на веб-сервер и получать данные в ответ.Этот процесс состоит из пяти
этапов,и все они выполняются с помощью кода javaScript:

1.Создадим экземпрял обьекта XMLHttpRequest.Это первый шаг всего лишь сообщает браузеру 
"Эй я собираюсь послать информацию на сервер,так что приготовься".В общем виде создание 
обьекта XMLHttpRequest на языке javaScript можно записать так:

var newXHR = new XMLHttpRequest();

Несмотря на простоту приведенного фрагмента кода,создание программ Ajax исключительно с 
помощью javaScript сопряжено с определенными сложностями.К счастью,бибилиотека jQuery
предусматривает более простой способ создание запросов Ajax//Мы узнаем об этом с ледующем разделе,чуть позже

2.Применим XHR-метод open() для определения способа отправки данных и места,куда они 
отправляются.Посылать данные можно двумя способами: GET или POST,они аналогичны тем 
которые использовались в HTML-формах.Метод GET - посылает информацию на веб-сервер как 
часть URL-адреса,допустим, shop.php?productID=34 .В рассматриваемом примере данные 
отправляются в качестве "строки запроса",которая представляет собой информацию,следующую 
за символом "?"(в данном случае productID=34).Эта пара имя/значение,где productID является
именем,а 34 - значением.Именем может быть имя поля формы,а значением - данные,которые 
посетитель вводит в это поле.

Метод POST - посылает данные отдельно от URL-адреса.Если метод GET обычно используется для
получения данных с сервера,то метод POST служит для обновления информации на сервере
(например чтобы добавить,обновить или удалить запись в базе данных).

Мы также используем метод open() для выбора страницы на сервере,куда направляются данные.
Обычно это та страница,которая использует серверный язык сценариев(например PHP)для 
извлечения сведений из базы данных или выполнения иной программной задачи.Мы указываем 
на нее с помощью URL-адреса.Например,следующий код сообщает обьекту XHR,какой метод 
использовать (GET) и какую страницу на сервере запрашивать:

newXHR.open("GET", "shop.php?productID=34");

/*
	URL-адрес,который мы задали для метода open(),должен находится на том же сайте,что и
страница,посылающая запрос.Из соображения безопасности браузер не разрешит посылать 
Ajax-запросы в другие домены.Формат JSONP позволяет обойти эту проблему.
*/

3.Создадим функцию для обработки результатов.Когда веб-сервер возвращает результат (новая 
информация из базы данных,подтверждение о передаче формы или просто текстовое сообщение),
нам обычно нужно с ним что-то сделать.Можно просто написать сообщение "Форма успешно передана"
Иногда необходимо заменить всю таблицу записей базы данных на новую.В любом случае нам 
придется написать функцию javaScript для обработки результата(называемую функцией 
обратного вызова),которая часто является сутью нашей программы.Как правило,эта функция 
манипулирует содержимым страницы(то есть изменяет ее DOM)путем удаления(например,удаляя 
форму,посланную с помощью Ajax),добавления(отображая сообщение "Форма успешно передена" 
или новую HTML-таблицу записей базы данных) или изменения элементов(например,выделяя 
количество звезд,которое посетитель только что выбрал при присвоении рейтинга товару).
Есть еще несколько этапов процесса,но поскольку мы используем библиотеку jQuery для 
упрощения рутины,единственное,что нам необходимо понять о функции обратного вызова,это то 
что она является кодом javaScript для обработки ответа сервера.

4.Пошлем запрос.Для отправки запроса на сервер мы применяем метод обьекта XHR send() 
Все,что мы делали до этого момента было просто подготовкой,а данный шаг сообщает серверу:
"Мы готовы...посылай запрос!"Если мы пользуемся методом GET,то код выглядит следующим 
образом:

xhr.send();

Метод send() может принимать аргумент - данные,которые мы мосылаем на сервер.При 
использовании метода GET данные посылаются как часть URL-адреса,например,
search.php?q=javascript ,где данные - это фрагмент q=javascript .Используя метод POST,
мы должны предоставить данные наряду с методом send():

xhr.send("q=javascript");

//Опять же,не задумывайтесь над деталями,мы увидим как библиотека jQuery упрощает этот процесс,с следующем разделе

После того как запрос послан,наша программа javaScript не обязательно должна отановиться.
Буква "А" в слове Ajax,как известно - означает "асинхронный",а это подразумивает,что после
отправки запроса код javaScript может продолжать заниматься чем-то еще.Браузер 
"не сидит без дела",просто ожидая ответа от сервера.

5.Применим ответ.После того как сервер обработал запрос,он посылает ответ браузеру.Функция
обратного вызова,созданная в пункте 3,обрабатывает ответ, и обьект XHR получает при этом 
часть информации,включая статус запроса,текст ответ и возможно ответ в формате XML
Статус ответа - это число,указывающее на характер,ответа сервера: нам вероятно,знаком код 
ошибки 404, означающий,что запрошенный файл не найден.Если все прошло по плану,мы получим
статус 200 или может быть 304 .В случае ошибки при обработке страницы мы получим статус 
500 и сообщение "Внутренняя ошибка сервера",а если запрашиваемый файл защищен паролем,мы 
получим ошибку 403: "Доступ запрещен".Полный список кодов ошибок мы можем найти по адресу:
www.w3.org/Protocols/rfc2616/rfc2616-sec10.html 

Чаще всего мы получаем текстовый ответ,который хранится в свойстве обьекта XHR responseText
Это может быть фрагмент HTML-кода,простое текстовое сообщение или сложный набор данных JSON
Наконец,если сервер посылает в ответ XML-файл,он хранится в свойстве обьекта XHR responseText
Хотя формат XML по-прежнему используется,более распростаненными форматами ответа для 
страниц сервера являются все же текстовые,HTML и JSON-данные,так что нам,может и вовсе 
никогда не придется обрабатывать XML-ответ.Какие бы данные сервер ни возвращал,все они 
обрабатываются функцией обратного вызова для обновления веб-страницы.По завершении работы 
функции обратного вызова заканчивается полный цыкл Ajax(однако мы можем отправлять 
несколько Ajax запросов одновременно).
 

	
							Работа с Ajax с помощью средств jQuery
Несмотря на то,что базовый процес XMLHttpRequest не слишком сложен,всякий раз при создании
запроса XHR необходимо выполнить много шагов.К счастью,библиотека jQuery предоставляет 
несколько функций,весьма упрощющих весь процесс.
//Из 5 шагов самое интересное проиходит в 3 шаге						


------------------------------------------------------------------------------------------
							Использования метода load()
Простейшим из методов Ajax,предлагаемых библиотекой jQuery,является load() .Он загружает 
HTML-файл в указанный элемент на странице.Например,на нашей странице отведено место для 
списка заголовков новостей.При его загрузке отображаются пять последних новостных 
сообщений.Мы можем добавить ссылки,которые дали бы возможность посетителям выбирать 
самостоятельно,какие заголовки должны быть в данном месте: вчерашние события,местные 
новости,новости спорта....Конечно,это можно сделать с помощью ссылок на различные страницы
содержащие нужную информацию(и не использовать Ajax),но тогда посетителям придется 
переходить на другую веб-страницу.
Альтернативным способом является загрузка выбранных новостных сюжетов в рамку с 
заголовками новостей на странице.Другими словами,каждый раз когда посетитель щелкает по 
другой категории новостей,браузер,запрашивает новый HTML-файл с сервера,а затем помещает 
этот файл в рамку с заголовкоми,не покидая текущую страницу 

Чтобы применить функцию load(),сначала воспользуемся селектором jQuery для идентификации 
элемента на странице,где должен быть размещен запрашиваемый HTML-контент.Затем вызовим 
функцию load() и передадим URL-адрес страницы,которую нужно получить.Например,у нас есть 
элемнт div с идентификатором headlines и мы хотим загрузить HTML из файла today_news.html
в данный элемент.Сделать это можно следующим образом:

$("#headlines").load("todays_news.html");

В процессе выполнения кода браузер запрашивает файл todays_new.html у веб-сервера.После 
его загрузки браузер заменяет текущее содержимое элемента div с идентификатором headlines
данными из нового файла.HTML-файл может представлять собой полную веб-страницу 
(включая элементы html,head,body)или только фрагмент например,запрашиваемый файл может 
содержать всего лишь элемент h1 и абзац текста.В этом случае этот HTML-фрагмент и 
вставляется на текущую страницу 

/*
Загружать HTML-файлы можно только с этого же сайта.Например,мы не можем загрузить домашнюю
страницу сервиса Google в элемент div на странице нашего сайта с помощью функции load()
*/

При использовании функции load() нам следует быть очень внимательными к путям файлов.
Во-первых,URL-адрес который мы передаем функции load() должен быть связан с текущей 
страницей.Другими словами,мы используем такой же путь как если бы ссылались из текущей 
страницы на HTML-файл,который нужно загрузить.Кроме того,пути к файлам в HTML-коде не 
переписываются при загрузке этого HTML в документ,так что если загруженный файл имеет 
ссылку или изображение,их URL-адреса должны быть связаны со страницей,использующей функцию 
load().Иначе говоря,если мы используем пути относительно документа,а загруженный HTML-файл
находится в другой папке на нашем сайте,то изображения и ссылки могут оказатся нерабочими 
после загрузки HTML-контента на текущую страницу.Вот простое решение:используем ссылки 
относительно корневого каталога или нужно удостоверится,что загружаемый файл находится в 
той же папке,что и страница,использующая функцию load().  

Кроме того,функция load() позволяет указать,какую часть загруженного HTML-файла мы хотим 
добавить на страницу.Например,запрашиваемая страница является обычной страницей с сайта:
она включает такие привычные элементы как баннер,панель навигации и нижний колонтитул.
Допустим,нас интересует лишь часть содержимого этой страницы,находящаяся в отдельно взятом
элементу div.Чтобы выбрать ее,вставим пробел и селектор jQuery после URL-адреса.В нашем 
примере нам нужно вставить содержимое элемента div с идентификатором news в файл 
todays_news.html.Для этого используем следующий код:

$("#headlines").load("todays_news.html #news");

В данном случае браузер загружает страницу todays_news.html,но не вставляет все ее 
содержимое в элемент div с идентификатором headlines ,а извлекаеттолько элемент div с 
идентификатором news.
------------------------------------------------------------------------------------------

/*
Если мы не используем jQuery-функцию load() для вставки HTML-контента со страницы на 
веб-сервере на страницу в браузере,нам понадобится серверное программирование для 
использования технологии Ajax.Главный смысл Ajax заключается в том,чтобы позволить коду 
javaScript общаться с сервером и получать от него информацию.В большенстве случаев это 
подразумевает наличие дополнительного сценария,выполняемого на веб-сервере и решающего 
задачи,которые не под силу коду JS,например считывание информации из базы данных,отправка 
электронных сообщений или авторизация пользователя.
*/


<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
										Методы get() и post()
Сервер не всегда способен возвращать HTML-код,ответом могут быть сообщения,номера кодов 
или данные требующие дальнейшей обработки средствами javaScript.Например,если мы 
используем технологию Ajax для получения определенных записей из базы данных,сервер может
возвратить XML-файл,содержащий эти записи или обьект JSON.У нас не получится вставить эти
данные на страницу - их придется обработать для получения HTML-кода

jQuery-функции get() и post() являются простыми инструментами для отправки и получения 
данных с веб-сервера.Как отмечалось в пункте 2 в разделе "Взаимодействие с веб-сервером",
обработка обьекта XMLHttpRequest методами GET и POST имеет нескошлько различий.Однако 
библиотека jQuery учитывает данные различия,так что функции get() и post() работают 
одинаково.Базовая структура такова:

$.get(url, data, callback);

или

$.post(url, data, callback);

/*
В отличие от большинства других функций библиотеки jQuery,нам не нужно добавлять get() или
post() в селектор jQuery,другими словами нам никогда не придется использовать подобный код:
$("#mainContent").get("product.php").Обе функции не связаны с какими-то элементами на 
странице,так что мы просто используем символ $,после которого следует точка и слово get 
или post:  $.get()
*/

Функции get() и post() принимают три аргумента:

1.Аргумент url - это строка,содержащая путь к серверному сценарию обработки данных
(например, "processForm.php").

2.Аргумент data - является либо строкой,либо литералом обьекта javaScript,содержащим 
данные,которые мы хотим послать на сервер.

3.Аргумент callback - является функцией обратного вызова,которая обрабатывает информацию,
возвращаемую сервером 

При выполнении функции get() или post() браузер посылает данные по указанному URL-адресу.
Когда сервер возвращает ответные данные,браузер передает их функции обратного вызова,
которая обрабатывает эту информацию и обновляет страницу.

 
					Форматирование данных,посылаемых на сервер(2й Аргумент)
При написании программ javaScript использующих Ajax,мы посылаем какую-то информацию на 
сервер.Например,если нам нужны сведения о конкретном товаре из БД,то мы можем просто 
послать номер,идентифицирующий этот товар.Когда сервер получает его в запросе XHR,он ищет 
в базе данных товар с совпадающим номером,извлекает информацию о товаре и посылает ее 
обратно браузеру. Посылаемые данные необходимо отформатировать понятным для функций get() 
и post(), мы можем отформатировать их как строку запроса или как литерал обьекта:

1.Строка запроса.Мы могли видеть строки запросов ранее: они часто появляются в конце 
URL-адреса,следуя после знака "?".Например,в этом URL-адресе:

http://www.chia-vet.com/products.php?prodID=18&sessID=1234

строкой запроса является:

prodID=18&sessID=1234

Она содержит две пары имя/значения - prodID=18 и sessID=1234 - и выполняет в принципе ту 
же задачу,что и создание двух переменых,prodID и sessID и сохранения в них двух значений.
Строка запроса является обычным методом передачи информации в URL-адресе

Форматировать данные,посылаемые на сервер можно и с помощью технологии Ajax.Например,мы 
создали веб-страницу,на которой посетители имеют возможность присваивать рейтинг фильмам,
выбирая определенное количество звезд.Щелчок по пяти звездам означает отправку на сервер 
информации о рейтинге 5 .В этом случае данные,посланные на сервер,могут выглядеть так:
rating=5 .Допустим,страница,обрабатывающая эти рейтинги называется rateMovie.php, тогда 
код для отправки на сервер данных с помощью Ajax мог бы выглядеть так для метода GET:

$.get("rateMovie.php", "rating=5");

а для метода POST - так:

$.post("rateMovie.php", "rating=5");										

/*
jQUERY-функции get() и post() не требуют от нас задвания данных или функции обратного вызова
Нам нужно лишь сообщить URL-адрес серверной страницы.Однако почти всегда мы будет 
предоставлять данные.Например,в коде $.get("rateMovie.php", "rating=5"); посылаются только
URL-адрес и данные,никакая функция обратного вызова не задана.В данном случае посетитель 
просто отправляет рейтинг,и серверу нет необходимости отвечать,а функции обратного 
вызова что-либо делать
*/	

/*
									GET или POST?
1)В некоторых случаев у нас нет выбора.Например,мы посылаем информацию серверному сценарию 
который уже выполняется на нашем сервере.Иначе говоря,серверное программирование завершено,
и нам просто нужно тот метод который предусмотрен в сценарии.Это либо GET либо POST,нужно 
или узнать у программиста или самому просмотреть код и понять какой метод он использовал,
после чего выбрать функцию jQuery - get() или post()

2)Если еще не написан серверный сценарий,с которым наша программа javaScript будет общатся 
тогда мы сами должны выбрать метод.Метод GET подходит для запросов,которые не влияют на 
структуру базы данных или файлов на сервере.Например,для запроса цены товара или списка 
самыз популярных продуктов.Метод POST удобен для отправки данных изменяющих информацию на 
сервере,например,запрос на удалени файла,обновления базы данных или добавления новых записей

3)Оба метода применяются,однако существует ситуация,однозначно требующая метода POST.
Скажем,если мы отправляем на сервер форму,содержащую большой обьем  информации,например,
пост в блоге,который может состоять из сотен слов,в этом случае пользуемся методом POST.
Метод GET имеет встроенный лимит на обьем данных,которые можно посылать(зависит от разных 
браузеров но в средлнем составляет несколько тысяч знаков).

Как правило метод POST используется для отправки форм,а метод GET для страничок,переходы...
*/

Если нам нужно послать на сервер больше одной пары имя/значение вставьте между ними знак &

$.post("rateMovie.php", "rating=5&user=Вова");

Нам нужно аккуратно применять этот метод,поскольку некоторые знаки принимают специальное 
значение после вставки в строку запроса.Например,знак & служит для включения 
дополнительных пар имя/значение.Знак = присваивает значение имени.Следующая строка запроса
является некорректной: 

"favFood=Mac & Cheese" //неправильно

Знак & здесь является частью значения Mac & Cheese,но в составе строки запроса символ & 
означает вторую пару имя/значение.Если мы хотим использовать специальные знаки,то нам 
следует их кодировать или экранировать во избежания конфликтов с альтернативнимы 
значениями.Например,знак пробела кодируется как %20 , знак & как %26 ,а знак = как %3D 
Таким образом,предыдущий код следует переписать так: 

"favFood=Mac%20%26%20Cheese" //правильно 

Язык javaScript представляет для этих целей метод encodeURIComponent().Применим эту 
функцию к строке и она правильно ее зашифрует.Например:

var queryString = "favFood" + encodeURIComponent("Mac & Cheese");
$.post("foodChoice.php", queryString); 
  
  
2.Литерал обьекта.Для коротких и простых фрагментов данных(не содержащих знаки пунктуации)
метод строки запроса работает хорошо.Но более надежным способом,поддерживаемым функциями 
jQuery get() и post(),является использование литерала обьекта для хранения данных.Мы 
можем передавать литерал обьекта непосредственно функциям get() и post().Например :

$.post("rateMovie.php", "rating=5");//метод строковой записи

Для использования литерала обьекта перепишим код так:

$.post("rateMovie.php", {rating: 5});

Мы можем либо передать литерал обьекта непосредственно функции get() или post(),либо 
сначала сохранить его в переменной,а затем передать ее функции get() или post():

var data = {rating: 5};
$.post("rateMovie.php", data);


Мы можем включить любое количество пар имя/значение передаваемой функции get() или post():
	var data = {
		rating: 5,
		user: "Вова"};
	$.post("rateMovie.php", data);

Или если мы напрямую передаем:

$.post("rateMovie.php", {
		rating: 5,
		user: "Вова"});	

		
		
								jQUERY-функция serialize()
Создание строки запроса или литерала обьекта для всех пар имя/значение достаточно непросто
Мы должны будем извлечь имя и значение для каждого элемента формы,а затем обьединить их 
чтобы составить единую длинную строку запроса или большой литерал обьекта javaScript.
К счастью,jQuery предусматривает функцию,облегчающую процедуру конвертации данных формы в
информацию,которую могут использовать функции get() и post()

Функция serialize() может применяться к любой форме(или даже к выбранным элементам формы)
Для ее применения сначала нужно создать выборку jQuery,включающею форму,затем присоединим
функцию serialize().Например,у нас есть форма с идентификатором login.Если мы хотим 
создать для нее строку запроса,сделаем это следующим образом:

var formData = $("#login").serialize();

Код $("#login") - это выборка jQuery,содержащая форму.
Фрагмент .serialize() - собирает все имена элементов формы и текушие значения каждого 
элемента и создает единую строку запроса.  

Чтобы использовать эту строку с функциями get() или post(),просто передадим 
преобразованные функцией serialize() результаты в качестве второго аргумента после 
URL-адреса.Например,мы хотим послать содержимое формы login на страницу login.php.Для
этого используем такой код:

var formData = $("#login").serialize();
$.get("login.php", formData, loginResults);

loginResults - представляет собой функцию обратного вызова,которая берет данные,
возвращаемые с сервера и обрабатывает их								
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<										

	

									Обработка данных с сервера
Технология Ajax - это улица с двусторонним движением.Программа javaScript посылает данные 
на сервер,а тот в свою очередь возвращает ответные сведения программе javaScript,которая
может использовать их для обновления страницы.Браузер посылает запрос на сервер с помощью 
обьекта XMLHttpRequest и ожидает ответа.Когда он приходит функция обратного вызова 
обрабатывает его.Ей передаются несколько аргументов,первый из которых(самый важный) и 
определяет данные,возвращаемые сервером.
Мы можем форматировать сведения,возвращаемые сервером любыми способами.Серверный сценарий
возвращает число,слова,абзац текста или целую страницу.В случаях,когда сервер присылает 
большой обьем информации он часто использует форматы XML или JSON.
Второй аргуемт функции обратного вызова представляет собой строку,указывающую статус 
ответа.Чаще всего статус "success" означает,что сервер успешно обработал запрос и 
возвратил данные.Однако иногда обработка запроса не удается,например,был запрошен файл,
который уже не существует или произошла ошибка в серверной программе.В таких случаях 
функция обратного вызова получает сообщение со статусом "error".Функция обратного вызова
обрабатывает данные и обновляет страницу заменяя отосланную форму результатами полученными
с сервера или например,просто отображая на странице сообщение "request successful"

Чтобы разобраться с полным циктом запрос/ответ,рассмотрим пример с присвоением рейтингов
фильмам.После щелчка по ссылке рейтинга,рейтинг и идентификатор фильма посылается на 
сервер,программа(серверная) вносит эту информацию в базу данный,а затем возращает среднее
значение рейтинга для для данного фильма.Это среднее значение отображается на веб-странице.
Применив технологию Ajax,мы можем отослать рейтинг на сервер не покидая страницу,а 
используя ответ с сервера - обновить содержимое страницы.


Чтобы на данной странице обойтись без кода javaScript,каждая ссылка указывает на 
динамическую серверную страницу,которая может обрабатывать рейтинг,присвоенный посетителем.
Например,ссылка пятизвездочного рейтинга может иметь вид:

<a href="rate.php?rate=5&movie=123">Какой-то фильм</a>

rate.php --- Имя серверного файла обрабатывающего рейтинги
?rate=5&movie=123 --- включает двафрагмента информации для сервера: 
rate=5 --- рейтинг
movie=123 --- номер,который идентифицирует фильм

Мы можем использовать javaScript для перехвата нажатий на ссылки и преобразовать их в
Ajax-вызовы на сервер:
 
$("#message a").click(function(){
	var href= $(this).attr("href");//Извлекаем атрибут href для нажатой ссылки
	var querystring = href.slice(href.indexOf("?")+ 1);
	$.get("rate.php", querystring, proccessResponse);//Ajax запрос
	return false;//Блокируем переход по ссылке
});
//Ajax запрос.Используя метод GET запрос содержащий строку запроса для ссылки,направляется серверному файлу rate.php

Теперь нужно создать функцию обратного вызова.Она принимает данные и строку со статусом 
ответа("success", если сервер возвратил данные).В данном случае имя функции 
proccessResponse .Код для обработки ответа с сервера может выглядеть так:

function proccessResponse(data) {//Ответ сервера хранится в  - data
	var newHTML;
	newHTML = "<h2>Ваш голос учтен</h2>";
	newHTML += "<p>Средний рейтинг для этого  фильма составляет ";
	newHTML += data + ".</p>";//ответ сервера
	$("#message").html(newHTML);
}

data --- Функция принимает в качестве агрументов данные,которые являются информацией,
возвращенной сервером.Они могут быть текстом,документами формата HTML,XML,JSON.


В данном примере функция обратного вызова была определена за пределами функции $.get()
Однако мы можем использовать анонимную функцию,для того,чтобы держать весь код Ajax в 
одном месте:

$.get("file.php", data, function(data, status){
	//код функции обратного вызова 
});

Например код для прошлого примере может выглядеть так:

$.get("rate.php", querystring, function(data){
	var newHTML;
	newHTML = "<h2>Ваш голос учтен</h2>";
	newHTML += "<p>Средний рейтинг для этого  фильма составляет ";
	newHTML += data + ".</p>";//ответ сервера
	$("#message").html(newHTML);
});


								
									Обработка ошибок
При использовании Ajax для общения с сервером,что-то может пойти не так.Возможно сервер 
временно недоступен или посетитель внезапно отключился от сети.Если подобное происходит то
функция $.get() и $.post() не выполнят своих задач,а посетитель об этом даже не узнает.
Хотя такие проблемы возникают доволько редко,лучше подготовится и сообщить посетителям о 
том,что пошло не так,чтобы они смогли предпринять какие-нибудь действия(например,
перезагрузить страницу еще раз или вернутся позже).

Чтобы отреагировать на ошибку мы просто добавляем функцию .error() в конец функции $.get()
или $.post() .Базовая структура выглядит так:

$.get(url, data, successFunction).error(errorFunction);

Например мы можем переписать предыдущий пример так:

$.get("rate.php", querystring, processResponse).error(errorResponse);

Затем нужно создать новую функцию errorResponse которая информирует посетителя о 
возникновении проблем.Например:

function errorResponse() {
	var errorMsg = "Ваш голос не может быть обработан в данный момент";
	errorMsg += "Повторите попытку позже";
	$("#message").html(errorMsg);
}

Данная функция (errorResponse) выполняется только при возникновении ошибки,связанной 
с сервером или соединением.

/*
	Метод .error() не работает с функцией jQuery .load(),а также с запросом посылаемым на
другой сайт с использованием формата JSONP	
*/

								
							Получения XML-документа с сервера
XML является распостраненным форматом обмена данными между компьютерами.Подобно HTML,XML 
позволяет использовать HTML-элементы для идентификации информации.Но,в отличие от HTML 
мы можем придумывать имена элементов,точно отражающие содержимое наших данных.Например,
простой XML-файл может выглядеть так:

<?xml version="1.0" ?>
<message id="234">
	<from>Вова</from>
	<to>Жанна</to>
	<subject>Привет,Жанна</subject>
	<content>Жанна,давай вместе пообедаем</content>
</message>

Здесь есть главный элемент(называемый корневым элементом) <message> - эквивалент HTML 
элемента html - и ряд других элементов которые определяют значение каждого фрагмента 
данных.Мы можем использовать инструменты селектора jQuery для доступа к данным внутри 
XML-файла.Допустим,серверный XML-файл php возвратил XML-файл,приведенный выше,и мы хотим
извлечь текст,находящийся внутри элемента content.XML-файл становится возвращенной 
информацией,так что функция обратного вызова может обрабатывать его.Мы можем использовать 
jQuery-функцию find() для поиска внутри XML-файла определенного элемента CSS,используя 
любой селектор jQuery.Например,найти элемент,класс,идентификатор,дочерный селектор или 
фильтры jQuery:

$.get("xml.php", "id=234", processXML);

function processXML(data) {
	var messageContent = $(data).find("content").text();
}

Ключевым фрагментом здесь является код $(data).find("content") ,который поручает jQuery
выбрать каждый элемнт content в переменной data.Поскольку в данном случае переменная data 
содержит возвращенный XML-файл,этот код приказывает jQuery искать элемент content внутри
этого XML-файла


							
							
							
									Формат JSON
Популярный формат для отправки данных с сервера - JSON(JavaScript Object Notation - 
представление обьектов в JavaScript).Он написан на языке JavaScript и похож на формат XML
тем,что является методом обмена данными.Данные в формате JSON - это строка,форматированная
как обьект javaScript.Браузеры могут быстро и легко преобразовать данные в формате JSON
в код javaScript.C другой стороны,документ XML должен разбираться кодом javaScript,что 
замедляет его работу и требует более длительного программирования.Поэтому формат JSON чаще 
применяется для обмена данными с помощью технологии Ajax.
В сущности JSON представляет собой литерал обьекта javaScript, или коллекцию пар 
имя/значение.Вот пример данных JSON:

{
	"firstName": "Федор",
	"lastName": "Семенов",
	"phone": "495-333-1212"
}

Внутри скобок находится пары имя/значение,например,"firstName": "Федор".В отличие от 
обычнго обьекта javaScript имена свойств JSON и все строковые значения должны заключатся 
в двойные кавычки.Другими словами,следующий код некорректен:

firstName : 'Федор' //Не правильно 

А правильным является код:

"firstName": "Федор" //Правильно 

Когда веб-сервер отвечает на Ajax-запрос,он может возвратить строку в формате JSON.Сервер 
не посылает javaScript-код: он посылает текст,отформатированный как обьект JSON.
Использовать код javaScript невозможно до тех пор,пока строка не конвертирована в обьект 
JSON.К счастью,библиотека jQuery предусматривает специальную функцию $.getJSON(),которая 
заботится обо всех деталях.Функция $.getJSON() во многом похожа на функции $.get() и 
$.post().Базовый код для нее выглядит так:

$.getJSON(url, data, callback);

Три аргумента функции $.getJSON() аналогичны аргументам функции .get() и $.post():
url - URL-адрес серверной страницы
data - Данные посылаемые на серверную страницу
callback - имя функции обратного вызова

Дгугими словами функция $.getJSON() работает как функции .get() или $.post() но данные 
передаваемые функции обратного вызова,представляют собой обьект JSON.Таким образом чтобы
применить функцию $.getJSON(),нам нужно узнать как обрабатывать обьект JSON функцией 
обратного вызова.Например,мы хотим делать с помощью Ajax запрос по поводу какого-то 
контакта,содержащегося в серверном файле "contacts.php",этот файл возвращает данные 
контакта в формате JSON(как в примере ранее).Базовый запрос выглядит так: 

$.getJSON("contacts.php", "contact=123", processContacts);

Данный код посылает строку запроса contact=123 в файл contacts.php,который на основе этой 
информации находит запрашиваемый контакт в базе данных и извлекает необходимые сведения.
Результат отсылается браузеру и передается функции обратного вызова processContacts.
Базовая структура обратного вызова выглядит так:

function processContacts(data) {
	
}

Функция processContacts имеет один аргумент data,который содержит обьект JSON,полученный 
с сервера.


								Доступ к данным JSON
Есть два способа доступа к данным обькта JSON: "dot syntax" и "array notation".
1.Dot syntax или "точечный синтаксис",указывает на определенное свойство обьекта,что 
достигается путем вставки точки между именем обьекта и названием свойства,доступ к 
которому нужно получить.Мы уже не раз наблюдали этот процесс при работе со свойствами 
разных обьектов javaScript вроде строк и массивов.Например,код "abc".length предоставляет
доступ к свойству length строки и возвращает число букв в строке "abc",то есть 3 
Предполохим мы создали переменную и храним в ней литерал обьекта:

var bdate = {
	"person": "Павел",
	"date": "10/27/1980"
};

В этом случае переменная bdate содержит литерал обьекта,так что если мы хотим получить имя 
человека,содержащееся в обьекте,используем следующий точечный синтаксис:

bdate.person //"Павел"

Для даты рождения:

bdate.date //"10/27/1980"


Полная картина выглядит примерно так:
1.Мы посылаем запрос: 
$.getJSON("contacts.php", "contact=123", proccessContacts);

2.Например,сервер возвратил обьект JSON(аргумент функции обратного вызова):
var data = {
	"firstName": "Федор",
	"lastName": "Семенов",
	"phone": "495-333-1212"
};

Теперь внутри функции обратного вызова мы получаем доступ к значениям:
function proccessContacts(data) {
	data.firstName //"Федор",
	data.lastName//"Семенов"
}

Представим,что вся суть этой маленькй программы Ajax заключается в том,чтобы извлечь 
контактную информацию и показать ее внутри элемента div с иднтификатором info.Весь 
программный код может выглядеть так:

$.getJSON("contacts.php", "contact=123", proccessContacts);

function proccessContacts(data) {
	var infoHTML = "<p>Контакт:" + data.firstName;
	infoHTML += " " + data.lastName + "<br>";
	infoHTML += "Телефон: " + data.phone + "</p>";
	$("#info").html(infoHTML);
}

/*
	На выходе мы получили бы строки,добавленные на страницу,которые выглядят так:
	Контакт: Федор Семенов
	Телефон: 495-333-1212
*/


								Сложные обьекты JSON
Мы можем создать и более сложные коллекции данных,используя литералы обьектов в качестве 
значений внутри обьекта JSON,другими словами,литералы обьектов вложенные в другие литералы
обьектов.Вот пример: нам нужно,чтобы сервер послал контактную информацию для нескольких 
лиц,используя формат JSON.Мы посылаем запрос в файл "contacts.php" в виде строки,в которой
указывается,сколько контактов требуется возвратить.Этот код может выгядеть так: 

$.getJSON("contacts.php", "limit=2", proccessContacts);

Код limit=2 - это информация посылаемая на веб-сервер и указывающая число контактов,
которое нужно возвратить.Допустим контактная информация для первого лица совпадает с 
данными из предыдущего примера,а контактная информация второго лица содержится еще в 
одном обьекте JSON:

{
	"firstName": "Елена",
	"lastName": "Ивановна",
	"phone": "495-555-5235"
}

Веб сервер возвращает строку,представляющую единый обьект JSON,который обьединяет два 
обьекта:

{
	"contact1:" {
		"firstName": "Федор",
		"lastName": "Семенов",
		"phone": "495-333-1212"
	},
	"contact2:"{
		"firstName": "Елена",
		"lastName": "Ивановна",
		"phone": "495-555-5235"
	}
}

Предположим функция обратного вызова принимает единственный аргумент data(например,
function proccessContacts(data)).Тогда переменной data был бы присвоен обьединенный обьект
JSON так же,как если бы был выполнен следующий код: 

var data = {
	"contact1:" {
		"firstName": "Федор",
		"lastName": "Семенов",
		"phone": "495-333-1212"
	},
	"contact2:"{
		"firstName": "Елена",
		"lastName": "Ивановна",
		"phone": "495-555-5235"
	}
}

Теперь получим доступ к первому обьекту внутри функции обратного вызова:

data.contact1 

Извлечем первого контакта:

data.contact1.firstName

Поскольку в данном случае мы хотим обработать несколько контактов,библиотека jQuery 
предлагает функцию $.each(), позволяющую проработать в цикле данные из каждого элемента 
обьекта JSON.Базовая структура такова:

$.each(JSON, function(name, value) {
	
}); 

Пример:

$.getJSON("contacts.php", "limit=2", processContacts);
function processContacts(data) {
	var infoHTML = "";//Создаем переменную с пустой строкой
	$.each(data, function(contact, contactInfo) {//Обрабатываем каждый обьект JSON
		infoHTML += "<p>Контакт: " + contactInfo.firstName;
		infoHTML += " " + contactInfo.lastName + "<br>";
		infoHTML += "Телефон: " + contactInfo.phone + "</p>";
	});//конец each()
	
	$("#info").html(infoHTML);//Добавляем сгенерированный HTML-код на страницу 
} 

/*
	var infoHTML = ""; --- Создает пустую строку.Ее заполнит HTML-код,который в итоге 
будет добавлен на страницу.
	$.each(data, function(contact, contactInfo) {}); --- метод $.each() принимает обьект 
JSON в качестве первого аргумента (data) и анонимную функцию в качестве второго.	
	$.each(data, function(contact, contactInfo) {}); --- contact - это имя обьекта(в нашем
случае это "contact1:"  и "contact2:").
	$.each(data, function(contact, contactInfo) {}); ---- contactInfo - это литерал обьекта 
тоисть,само значение.

Другими словами contact - это "contact1:" и "contact2:", а contactInfo это 
	"firstName": "Федор",
	"lastName": "Семенов",
	"phone": "495-333-1212"
и
 	"firstName": "Елена",
	"lastName": "Ивановна",
	"phone": "495-555-5235"
*/

В результате получится следующий HTML-код:

<p>Контакт: Федор Семенов <br>
	Телефон: 495-333-1212</p>
<p>Контакт: Елена Ивановна <br>
	Телефон: 495-555-5235</p>
	

								
								
								Ведение в JSONP
Из сообщажений безопасности запросы Ajax ограничены тем же доменом.То есть страница,
посылающая запрос Ajax,должна находится на том же сервере,что и страница,на него 
отвечающая.Эта политика браузера для предотвращения несанкционированной связи одного 
сайта с другим.Однако это ограничение можно обойти.Хотя веб-браузер не может послать 
XMLHTTP запрос на другой сайт,он может загружать информацию с других сайтов,включая 
изображения,таблицы стилей и внешние файлы javaScript

Формат JSONP(JSON with padding) предоставляет возможность получать информацию с другого 
сайта.По сути,вместо создания запроса Ajax на другой сайт,мы загружаем сценарий,содержащий 
код JSON.Другими словами,это похоже на создание ссылки на внешний файл javaScript,
находящийся на другом сайте.

Однако мы не можем запросить любую информацию с другого сайта.Чтобы код JSONP сработал,
другой сайт должен быть настроен на ответ в формате JSONP.Большинство сайтов не настроены
на отправку информации таким способом,но многие крупные сервисы,например,Google Maps,
Twitter,Flickr,Facebook,Netflix,YouTube предлагают интерфейс программирования приложений
(API - Aplication Programming Interface),позволяющий нам запрашивать данные,вроде карты,
фотографии,рецензии на фильм...используя функцию библиотеки jQuery $.getJSON() 
Другими словами JSONP - позволяет извлекать данные JSON с другого сайта,запрашивая с 
этого сайта файл javaScript

						Добавление фрида сервиса Flickr на наш сайт
Сервис Flickr - это популярный сайт для обмена фотографиями.Он существует уже несколько 
лет и содержит миллионы фотографий.Сайт Flickr предоставляет нам два способа получения 
фотографий и относящейся к ним информации.Самым мощным,но и самым сложным методом является 
использование API сервиса Flickr для поиска фотографий.Этот метод требует от нас 
регистрации в системе Flickr и получения специального API ключа(строки чисел и символов,
которые нас идентифицируют).Также этот метод требует сложного программного кода.Проще 
всего использовать сервис Flickr Feed.Фид - это способ держать людей в курсе относительно 
изменений на сайте.Например,мы можем получить 20 последних фотографий от конкретного 
пользователя или группы.


								
								
								Построение URL-адреса
Сервис Flickr предоставляет несколько различных URL-адресов для получения доступа к фидам 
для разных типов фотографий(www.flickr.com/services/feeds/ -- полный список).Например,
мы используем адрес: www.flickr.com/services/feeds/photos_public.gne для получения доступа
к фотографиям с конкретных аккаунтов и ссылку для извлечения фотографий из конкретной 
группы.Как только мы определили,какой тип фида нам нужен,и URL-адрес который ему 
соответствует,нам нужно добавить дополнительную информацию для извлечения интересующих 
нас фотографий.Для этого мы добавляем строку запроса с несколькими фрагментами информации.
Строка запроса представляет собой знак ? в конце URL-адреса,за которым следует одна или 
несколько пар имя/значение(www.flickr.com/services/feeds/groups_pool.gne?id=250342342@N0231format=json)

1.Добавим один или несколько идентификаторов.Для выбора фотографий из конкретной группы 
или пользовательского аккаунта,мы добавляем символы id=,за которыми следует номер аккаунта
пользователя или группы.Например,для доступа к фиду группы "Веб Дизайн" мы используем 
фид группы и ее идентификатор так:

http://api.flickr.com/services/feeds/groups_pool.gne?id=37996591093@N01

Для пользовательских фидов Flickr мы используем фид общедоступных фотографий и один или 
несколько идентификаторов.Например,для извлечения фотографий из Смитсоновского института
(у котогоро есть аккаунт в Flickr) и библиотеки Конгресса мы можем использовать 
идентификатор и фид общедоступных фотографий:

http://api.flickr.com/services/feeds/groups_publick.gne?ids=8623520@N02,252862@N03

Чтобы использовать несколько идентифкаторов нужно отделять их запятой.
Чтобы узнать чей-то идентификатор можно использовать сайт: idgettr.com

2.Добавим формат JSON.Сервис фидов Flickr очень гибок и может возвращать информацию о 
фотографии во многих форматах от RSS до Atom,CSV,JSON.Чтобы сообщить серверу Flickr,что 
мы хотим получить данные в формате JSON,нам необходимо добавить в строку запроса фрагмент
&format=json .Например,чтобы получить фид в формате JSON мы используем такой URL-адрес:

http://api.flickr.com/services/feeds/photos_public.gne?ids=25053835@N03&format=json

Если мы введем этот адрес в адресную строку браузера,то увидим литерал обьектов содержащий
большой обьем информации.Вот что мы получаем от сервиса Flickr,когда используем функцию 
$.getJSON().Нам нужен код javaScript,чтобы разделить этот обьект,а затем использовать его
для построения небольшой галереи изображений.

//ЕСЛИ МЫ НЕ ДОБАВИМ format=json,ТО В ОТВЕТ ПОЛУЧИМ ДАННЫЕ В ФОРМАТЕ XML

3.Добавим к URL-адресу обратный вызов JSONP.Наконец,чтобы страница нашего сайта успешно 
запросила данные в формате JSON с другого сайта,мы должны добавить последний фрагмент к 
URL-адресу: &jsoncallback=? .По соображением безопасности мы не можем просто посталь
XMLHTTP запрос в другой домен.Чтобы обойти это ограничение,часть &jsoncallback=? сообщает
серверу Flickr,что мы хотим получать данные в формате JSONP и позволяет jQuery-функции 
$.getJSON() обрабатывать этот запрос так,как если бы браузер просто запрашивал внешний 
файл javaScript.Другими словами,для получения последних фотографий Смитсоновского 
института с сервера Flickr,мы должны передать функции $.getJSON() URL-адрес:

http://api.flickr.com/services/feeds/photos_public.gne?ids=25053835@N03&format=json&jsoncallback=?

	
								Поиск конкретных фотографий
В системе Flickr разрешено присвоить любому фото метку,содержащую одно или более слов.
Метка - это слово или короткая фраза,описывающая элемент фотографии.Например,мы можем 
отметить особенно яркую фотографию заката словом "закат".Любая фотография может иметь 
несколько меток,так что мы можем отметить фотографию заката ловами "закат,оранжевый,пляж"

Сервис Фидом Flickr предусматривает настройки,позволяющие нам искать конкретные метки:

1. tags --- Добавим в URL-адрес фрагмент tags(метки) и одно или несколько разделенных 
запятыми ключевых слов,например, &tags=fireworks,night .Чтобы найти фотографии фейерверков 
в ночном небе,мы можем использовать следующий URL-адрес:

http://api.flickr.com/services/feeds/photos_public.gne?tags=fireworks,night&format=json&jsoncallback=?

2. tagmode --- Обычно,когда мы ищем набор меток,система Flickr  извлекает фотографии,
соответствующие всем этим меткам.Например,мы добавили в фид ?tags=chipmunks,baseball,winter
Этот код находит только фотографии бурундуков,играющих в бейсбол зимой.Если нам нужны 
фотографии,связанные с бурундуками или бейсболом или зимой(другими словами,соответствующие
как минимум одной из меток),добавим в URL-адрес часть &tagmode=any .Например:

http://api.flickr.com/services/feeds/photos_public.gne?tags=chipmunks,baseball,winter&tagmode=any&format=json&jsoncallback=?

Разрешается комбинировать параметры поиска,чтобы уточнить выбор фотографий.Например,мы 
можем обьединить идентификатор с меткой,чтобы найти фотографии конкретного автора и 
конкретной вещи.Например,мы хотим получить фид с 20 последними фото бурундуков,которые 
сделали наши друзья:

http://api.flickr.com/services/feeds/photos_public.gne?ids=25053835@N03,862320@N02&tags=chipmunk&format=json&jsoncallback=?


							
								Использование метода $.getJSON()
Использование метода $.getJSON() для извлечения фотофида с сервиса Flickr работает так же
как и извлечение данных JSON с нашего собственного сайта.Базовая структура функции та же 
самая.Например,вот код извлекающий фид Flickr Смитсоновского института: 

var flickrURL = "http://api.flickr.com/services/feeds/photos_public.gne?ids=25053835@N03&format=json&jsoncallback=?";
$.getJSON(flickrURL, function(data){
	//какие-то действия над возвращенными данными JSON
});								

Создаем переменую flickrURL и сохраняем в ней URL-адрес.Затем посылаем запрос Ajax и 
подготавливаем анонимную функцию для обработки данных.После отправки Ajax-запроса код 
извлекает данные с сервера - в нашем примере эти данные посылаются анонимной функции и 
хранятся в переменной data.

/*
	Можно передавать данные напрямую ссылкой вроде: 
var flickrURL = "http://api.flickr.com/services/feeds/photos_public.gne?ids=25053835@N03&format=json&jsoncallback=?";
$.getJSON(flickrURL, function(data){
	//какие-то действия над возвращенными данными JSON
});

и потом обрабатывать,а можно создать общуу сылку,а потом в отдельном обьекте добавлять
все атрибуты:	
	
	var URL = "https://api.flickr.com/services/feeds/photos_public.gne?jsoncallback=?";	
	var searchInfo = {
		id: "25053835@N03",
		format: "json"
	};
	$.getJSON(URL, searchInfo, function(data){
		$("h1").text(data.title);//меняем название 
	});
	
	Или такой вариант:
	var URL = "https://api.flickr.com/services/feeds/photos_public.gne?format=json&jsoncallback=?";	
	var searchInfo = {
		id: "25053835@N03"
	};
	$.getJSON(URL, searchInfo, function(data){
		$("h1").text(data.title);//меняем название 
	});
	
Все три варианта рабочие	
*/

Если открыть скажем в браузере http://api.flickr.com/services/feeds/photos_public.gne?ids=25053835@N03&format=json&jsoncallback=?
то Обьект JSON системы Flickr содержит общую информацию о данном фиде в начале "title",
"link"...Элемент "title" - это название фида.В даном случае(Uploads from Smithsonian Institution)
Элемент "link" - указывает на главную страницу Смитсоновского института на сервисе Flickr
Мы можем использовать эту информацию в качестве заголовка на странице с фотографиями.
Для доступа к этой информации мы можем использовать точечный синтаксис:

data.title //data - это название переменой в функции обратного вызова,а title это уже то к чему мы обращаемся

Самая важная часть фида это свойство "items" ,содержащее дополнительные обьекты,каждый из 
которых включает информацию о фотографии.Каждый обьект внутри "items" представляет 
информацию о фотографии.Название фотографии,сылку на страницу фотографии,дату создания...
Другой важный элемент каждой фотографии - это обьект "media" .Например:

{
	"m": "http://farm7.static.flickr.com/6029/5988083516_bfc9f41286_m.jpg"
}

Часть "m" означает medium и ее значением является URL-адрес фотографии.Фотографии на 
сервисе Flickr часто бывают доступны в разных размерах,например,medium(средний),thumbnail(
эскиз), small.Если мы хотим отобразить изображение на странице,то URL-адрес это то что нам
нужно.Мы можем вставить на страницу элемент img и указать данную фотографию на сервере Flickr

 
Изменить фотографию:

Сервис Flickr использует следующие правила наименовани фотографий: путь к изображению 
среднего размера выглядит так: http://farm7.static.flickr.com/6029/5988083516_bfc9f41286_m.jpg
а путь меньше фотография так: http://farm7.static.flickr.com/6029/5988083516_bfc9f41286_s.jpg
Единственное отличие - в конце имени файла : "_m" - указвает на средний размер, "_s" -на 
маленький квадратный эскиз,"_t" - это небольшое изображение,самая длинная сторона которого
не привышает 100 пикселов, "_b" - самое большое изображение(1024 px в длину)

//Фид сервиса Flickr предоставляет максимум 20 изображений									
									
									
------------------------------------------------------------------------------------------
detach() --- Данный метод используется,чтобы удалить со страницы выбранныей HTML-элемент
или элементы,но не полностью избавится от них.Другими словами элемент списка отсутствует 
в списке,но все еще существует в памяти.								
------------------------------------------------------------------------------------------									
									

									
							Дополнительные возможности jQuery

Конструкция $() разнозначна функции jQuery().В статьях и блогах часто можно встретить:

jQuery("p").css("color","#F03");

Это тоже самое что и:

$("p").css("color","#F03");
									
Конструкция $() равнозначна функции jQuery() - они взаимозаменяемы.

/*
	Функцию $() использует еще одна библиотека javaScript - Prototype(www.prototypejs.org)
Если мы тоже применяем библиотеку Prototype на нашем сайте,то нам следует использовать 
функцию jQuery().Кроме того,специально для таких случаев в библиотеку jQuery включена 
функцию .noConflict() .Ее подробное описание - api.jquery.com/jQuery.noConflict/
*/

			Создание переменых для сохнанения вычеслительной мощности компьютера
	
$("#tooltip").html("<p>Турбкозуб</p>");	
$("#tooltip").fadeIn(250);	
$("#tooltip").animate({left: 100px},250);

При каждом обращении к $("#tooltip") вызывается функция jQuery() что замедляет работу 
Для ускорения работы достаточно было бы выбрать этот элемент $("#tooltip") один раз.
Один из способов:

$("#tooltip").html("<p>Турбкозуб</p>").fadeIn(250).animate({left: 100px},250);

Но иногда большими поэтому можно использовать пробелы:

$("#tooltip").html("<p>Турбкозуб</p>")
.fadeIn(250)
.animate({left: 100px},250);	
	
Можно поступить иначе - один раз вызвать функцию jQuery() и сохранить результат ее 
выполнения в переменной,которую затем можно будет использовать повторно:

var tooltip = $("#tooltip");
tooltip.html("<p>Турбкозуб</p>");	
tooltip.fadeIn(250);	
tooltip.animate({left: 100px},250);	

Теперь выборка элемента осуществается только один раз вместо 3х	
//Обычно для переменных с выборкой jQuery ставится $  var $tooltip = $("#tooltip");	это 
//делается для того,чтобы выделить переменные содержащие результат работы jQuery()
Тоже самое и для $(this).Когда мы используем $(this) проиходит неявный вызов jQuery()
поэтом чтобы сохранить вычеслительные мощности компьютера,нужно $(this) брать в переменную
а потом ссылатся на эту переменную:

$("a").click(function(){
	var $this = $(this);
	$this.css("color", "red");
	var href = $this.attr("href");
	window.open("href");
	return false;
});
	
	
На производительность страницы сказывается не обьем содержимого,а лишь частота обновления
Допустим мы хотим всплывающую подсказку:

$("#elementForTooltip").append("<div id='tooltip'></div>");
$("#tooltip").append("<h2>Заголовок подсказки</h2>");
$("#tooltip").append("<p>Содержимое подсказки</p>");
	
Данный код не оптимален,потому,что мы имеем 3 операции append(),3 раза меняя структуру 
модели DOM.Это создает нагрузку на браузер и если у нас получится уменьшить число 
модификаций модели DOM,производительность страницы заметно возрастет.Например:

var tooltip = "<div id='tooltip'><h2>Заголовок подсказки</h2><p>Содержимое подсказки</p></div>";
$("#elementForTooltip").append(tooltip);	

Этот код оптимален.Мы заминили 3 операции append() одной
//В зависимости от браузера но данный код(с одной append) будет работать в 20 раз быстрее 

Подводя итоги: если нужно добавить фрагмент  HTML-кода,делаим это с помощью одной 
операции,а не нескольких 

								
								Оптимизация селекторов
Приемы которые ускоряют работу операций поиска и повышают производительность программ на 
языке javaScript:

1.Используем идентификаторы везде,где только можно.Самый быстрый способ выбрать элемент 
на странице - использовать идентификатор.
2.Используем идентификатор в селекторе потомков.Предположим,что на странице нужно выбрать 
все элементы ссылок,а.Так получилось,что все эти элементы оказались в div с 
идентификатором main .Селектор $("#main a") сработает гараздо быстрее селектора $("a")
3.Применяем функцию .find() .Библиотека jQuery предусматривает функцию для поиска 
элементов в выборке.Она работатет подобно селектору потомков: ищет одни HTML-элементы
внутри других.Если вкратце,то сначала выполняется выбор элементов с помощью селектора 
jQuery,а затем применяется функция .find(),которой передается результат работы селектора 
Другими словами конструкцию $("#main a") можно записать так: $("#main").find("a");
Иногда замена селектора потомков функцией .find() приводит к тому,что поиск выполняется 
в два раза быстрее.
//Проверить скорость селекторов - jsperf.com/sawmac-selector-test

4.Избегать излишней детализации.Например,правило #main .slidebar .note ul.nav li a очень
конкретно,но может медленно обрабатываться функциями jQuery.Лучше использовать селектор 
потомков,который и короче и точнее,например $(".slidebar .nav a") или применить функцию  
.find() : $("#main").find(".slidebar").find(".nav a")


									Обход древа DOM
Чаще всего обход модели DOM происходит,когда мы присоединяем событие к одному элементу,а 
затем хотим выполнить некое действие над другим элементом.Допустим,существует элемент div 
с id="gallery",который содержит несколько эскизов изображений.Нужно,чтобы после щелчка по 
этому элементу что-нибудь происходило: изображение должно уменьшаться или увеличиваться.
Событие прикрепляется к элементу div таким образом:

$("#gallery").click(function(){
	
});
 
В функцию нужно добавить программный код для анимации изображений.Пользователь будет 
щелкать кнопкой мыши по элементу div,но реагировать должны изображения.В приведенном 
фрагменте мы выбрали элемент div,значит ключевое слово $(this) будет ссылатся на этот 
элемент.После выбора div нужно найти в нем все изображения.К счастью,в библиотеки jQuery
для этих целей существует функция .find() .Она предназначена для создания новой выборки на 
основе текущей,внутри существующей вборки выполняется поиск элементов,удовлетворяющих 
новому условию поиска.Для выбора изображений в элементе div добавим:

$("#gallery").click(function(){
	$(this).find("img");
});
 
$(this).find("img") - Cоздает новую выборку элементов,поскольку $(this) ссылается на 
элемент div функция find("img") выбирает все изображения внутри этого элемента.

$("#gallery").click(function(){
	$(this).find("img").fadeTo(500, 0.3).fadeTo(250,1);
});

Функция fadeTo() использует длительность и степень непрозрачности.Все изображения будут 
плавно исчезать,достигая степени непрозрачности 30% в течении 500мс,а затем вновь 
появляться достигать 100% непрозрачности в течении 250мс
 

						Наиболее полезные функции обхода древа DOM:

------------------------------------------------------------------------------------------
.find() --- Находит заданные элементы в текущей выборке.Мы записываем выборку jQuery,
добавляем к ней функцию .find() и передаем ей селектор CSS:

$("#gallery").find("img")

Этот код выполняет поиск всех изображений в элементе div с идентификатором gallery.Конечно
такой же результат можно получить используя селектор потомков,например $("#gallery img")
Однако функция .find() чаще всего применяется в ситуациях,когда когда приходится иметь 
дело с уже обработаным набором элементов.Функция .find() используется для поиска потомков,
элементов размещенных в теле другого элемента. 
------------------------------------------------------------------------------------------
	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
.children() --- Похожа на функцию .find().Она также принимает в качестве аргумента 
селектор,но выполняет поиск лишь в наборе непосредственных потомков текущей выборки.
Например,элемент div в теле которого содержится несколько других элементов div.Нужно 
сделать так,чтобы при щелчке по главному элементу появлялись изначально скрытые элементы,
обведенные крассным контуром.С помощью функции .find() эту задачу можно решить так:

$("#mainDiv").click(function(){
	$(this).find("div").show().css("outline", "red 2px solid");
});   

Однако если в одном из элементов,находящихся внутри основного,тоже содержится элементы div
возникает проблема.Код .find("div") выберет абсолютно все элементы div,в том числе и 
содержащиеся в других элементах.Может получится,что на странице будут обведены все 
имеющиеся элементы div,в то время как должны быть обведенны только непосредственно 
дочерние элементы div основного элемента div.Для решения данной проблемы перепишем этот 
фрагмент кода,воспользовавшись функцией .children() :

$("#mainDiv").click(function(){
	$(this).children("div").show().css("outline", "red 2px solid");
}); 

Теперь будут выбраны лишь непосредственные дочерние элементы основного элемента div и 
пропущены любые элементы,размещенные внутри дочерних элементов div 
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< 
 
------------------------------------------------------------------------------------------
.parent() --- В то время как функция .find() находит элементы,находящиеся внутри выбраного 
элемента,функция .parent() перемещается по дереву DOM в поисках родителя текущего элемента.
Такая функция удобна,например если мы присоединяем событие hover к элементам a,но при этом 
необходимо еще обработать элемент div(например,добавить рамку).В таком случае для поиска 
элемента div будет использована функция .parent() :

$("#gallery").hover(
	function() {
		var $this = $(this);
		$this.css("outline", "2px solid red");//Добавления контура к ссылке
		$this.parent().css("backgroundColor", "white");//Добавления фона к div 
	},
	function() {
		var $this = $(this);
		$this.css("outline", "");//Удаления контура ссылки
		$this.parent("backgroundColor", "");//Удаления цвета фона для div
	});

В этом примере при наведении указателя мыши на ссылку вокруг ссылки появится рамка,затем 
будет выбран родительский элемент этой ссылки и у элемента изменится цвет фона.После того 
как указатель мыши покинет ссылку,рамка пропадет,и цвет фона снова изменится на исходный.
------------------------------------------------------------------------------------------ 
 
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
.closest() --- Находит ближайшего предка,удовлетворяющего заданному селектору.В отличие от 
функции .parent(), которая выбирает непосредственно родителя текущего элемента,функция 
.closest() принимает в качестве аргумента селектор и находит ближайшего предка,
соответствующего этому селектору.Допустим мы емеет структуру:
<div>
	<a href="#"><img src="#"></a>
</div>
 
И нужно при клике на картинку отредактировать div:
 
$("#gallery img").click(function(){
	var $this = $(this);
	$this.css("outline", "2px red solid");
	$this.closest("div").css("backgroundColor", "white");
}); 

closest("div") - Ищет ближайшего предка,которым является элемент div.Ближайшим предком на 
самом деле является элемент a ,но поскольку это не div библиотека jQuery его пропустит и 
закончит поиск не раньше,чем найдет элемент div 
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< 
 
------------------------------------------------------------------------------------------
.siblings() --- Пригодится в случаях,когда нужно выбрать элемент,который находится на 
одном уровне с уже выбранным.Например,нам нужно чтобы при щелчке по ссылке остальные 
ссылки плавно исчезали или появлялись.Эффект должен быть применен ко всем ссылкам в том 
же элементе div.Иначе говоря,нужно выбрать все ссылки,находящиеся на одном уровне с 
нажатой.Мы можем добиться этого так:

$("#gallery a").click(function(){
	$(this).siblings().fadeTo(500, 0.3).fadeTo(250, 1);
});

Функция .siblings() также может принимать в качестве аргумента имя селектора,чтобы 
ограничить круг поиска нужным элементом:

$(this).siblings("a").fadeTo(500, 0.3).fadeTo(250, 1);
------------------------------------------------------------------------------------------
 
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
.next() --- Находит следующий элемент того же уровня в текущей выборке. 
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< 
 
------------------------------------------------------------------------------------------
.prev() --- действует так же,как и функция .next(),но ищет ближайший предшествующий 
элемент того же уровня.  
------------------------------------------------------------------------------------------ 
 
 
 
							Работа с цепочкой(Функция .end())

$("div").css("outline", "2px red solid").find("a").css("color", "purple");

Сначала выбыраются все элементы div к ним добавляется красный контур 2px,а затем 
выполняется новая выборка,ищится все элементы а в div, и меняет цвет ссылок на фиолетовый

Но иногда нужно вернутся к исходной выборке.Другими словами,сначала нужно выбрать,затем 
что-то еще,а потом вернутся к исходной выборке.Например у нас есть код:

$("div").click(function(){
	var $this = $(this);
	$this.fadeTo(250, 1);//Появление элемента div
	$this.find("h2").css("color", "#F30");
	$this.find("p").css("backgroundColor", "#F343FF");
});  
 
Для данного примера связывание функций является очень полезным: троекратный вызов функции 
$(this) можно легко заменить одним,выстроив цепочку из следующих друг за другом функций.
Однако при обьединении функций в цепочку могут возникнуть трудности: 

$("div").click(function(){
	var $this = $(this);
	$this.fadeTo(250, 1)
	.find("h2")
	.css("color", "#F30")
	.find("p")
	.css("backgroundColor", "#F343FF");
});
 
 
На первый взгляд тут все правильно,но после выполнения кода .find("h2"),который меняет 
выборку с элемента div на выборку сордержащую элемент h2 из div возникает проблема.При 
выполнении .find("p")  запустится поиск элементов абзаца p,в элементе h2,а не в div.
К счастью,в этом случае можно воспользоваться функцией .end(),чтобы отменить последние 
изменения и вернуться к исходной выборке.В этом фрагменте кода мы воспользуемся функцией 
.end() для возврата к выборке по элементу div,а затем выберем элементы абзаца p 
находящиеся в элементе div.Получим следующий программный код:

$("div").click(function(){
	var $this = $(this);
	$this.fadeTo(250, 1)
	.find("h2")
	.css("color", "#F30")
	.end()
	.find("p")
	.css("backgroundColor", "#F343FF");
});

 
Код .end() возвращает к исходному элементу div.И выборка будет идти не по h2,а по div
 
 
 
------------------------------------------------------------------------------------------
.wrap() --- Заключает каждый элемент выборки в пару HTML-тегов.Предположим мы хотим 
создать необычные подписи под изображением на странице.Выберем нужные изображение на 
странице и заключим их в элемент div класса figure,затем добавим в него элементы p
класса caption.(Далее этот класс нужно отформатировать c помощью CSS):

$("img").each(function(){
	var $this = $(this);//сохранение ссылки на текущее изображение
	var  caption = $this.attr("alt");//получение свойства alt для подписи
	$this.wrap("<div class='figure'></div>").after("<p>" + caption + "</p>");
}); 

Функция .wrap() может получать даже набор вложеных элементов:

$("#example").wrap("<div id='outer'><div id='inner'></div></div>");

//Эта функция просто добавляет тег,если его нету,если уже есть такой тег то она не  
//добавляет,а добавляет только там где его нету 
------------------------------------------------------------------------------------------ 
 
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
.wrapInner() --- Окружает HTML-элементами содержимое каждого элемента выборки.Предположим
код HTML содержит следующий фрагмент:

<div id="outer">
	<p>Содержимое элемента outer</p>
</div>  

Если браузер встретит вот такой программный код: 

$("#outer").wrapInner("<div id='inner'></div>");

то код станет таким:

<div id="outer">
	<div id='inner'>
		<p>Содержимое элемента outer</p>
	</div>
</div>
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< 
 
------------------------------------------------------------------------------------------
.unwrap --- Удаляет родительский элемент,окружающий выборку.Предположим на странице есть 
такой HTML-код:

<div>
	<p>некоторый абзац</p>
</div> 

Выполнения кода: 

$("p").unwrap(); 

изменит этот код таким образом:

<p>некоторый абзац</p>

Убрав div элемент.Функция .unwrap() - не принимает аргументов.Другими словами,не помещает 
ничего в круглые скобки функции
------------------------------------------------------------------------------------------ 
 
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
.empty() --- Удалит все содержимое элементов выборки,но сама выборка при этом останется.
Например,на странице находится элемент div с идентификатором messageBox.Средствами языка 
JavaScript в этот элемент динамически добавлять содержимое и отображать сообщения,
взяимодействуя с посетителями.Элемент div можно заполнить множеством заголовков,
изображений и абзацев текста,чтобы предоставить сообщения о статусе.В какой-то момент мы
можем очистить рамку,но не удалять ее,так мы сохраним возможность отображать сообщения 
в дальнейшем.Например:

$("#messageBox").empty();

Как и .unwrap(),функция .empty() не принимает аргументов 
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< 
 
 
 
							
										Работа со строками  
Можно передать функции .submit() функцию проверки как аргумент:

function verifyPasword() {
	var password = $("#password").val();
	if (password.length <= 6) {
		alert("Этот пароль слишком короткий");
	}else if (password.length > 15) {
		alert("Этот пароль сслишком длинный");
	}
}
 
$("form").submit(verifyPasword); 
 
Мы также можем присвоить эту функцию,событию blur(),когда пользователь будет покидать поле 
он будет получать сообщение,если ввел не правильно 
 
 
								Изменение регистра строки 
Язык javaScript предусматривает два способа смены регистра букв строки,так что мы можем 
изменить строки "привет" на "ПРИВЕТ" или "НЕТ" на "нет".Приведение строк к одному и тожу
же регистру облегчает процесс их сравнения.Например,мы создали викторину и одним из 
вопросов яляется "Как звали первого человека,побывавшего в космосе?".Для проверки ответа 
мы можем использовать такой код:

var correctAnswer = "Юрий Гагарин";
var response = prompt("Как звали первого человека,побывавшего в космосе?");
if (response == correctAnswer) {
	//правильно
}else {
	//неправильно
}
 
Правильный ответ "Юрий Гагарин",но если пользователь ввел "юрий гагарин" то укравляющая 
инструкция будет выглядеть так: "юрий гагарин" == "Юрий Гагарин".Получится так что 
пользователь ввел неправильный ответ,так как javaScript воспринимает буквы верхнего и 
нижнего регистра по-разному,строчные символы "ю" и "г" не будут соответствовать прописным 
"Ю" и "Г".Чтобы решить эту проблему,мы можем привести строки к одному регистру,а затем 
сравнить их:

if (response.toUpperCase() == correctAnswer.toUpperCase()) {
	//правильно
}else {
	//неправильно
}

В этом случае управляющая инструкция изменит регист строки ответа испытуемого и строки 
правильного ответа на верхний,так что строки "юрий гагарин" и "Юрий Гагарин" изменятся на 
"ЮРИЙ ГАГАРИН".

Чтобы изменить регистр на нижний,используем функцию toLowerCase() : 

var answer = "Юрий Гагарин";
alert(answer.toLowerCase());//"юрий гагарин"
 
Ни один из этих методов не изменяет исходную строку,содержащуюся в переменной - они просто 
возвращают эту строку,написанную либо строчеными либо прописными буквами.По этому в 
вышеприведенном примере переменная answer по-прежнему содержит строку "Юрий Гагарин",даже 
после появления окна оповещения.



							Поиск в строке: техника indexOf()
Язык javaScript предусматривает несколько техник поиска слова,числа или другой серии 
символов внутри строки.Поиск может пригодится в случае,если мы хотим узнать какой браузер 
использует посетитель для просмотра нашего сайта.Каждый браузер идентифицирует себя с 
помощью строки,содержащей множество различных статистик.Мы можем увидеть эту строку,
добавив следующий код на страницу:

alert(navigator.userAgent);


Navigator --- Это один из обьектов браузера
userAgent --- Содержит длинную строку данных,например,для браузера Internet Explorer 10,
работающего в Window 8 свойство userAgent имеет такое значение:
Mozilla/5.0(compatible; MSInternet Explorer 10.0; Window NT 6.2; Trident/6.0)
Поэтому если мы  хотим проверить,является ли браузер программой Internet Explorer 10,
мы можем просто поискать в строке userAgent фрагмент MSInternet Explorer 10.0;

Одним из способов поиска в строке является функция indexOf().Чтобы воспользоваться этим 
способом,необходимо после строки добавить точку,функцию indexOf() и искомую 
последовательность символов.Базовая структура такова:

string.indexOf("искомая строка");

Функция indexOf() возвращает число: если искомая строка не найдена то функция возвращает 
значение -1 .Так что если нам нужно проверить,был ли браузер программой Internet Explorer
то используем такой код:

var browser = navigator.userAgent;//это строка
if(browser.indexOf("MSInternet Explorer") != -1) {
	//Это браузер Internet Explorer
}

Если функция indexOf не находит "MSInternet Explorer" то возвращает -1 

Когда функция indexOf() Находит искомую строку она возвращает число,равное положению 
первого символа искомой строки:

var quote = "To be, or not to be";
var searchPosition = quote.indexOf("To be");
//Возвращает 0
 
Функция indexOf() начинает поиск с начала строки.Мы также можем начать поиск с конца 
строки, используя функцию lastIndexOf().Например:

var quote = "To be, or not to be";
var firstPosition = quote.indexOf("be");//Возвращает 3
var lastPosition = quote.lastIndexOf("be");//Возвращает 17


								
						Извлечение части строки с помощью метода slice()
Чтобы извлечь часть строки,используем метод slice() .Данная функция возвращает часть 
строки.Например,у нас есть строка http://www.sawmac.com и мы хотим избавится от части http://
Одним из способов это сделать является извлечение каждого символа строки,находящегося 
после части http:// :

var url = "http://www.sawmac.com";
var domain = url.slice(7);//www.sawmac.com

Функции slice() необходимо указать число с которого оно начинает вырезать финальную строку 
В данном примере число 7 указывает на индекс 8й буквы строки.Функция возвращает все 
символы начиная с указанного индекса до конца строки.Если мы не передадим функции slice()
второй аргумент,то она просто извлечет все символы начиная с указанного идекса.

Мы также можем извлечь определенное число символов строки,передав функции slice() второй 
аргумент.Базовая структура:

slice("начало", "конец");

Мы также можем указать отрицательные числа.Отрицательные числа ведутся от конца строки:

slice(-6, -1);


Метод slice() извлекает часть строки.Сама строка не меняется.Функция просто возвращает 
извлеченную строку которую мы можем сохранить в переменной.



								Регулярные выражения 
Иногра нам необходимо найти в строке не конкретное значение,а определенное сочетание 
символов.Например,нам нужно удостовериться в том,что при заполнении формы заказа 
посетитель вводит номер телефона в корректном формате.Мы не ищем конкретный номер телефона 
в вроде 495-333-1212 .Вместо этого мы ищем по общей маске: три цифры,дефис,три цифры, еще 
один дефис и еще четыре цифры.Мы хотим проверить значение введенное посетителем и если оно 
соответствует маске(например: 495-333-1212, 234-555-5454 ...) то все в порядке.Однако если 
введенное значение не соответствует маске(например: посетитель ввел 823ардар),то нам нужно 
отобразить сообщение вроде: "Неправильно введенные данные"


						Cоздание и использование регулярного выражения
Чтобы создать регулярное выражение на языке javaScript, мы должны создать обьект 
регулярного выражения,который представляет собой последовательность символов,заключенных 
между двумя слешами.Например,для создания регулярного выражения,которое соответствует 
слову "привет" мы можем ввести следующий код:

var  myMatch = /привет/;

Как открывающая и закрывающая кавычки создают строку,так открывающий / и закрывающий /
создают регулярное выражение.Существует несколько функций,использующих регулярные 
выражения.Самой простой из которых является функция search()
------------------------------------------------------------------------------------------
search() --- Работает подобно функции indexOf(),но вместо того,чтобы искать одну строку 
внутри другой,она ищет в строке маску(регулярное выражение).Например,мы хотим найти строку 
"To be" в строке "To be or not to be" :

var myRegEx = /To be/;//регулярное выражение не заключено в кавычки
var quote = "To be or not to be";
var foundPosition = quote.search(myRegEx);//Возвращает 0 

Если функция search() находит совпадение,то возвращает индекс первой буквы,а если не 
находит возвращает значение -1 .Поэтому в вышеприведенном примере переменная foundPosition
содержит значение 0,так как строка "To be" находится в самом начале строки.

search() работает точно также как indexOf() но регулярные выражение более точны и полезней.
Например,мы можем через indexOf() проверить есть ли на нашем сайте адрес http://www.sawmac.com
функция indexOf() проверит только этот адрес,а с помощью search() (или других регулярок) 
мы можем проверить все форматы URL-адрессов. 
------------------------------------------------------------------------------------------

 
							Построение регулярного выражения
Хотя регулярное выражение может состоять из слова или слов,чаще всего мы будем 
использовать комбинацию букв и специальных символов для определения маски,соответствия
которому мы собираемся искать.

Перечень наиболее часто используемых символов:
-------------------------------------------------------------------------------------------
.   --- Любому символу:букве,цифре,пробелу...
-------------------------------------------------------------------------------------------
\w  --- Любому символу,входящему в состав слова,включая буквы a-z,A-Z, цифры 0-9 и символы 
нижнего подчеркивания: _
Другими словами: буквенно-цифровой символ или нижнее подчеркивание
------------------------------------------------------------------------------------------
\W  --- Любому символу,не входящему в состав слова.Это полная противоположность символу \w
------------------------------------------------------------------------------------------
\d  --- Любой цифре от 0 до 9 
------------------------------------------------------------------------------------------
\D  --- Любому символу,кроме цифры.Это полная противоположность символу \d 
------------------------------------------------------------------------------------------
\s  --- Пробелу,табуляции,возврату каретки или новой строке 
Другими словами: любой пробельный символ
------------------------------------------------------------------------------------------
\S  --- Всем символам,кроме пробела,табуляции,возврата каретки или новой строки 
------------------------------------------------------------------------------------------
^   --- Началу строки.Полезен,когда нам нужно убедится,что перед строкой не находится ни 
один символ 
------------------------------------------------------------------------------------------
$   --- Концу строки.Используем знак $,чтобы удостовериться,что искомые символы находятся в 
конце строки.Например, /com$/ соответствует строке com,но только если эти буквы являются 
последними тремя буквами строки.Другими словами, /com$/ соответствует com в строке 
Infocom, но не в строке communication 
------------------------------------------------------------------------------------------
\b  --- Пробелу,началу строки,концу строки или любому небуквенному и нечисловуму знаку: 
+,= или " .Используем символ \b  для сопоставления начала или конца слова,даже если это 
слово находится в начале или конце строки
------------------------------------------------------------------------------------------
[ ]  --- Любому символу в квадратных скобках.Например,конструкция [aeiou] соответствует 
любой из этих букв в строке.Для диапазона символов используем дефис: [a-z] соответствует 
любой строчной букве, [0-9] соответствует любой цифре(тоже что и \d) 
------------------------------------------------------------------------------------------
[^ ]  --- Любому символу,кроме тех,которые находятся в квадратных скобках.Например,
[^aeiouAEIOU] соответствует любому символу,кроме гласных букв. [^0-9] соответствует любому
символу,который не является цифрой(тоже что и \D) 
------------------------------------------------------------------------------------------
|  --- Символу перед или после знака | .Например, a|b соответствует либо a либо b, но не 
обоим.						
------------------------------------------------------------------------------------------							
\   --- Используется для поиска буквального значения символов,используемых при построении 
регулярных выражений (*,.,\,/  ...)Например точка (.) в регулярном выражении означает 
"любой символ",но если мы хотим найти точку в строке,нам нужно указать это так \.						



Допустим нам нужно найти 6 цифр идущих подряд,для почтового индекса:

1.Найдем одну цифру.(Будем использовать \d)
2.Найдем шесть цифр,идущих подряд.Так как символ \d соответствует одной цифре,легко найти 
шесть цифр,используя такое регулярное выражение: \d\d\d\d\d\d
3.Найдем только 6 цифр.Наше регулярное выражение найдет 123456 в числе 123456789.Очевидно
что 123456789 - это не почтовый индекс ,поэтому нужно регулярка которая нацеливается 
только на шестизначные номера.Символ \b соответствует любому небуквенному или нечисловому 
знаку,так что мы можем написать \d\d\d\d\d\d\b .Мы также можем использоватьзнак ^ для 
сопоставления начала строки и символ $ для сопоставления ее окончания.Например,если 
посетитель ввел "вываыва888888фывфывфывфы" в поле почтового идекса формы заказа,то мы 
можем попросить этого посетителя прояснить(исправить) введенный индекс перед отправкой 
формы.Потому что мы хотели получить что-то вроде 888888(без других символов).В данном 
случае регулярное выражение будет иметь такой вид: ^\d\d\d\d\d\d$
4.Задействуем регулярное выражение.Допустим введенные данные уже содержатся в переменной 
zip и мы хотим проверить соответствует ли эти данные формату почтового индекса:

var zipTest = /^\d\d\d\d\d\d$/;
if (zip.search(zipTest) == -1) {
	alert("Это некорректный почтовый индекс");
}else {
	alert("Это корректный почтовый индекс");
}

Данный пример регулярного выражения работает,однако шестикратный ввод символа \d является 
не очень удобным.К счастью,язык javaScript включает несколько символов для сопоставления 
множетства одинаковых знаков.

Список символов для сопоставления нескольких экземпляров одного и того же знака:
------------------------------------------------------------------------------------------
?   --- Нулю или одному экземпляру предыдущего элемента,то есть наличие предыдущего 
элемента необязательно,однако если он присутствует,то может появиться только однажды.
Например,регулярное выражение colou?r соответствует и color, и colour но не colouur   
------------------------------------------------------------------------------------------ 
+   --- Одному или нескольким экземплярам предыдущего элемента.Предыдущий элемент должен 
появиться как минимум один раз 
------------------------------------------------------------------------------------------
*   --- Любому количеству экземпляров предыдущего элемента.Наличие предыдущего элемента 
необязательно,он может присутствовать в любом количестве.Например, .* соответствует 
любому количестве знаков 
------------------------------------------------------------------------------------------
{n}   --- Конкретному количеству экземпляров предыдущего элемента.Например, \d{3} 
соответствует трем цифрам,идущим подряд 
------------------------------------------------------------------------------------------
{n, }   --- Предыдущему элементу,присутствующему n или более раз.Например, a{2,} 
соответствует букве а,присутствующей в двух или более экземпляров,то есть будет 
соответствовать строке аа в слове ааrdvark и строке aaaa в слове aaaahhhh
(То есть в нашем случае не меньше 2х раз должно повториться аа)
------------------------------------------------------------------------------------------
{n,m}   --- Предыдущему элементу,присутствующему не менее n и не более m раз.Поэтому
\d{3,4} будет соответствовать трем или четырем цифрам подряд(но не двум или пяти цифрам подряд)



Например,чтобы сравнить пять цифр,мы можем написать : \d{5}



Допустим мы хотим найти в строке имя файла в формате GIF.Кроме того,мы хотим извлечь имя 
файла и каким-то образом его использовать в своем сценарии,иначе говоря нам нужно найти 
любую строку соответствующую базовой маске имени файла в формате GIF например,logo.gif,
banner.gif,ad.gif ...

1.Определим общую маску имен.Чтобы построить регулярное выражение,нас сначала нужно 
определить маску,с которой мы станем сравнивать строки.Поскольку мы ищем файлы в формате 
GIF мы знаем,что все имена будут заканчиваться частью .gif .Другими словами перед 
фрагментом .gif может находится любое количество букв,цифр или других символов 

2.Найдем часть .gif .Так как мы не можем просто написать .gif из-за того что точка - это 
любой символ,нужно поставить обратный слеш:  \.gif 

3.Найдем любое количество знаков перед частью .gif .Нам нужно найти соответствие чему-то 
вроде a.gif, photo.gif ,а не просто .gif .Чтобы найти любое количество знаков,мы можем 
использовать символы .+ означающие: "найди как минимум один(+) экземпляр символа (.)"
Однако если мы используем такое регулярное выражение у нас могут быть проблемы.Например,
у нас есть строка "file logo.gif" ,решулярное выражение .+\.gif будет соответствовать 
всех строке,хотя нам нужно получить только фрагмент logo.gif .Чтобы этого добиться 
используем символы \S ,соответствующие любому знаку,кроме пробела(новой строки,табуляции..)
Регулярное выражение \S+\.gif соответствует только имени logo.gif в строке.

4.Убедится в том,что после части gif ничего нет.С регулярными выражениями могут возникнуть 
сложности.Например,если мы применим созданное ранее регулярное выражение к строке email:
alex.gifford@example.com ,то получим результат alex.gif ,что вообще не является именем 
файла.Чтобы предотвратить это,нам следует удостовериться в том,что после части gif ничего 
нет.Для этого мы можем добавить границу \b например, \S+\.gif\b ,чтобы ислючить части 
других строк,включающих фрагмент .gif 

5.Сделать поиск нечувствительным к регистру.Есть еще одна проблема с регулярными 
выражениями: оно находит только файлы заканчивающиеся на .gif,однако .GIF - это тоже 
корректное расширение,тем не менее данное регулярное выражение не учтет имя файла вроде 
logo.GIF .Чтобы заставить регулярное выражение игнорировать различия между прописными и 
строчными буквами,используйте аргумент i:

/\S+\.gif\b/i

Аргумент i находится за пределами маски и справа от символа /,определяющего окончание 
маски регулярного выражение.

6.Задействуем регулярное выражение в коде.

var testString = "Файл logo.gif автор alex.gifford@example.com";//строка для проверки 
var gifRegex = /\S+\.gif\b/i;
var results = testString.match(gifRegex);
var file = results[0];//logo.gif
 

 
								Групировка частей маски
Мы можем использовать круглые скобки для создания подгруппы в пределах маски.Подгруппы 
могут пригодится для сопоставления нескольких экземпляров одной и той же маски.Например,
мы хотим проверить наличие строк Apr или April - обе начинаются с фрагмента Apr,так что 
станим сопоставлять эту часть,однако мы не можем использовать толкьо строку Apr для 
сравнения,так как она соответствует и части Apr в словах Apricot или Aprimecorp.Таким 
образом,мы должны сопоставить строку Apr,за которой следует пробел или окончание слова
(это символ \b) или строку April,за которой следует окончание слова.Иначе говоря строка 
il необязательна.Вот,как мы можем записать это используя круглые скобки:

var sentence = "April is the crulest month";
var aprMatch = /Apr(il)?\b/;

Обязательное наличие строки Apr и необязательное наличие подмаски(il).(? означает ноль или
один раз),Знак \b соответствует окончанию слова так что мы не получим результат вроде:
Apricot или Aprimecorp 

Чтобы предотвратить возникновение проблем с этим регулярным выражением мы можем добавить 
границу \b в его начале:

var aprMatch = /\bApr(il)?\b/;//В этом случае результатами не станут wApril или SApr

									
								Почтовый индекс
Cоздание регулярных выражений имеет всои сложности.Мы должны не только понимать принцип 
работы различных знаков,но и конструировать правльные маски.Например,при поиске 
соответстия почтового индекса,мы должны принимать во внимание тот факт,что почтовый индекс 
может содержать разное количество цифр: и шесть и пять и даже 5+4.
Например,почтовый идекс для России 6 цифр:

\d{6}

для США идексы содержат либо пять цифр либо пять цифр либо девять цифр(пять цифр за 
которыми следует дефис и еще 4 цифры).Вот пример для обоих вариантов:

\d{5}(-\d{4})?

\d{5} - соответствует 5ти цифрам,например 12345 
() - создаут единую маску
-\d{4} - соответствуют дефису и следующим за ним четырем цифрам: 1234 
? - либо ноль либо один экземпляр предыдущей маски.Вот где вступает в игру () :выражение 
(-\d{4}) воспринимается как единое целое,так что ? относится к этой к дефису и 4 цифрами
следующим за ними.Другими словами если мы получим первый пять цифр(\d{5}),например 12345 
то данное значение будет верным,так как значение в круглых скобках является необязательным


Чтобы убедится в том,что регулярному выражению соответствует вся строка,начнем регулярное 
выражение с символа ^ и завершим символом $ .Например,если мы хотим убедиться,что 
посетитель ввел в поле формы только почтовый индекс в корректном формате,используем 
регулярное выражение: ^\d{5}(-\d{4})?$ ,чтобы предотвратить получение ответа 
типа "бла 15789 бла бла"

								Телефонный номер								
Расмотрим формат телефоного номера,состоящего из трехзначного кода города,за которым 
следует семь цифр.Люди могут записать такой номер разными способами: 912-333-1212, 
(812) 333-1212, 812.333.1212 или просто 812 333 1212 .Регулярное выражение для данной 
маски будет таким:

\(?(\d{3})\)?[ .-](\d{3})[ .-](\d{4})


\(  - соответствует буквальному смыслу открывающей круглой скобки.Так как круглые скобки 
используются для группировки масок,то открывающая круглая скобка имеет особый смысл в 
регулярных выражениея.Поэтому мы ставим косую черту перед скобко обозначая тем самым что 
мы хотим просто скобку.
?   - ноль или один экземпляр(другими словами,наличие скобки не обязательно)
(\d{3})  - это подмаска соответствует трем любым цифрам 
\)?  - говорит о том,что наличие закрывающей круглой скобки не является обязательным  
[ .-]  - будет соответствовать либо пробелу либо дефису,либо точке.Обычно нам нужно 
использовать слеш(\.) чтобы сообщить интерпритатору javaScript о том что мы ищем 
соответствие именно в точке,а не любому символу.Однако внутри квадратных скобок точка 
всегда воспринимается буквально.
(\d{3})  - еще одна подмаска соответствующая любым трем цифрам 
[ .-]  - соответствует либо пробелу,либо дефису либо точке.
(\d{4})  - любые 4 цифры


							Адрес электронной почты 
Проверка правильности электронного адреса,введеного в поле формы,является распостраненной
задачей при обработке пользовательского ввода.Многие люди пытаются уклониться от 
предоставления настоящего электронного адреса,используя ответы типа "не ваше дело" или 
просто вводят адрес с ошибками(например, missing@sawmac.commm).Следующее регулярное 
выражение может проверить,содержит ли строка электронный адрес в правильном формате:

[-\w.]+@([A-z0-9][-A-z0-9]+\.)+[A-z]{2,4} 
//Данное регулярное не выясняет,является ли введенный адрес действующим,а просто проверяет его формат

[-\w.]+  - соответствует дефису,любому слову или точке,присутвтующим одни или более раз.
Таким образом,она будет соответствовать строкам "ivan", "ivan.ivanov","ivan-ivanov"
@  - это символ @,присутствующий в элекстронном адресе 
[A-z0-9] - соответствует одной букве или цифре 
[-A-z0-9]+   - соответствует одному или нескольким экземплярам буквы,цифры или дефиса 
\.   - соответствует точке например, sawmac.com 
+    - cоответствует одному или нескольким экземплярах в круглых скобках,например, bob@mail.sawmac.com  
[A-z]{2,4}   - любая буква,присутствующая 2,3,4 раза(com,ru) 


Приведенное регулярное выражение для электронного адреса не соответствует всем форматам 
адресов электронной почты.Так !#$%'*+-/=?^_`.{|}~@example.com является допустимым 
эдектронным адрессом,однако описанное в данном разделе регулярное выражение не будет ему 
соответствовать.Оно сконструировано для поиска наиболее вероятных адресов.Если мы хотим 
большей точности,используем следующее регулярное выражение:

/^[\w!#$%&\'*+\/=?^`{|}~.-]+@(?:[a-z\d][a-z\d-]*(?:\.[a-z\d][a-z\d-]*)?)+\.(?:[a-z][a-z\d-]+)$/i



									Дата
Дату можно записать разными способами,например, 28/09/2014, 28.09.2014, 28 09 2014 или 
даже 28-9-2014 .Поскольку наши посетители могут ввести дату как угодно,нам нужен способ 
позволяющий проверить ввели ли они дату в допустимом формате:

([0123]?\d)[-\/ .]([01]?\d)[-\/ .](\d{4})

[0123]?  - Соответствуют цифрам 0,1,2,3 и могут встречаться ноль или один раз.Поскольку 
40-го месяца не бывает,мы ограничиваемся этими четырьмя цифрами.Эта маска не является 
обязательной(на что указывает ?),так как посетитель может ввести 9 вместо 09 для указания 
девятого дня месяца 
 
\d  - соответствует любой цифре 
[-\/ .] - будет соответсвовать дефису,слешу,точке или пробелу.Например, 28/09/2014, 28.09.2014 
()  - определяют следующую подмаску,для месяца 
[01]? - соответствует либо 0 либо 1 ,а знак ? делает налиниче данной цифры необязательным 
Это первая цифра месяца.Она не может быть больше 1 , 22 месяца не существует.Кроме того,
если указаный месяц находится в диапазоне от января до сентября то мы можем получить 
5 вместо 05 .Вот почемему наличие этой цифры необязательно 

\d{4}  - соответствует любым четырем цифрам,например 1908 или 2880 


									Веб-адрес 
Проверка соответствия строки формату веб-адреса  используется,если мы просим посетителя 
ввести адрес его веб-сайта и хотим удостовериться,что он его ввел, или если мы хотим 
просмотреть некий текст и найти в нем все URL-адреса.Базовым регулярным выражением для 
URL-адреса является код:

((\bhttps?:\/\/)|(\bwww\.))\S*


|  - означает что регулярное выражение должно соответствовать либо части 1 либо части 2 
(часть 1 - это (\bhttps?:\/\/) ,  часть 2 - это  (\bwww\.), до | это часть 1,а после уже часть 2)


(  - означает начало внешней группы 
(  - означает начало внутренней группы(2я скобка)
\b  - соответствует началу слова 
http  - соответствует началу полного веб-адреса,начинающегося с http
s?   - означает,что присутствие буквы s необязательно.Поскольку веб-страница может быть 
передана через защищенное соединение,веб-адрес может начинаться с части https 

:\/\/  - соответствует символам :// .Так как слеш в регулярных выражениях имеет особое 
значение,мы должны поставить перед ним обратный слеш,чтобы он воспринимался буквально 

)  - это конец внутренней группы.Эта группа будет соответствовать либо http:// либо https://
|  - означает одну из двух групп  
(  - начало второй внутренней группы 
\b  - соответствует началу слова 
www\.  - соответствует части www.
)  - Это конец второй внутренней группы.Эта группа будет соответствовать URL-адресу в 
котором нет части http://, а будет начинатся с части www.
  
)  - Это конец внешней группы.На данном этапе регулярного выржения будет соответствовать 
тексту начинающемуся с http:// , https:// или www

\S*  - соответствует нулю или более знакам не являющимся пробелами 

/*
Данное выражение не является совершенным(например,оно будет соответствовать безсмысленному
адресу http://#$*%%*@*),однако оно достаточно простое и станет успешно находить 
соответствия настоящим URL-адресам,например: http://www.sawmac.com/missing/js/index.html
*/

Чтобы проверить содержит ли строка только URL-адрес(то есть перед  после URL-адреса ничего 
нет),используем символи ^ и $ в начале и конце регулярного выражения:

\b:^((https?:\/\/)|(www\.))\S*$


------------------------------------------------------------------------------------------
									Функция match()
Мы можем применить эту функцию к строке	не только для того,чтобы проверить наличие в ней 
маски,но также и для того,чтобы выделить эту маску для дальнейшего использования в 
сценарии.Например,в нашей форме присутствует текстовое поле,предназначенное для ввода 
комментариев посетителей.Возможно,мы хотим проверить содержит ли комментарии URL-адрес,
и есди да то извлечь этот URL-адрес для дальнейшей обработки.

Следующий код находит и извлекает URL-адрес используя цункцию match() :

var text = "мой веб-сайт: www.eksmo.ru";
var ulrRegex = /((\bhttps?:\/\/)|(\bwww\.))\S*/; 								
var url = text.match(ulrRegex);
alert(url[0]);//www.eksmo.ru

//Еcли мы хотели действительно проверить содержимое текстового поля формы: var text = $("#comments").val();

Переменная url содержит результат выполнения функции match() .Если маска регулярного 
выражения в строке не найдена,то результатом будет специальное значение null 
Если соответствие найдено,то сценарий возвратит массив,первым значением которого окажется 
соответствующий текст.В данном примере переменная url содержит массив,первым элементом 
которого является найденный текст.В этом случае массив url[0] содержит значение www.eksmo.ru

/*
В языке JavaScript значение null расценивается как значение false,так что мы можем 
проверить наличие соответствия так:

var url = text.match(urlRegex);
if (! url) {
	//совпадений нет
}else {
	//совпадение найдено 
} 
*/
									

Метод match() также предоставляет некоторые дополнительные сведения.В дополнение к массиву
чьим первым элемнтов является сопоставляемая строка,метод match() также возвращает 
свойсвтво index которое указывает на позицию в строке,где начинается совпадение.Например:

var string = "To be or not";
var regex = /be/;
var result = string.match(regex);
alert(result.index);//Выводит результат 3  	

В переменной result сохраняются значения,возвращаемые методом match().В данном случае 
есть массив,чей первый и единственный элемент является совпавшей строкой: переменная 
result[0] содержит текст be .Метод match() также добавляет к результату свойство index	
В данном примере это свойство имеет значение 3,так как строка be начинается на четвертой
позиции в строке.Это тоже значение которое было бы возвражено методом search(), или 
подобно методу indexOf().Кроме того это то же значение,которое мы использовали бы с 
методом slice(). 
							
						Нахождение всех экземпляров маски 
Функция match() работает двумя способами в зависимости от того,как мы построили свое 
регулярное выражение.В вышеприведенном примере метод возвращает массив с первым попавшимся
соответствующим текстом и свойство index,ссодержащее начальную позицию совпадающей строки
(а также дополнительные элементы массива если мы использовали подмаски в своем регулярном
выражении).Таким образом,если у нас была длинная строка,содержащая несколько URL-адресов
то только первый из них будет найден.Однако мы также можем активировать свойство 
регулярного выражения global, чтобы найти все совпадения в строке.

Мы делает поиск глобальным,добавляя аргумент g в конце регулярного выражения:

var ulrRegex = /((\bhttps?:\/\/)|(\bwww\.))\S*/g; 

Аргумент g находится после слеша /,который используется для заключения маски.
Это регулярное выражение производит глобальный поиск,при использовании с функцией match()
оно ищет каждое совпадение в сроке и возвращает массив,содержащий весь соответствующий 
текст,что является отличным способом нахождения,например,всех URL-адресов в сообщении 
блога или всех экземпляров слова в длинном тексте. 

Мы могли бы переписать код приведенный в начале раздела,используя глобальный поиск:

var text = "существует много оличных сайтов вроде www.litres.ru и http://www.eksmo.ru";
var ulrRegex = /((\bhttps?:\/\/)|(\bwww\.))\S*/g; 								
var url = text.match(ulrRegex);
alert(url[0]);//www.litres.ru
alert(url[1]);//http://www.eksmo.ru

Мы можем определить количество совпадений получив доступ к свойству length массива:

url.length

Этот пример возвратит число 2,так как в проверяемой строке найдены два URL-адреса.Кроме 
того мы получаем доступ к каждой найденной строке используя идекс массива,например,
url[0] -указывает на первое совпадение,а часть url[1] - на второе.

Глобальный поиск совместно с методом match не возвращает значение свойства index совпавшей
строки,а также какой-либо информации о подмасках.Глобальный поиск возвращает только массив 
содержащий каждое совпадение в рамках искомой строки. 
------------------------------------------------------------------------------------------									
									
									
								Замена текста 
Мы также можем использовать регулярные выражения для замены текста в строке.Например, у 
нас есть строка содержащая дату в формате: 28.10.2014 .Однако нам нужно,чтобы дата была 
в формате 28/10/2014 .Этого можно добиться с помощью функции replace() :

string.replace(regex, "replace");

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
replace() --- Функция replace() принимает два аргумента: 
1.Первый - это регулярное,которое мы хотим найти в строке
2.Второе - строка,заменяющая любое совпадение
Поэтому для изменения формата даты с 28.10.2014 на 28/10/2014 мы можем использовать:

var date = "28.10.2014";
var replaceRegex = /\./g;
var date = date.replace(replaceRegex, "/");
alert(date);//28/10/2014

/*
var replaceRegex = /\./g; - Создает регулярку,и ищет точку,a g означает глобальную заменту,
то есть замену каждого экземпляра точки.Если убрать g то замена произойдет только на 
первой найденной точке.
*/

							Использование подмасок для замены текста 
Функция replace() может не только заменять текст другой строкой но и запоминать подмаски 
в регулярном выражении и использовать их при замене текста.
Подмаска --- это любая часть регулярного выражения,заключенная в круглые скобки.Например,
(il) в регулярном выражении в регулярном выражении /Apr(il)?\b/	является подмаской.

Использование функции replace(), показанное в начале данного раздела изменяет строку 	
28.10.2014 на 28/10/2014 .Однако что если мы также хотим перевести даты в таких форматах,
как 28 10 2014 или 28-10-2014 в тот же формат 28/10/2014?Вместо того чтобы писать 
несколько строк кода javaScript для замены точек,пробелов и дефисов мы можем создать 
общую маску соответствующую любому из данных форматов:  

var date = "28-10-2014";
var regex = /([0123]?\d)[-\/ .]([01]?\d)[-\/ .](\d{4})/; 	
date = date.replace(regex, "$1/$2/$3");

Этот пример использует регулярное выражение для поиска соответствия формату даты.Каждая 
подмаска соответствует одной части даты(например ([0123]?\d)).Функция replace()	запоминает
строки,соответствующие этим подмаскам и может использовать их в качестве часте заменяющей 
строки.В этом случае заменяющая строка такова: "$1/$2/$3" . 
Знак $ за которым следует число представляет одну из соответствующих подмасок.Выражение 
$1 соответствует первой подмаске - числу.Таким образом эта строка переводится так:
"помести сюда первую подмаску,за которой следует /,подмаска,/и последняя подмаска"
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
								
									
									
									Работа с числами 
При использовании функции prompt() для извлечения пользовательского ввода,даже если кто-то 
введет 3.25 мы получим строку,содержащую число.Иначе говоря будет "3.25"(строка),а не 
число 3.25 .Часто этот метод не создает проблем,так как интерпритатор javaScript обычно 
конвертирует строку в число,когда считает,что это необходимо.Например:

var a = "3"'
var b = "4";
alert(a * b);//12 

В данном примере,несмотря на то,что обе переменные a и b являются строками, интерпритатор 
javaScript конвертирует их в числа,чтобы выполнить умножение и возвращает результат 12 
Однако когда мы используем операцию + ,интерпритатор javaScript не будет выполнять 
преобразование,и мы можем получить такой странный результат:

var a = "3"'
var b = "4";
alert(a + b);//34

В данном случае обе переменные a и b являются стрками.Операция + не только выполнит сложение 
но и обьединит две строки.Поэтому вмето результата сложения чисел 3 и 4 мы получим 
обьединение двух строк: 34 
									
Для преобразования строки в число язык javaScript предусматривает несколько способов:

1)Функция Number() - преобразует любую переданную ей строку в число:

var a = "3";
a = Number(a);//Переменная теперь является числом 3 

Таким образом проблема со сложением двух строк может быть решена так:
var a = "3"'
var b = "4";
var total = Number(a) + Number(b);//7

В целях экономии времени можно использовать операцию + ,которая делает тоже что и функция 
Number() .Просто добавим символ + перед переменной,содержащей строку и интерпритатор 
javaScript преобразует строку в число:
var a = "3"'
var b = "4";
var total = +a + +b;//7

Недостаток этих двух техник в том,что если строка содержит что-то кроме чисел,одной точки 
и знаков + или - в начале строки,то в результате мы получим NaN (не число)


2)Функция parseInt() - также пытается преобразовать строку в число.Однако в отличие от 
функции Number() метод parseInt() постарается преобразовать в число даже строку,содержащую 
буквы,если эта строка начинается с числа.Эта комана может пригодиться,когда мы получаем 
строку вроде "20 лет" в качестве ответа на вопрос о чьем-то возрасте:

var age = "20 лет";
age = parseInt(age);//20

Функция parseInt() ищет либо число, либо знак + или - в начале строки и продолжает искать 
числа,пока не встретит "нечисло".Таким образом,в вышеприведенном примере,функция 
возвращает число 20 и игнорирует оставшуются часть строки: " лет".

В дополнение к строковому значению метод parseInt() принимает второй аргумент radix,
который определяет какую систему счисления следует использовать.В большинстве случаев мы 
будем использовать привычную десятичную систему счисления.Однако это не единственный 
вариант.Существуют также восьмеричные и шестнадцатеричные числа.
//восьмеричные числа начинаются с 0,например 010

Таким образом,при использовании метода parseInt() всегда следует применять десятичную 
систему счисления 

var age = "010 лет";
age = parseInt(age, 10); //10


3)Функция parseFloat() похожа на функцию parseInt(),но мы используем ее когда строка может 
содержать десятичную дробь.Например,если у нас есть строка вроде "4.5 акра",то мы можем 
использовать функцию parseFloat() для извлечения всего значения,включая дробную часть:

var space = "4.5 акра";
space = parseFloat(space); //4.5

Если бы мы использовали метод parseInt() в предыдущем примере,то получили бы в результате 
просто число 4, так как функция parseInt() и извлекает только целые числа.


								Тест на числа 
При использовании кода javaScript для обработки пользовательского ввода нам часто нужно 
удостоверится что введенная пользователем информация соответствует определенному типу.
Например,если мы спрашивает год рожения человека,мы хотим быть уверены,что он введет число 
Точно так же,когда мы выполняем математические расчеты,если используемые данные не 
являются числами то наш сценарий не будет работать.
Чтобы удостовериться в том,что строка является числом, используем метод isNaN() 
Эта функция принимает в качестве аргумента строку и проверяет,является ли строка "нечислом"
Если строка содержит что-то кроме знака + или -(для положительных или отрицательных чисел)
за которыми следуют числа,а также десятичного значения(его присуцтвие необязательно),то 
она считается "нечилом",таким образом строка "-23.25" - является числом,а строка 
"24 писела" - нет.Этот метод возвращает либо значение true(если строка не является числом),
или false(если она является числом).Мы можем использовать функцию isNaN()в качестве части 
управляющей инструкции так:

var x = "10";//Это число
if (isNaN(x)) {
	//не число 
}else {
	//число
}


									Округление чисел 
Язык javaScript предусматривает способ округления дробных чисел,например, можно округлить 
4.5 до 5.Округление пригодится,когда мы производим расчеты,результатом которых должно 
стать целое число.Например,мы используем код javaScript,чтобы динамически устанавливать 
высоту элемента div в пикселях,основываясь на высоте окна браузера.Другими словами,высота 
элемента div рассчитывается используя значения высоты окна браузера.Любое вычисление 
может привести к получению десятичной дроби(например, 300.25),но так как нет такого 
понятия как .25 пикселов,нам необходимо округлить результат до ближайшего целого значения 
например 300. 

Мы можем округлить число,используя метод round() обьекта Math. Синтаксис этой функции 
несколько необычен:

Math.round(number)

Мы передаем дробное число(или переменную,содержащую дробное число)функции round(),а она 
возвращает целое число.

var decimalNum = 10.25;
Math.round(decimalNum);//10

/*
	Язык javaScript предусматривает два других метода для округления чисел:
Math.ceil() и Math.floor() .Они используются,как и метод Math.round(), но функция 
Math.ceil() всегда округляет число в большую сторону(например,Math.ceil(4.0001) 
возвращает число 5),а функция Math.floor() всегда округляет число в меньшую сторону: код 
Math.floor(4.9999) возвращает число 4
*/
 
							Форматирование значений в валюте 
При расчете стоимости заказа могут использоваться десятичные дроби: 9.99 .Однако даже если 
значение стоимости представлено целым числом,часто употребляется два нуля: 99.00 
Значение стоимости 8.9 записывается так: 8.90 .К сожалению,язык javaScript не воспринимает 
числа таким бразом: он отбразывает нули(например,10 вместо 10.00, 8.9 вместо 8.90)		
					
К счастью,чуществует метод toFixed(),который позволяет нам преобразовать число в строку,
соответствующую нужному количеству десятичных знаков.Чтобы использовать эту функцию,
добавим точку после числа(или после имени переменной,содержащей число) и часть toFixed(2):

var cost = 100;
var printCost = cost.toFixed(2) + "грн";//100.00грн 
								
Число которое мы передаем функции toFixed() определяет количество десятичных знаков.Для 
значений в валюте используем число 2,чтобы в результате получить такие значения как 100.00 или 
99.90 .Если мы используем число 3,то получим результат содержащий три десятичных знака: 
10.000 или 9.900 								
								
Если исходное число имеет больше десятичных знаков,чем мы указали то это число округляется 
до указанного количества знаков полсе запятой.Например:

var cost = 100.299;
var printCost = cost.toFixed(2)+ "грн";//100.30грн								
								
В данном случае число 100.299 округляется до 100.30

Функция toFixed() - применима только к числам.Если мы используем ее к строке то в 
результате получим ошибку:

var cost = "10";
var printCost = cost.toFixed(2)+ "грн";//ошибка

Чтобы обойти эту проблему нам нужно преобразовать строку в число:

var cost = "10";
cost = +cost;//или cost = Number(cost);
var printCost = cost.toFixed(2)+ "грн";//ошибка



							Генерация случайных чисел 
Язык javaScript предусматривает метод Math.random() для генерации случайных чисел.Данный 
метод возвращает случайное число от 0 до 1(например, .9716022342512141)Хотя нам могут быть 
не нужны подобные числа,мы можем использовать некоторые простые математические операции 
для генерации целого числа от 0 до какого-либо другого числа.Наример,чтобы сгенирировать 
число от 0 до 9 допустимо использовать такой код:

Math.floor(Math.random() *10);

Math.random() *10 - генерирует случайное число от 0 до 10(например, 4.12149004264842)
Math.floor - чтобы получить целое число,округляет любую десятичную дробь в меньшую сторону 
так например(3.1241435894230 становится 3, а .12408161759 становится 0)
//Для того чтобы задать число диапазона скажем от 0 до 25(Math.floor(Math.random() *25);)
//Так же можно испольовать для округления вместо Math.floor, Math.ceil() и Math.round()
  

						Выбор элемента массива случайным образом
Мы можем использовать метод Math.random() для случайного выбора элемента массива.
Использование функции Math.random() упрощает случайный выбор элемента массива:

var people = ["Иван", "Саша", "Ирина", "Вова"];
var random = Math.floor(Math.random() * people.length);
var rndPerson =  people[random];

Первоя строка создает массив.Вторая строка выполняет два действия: сначала она генерирует 
случайное число от 0 до числа элементов массива.Затем это число округляется в меньшую 
сторону с помощью функции Math.floor(),таким образом получатся числа 0,1,2,3
И последняя строка использует переменую random для указания индекса массива


						Функции для выбора случайного числа 
Функции - это отличный способ создания полезных фрагментов кода для многократного 
использования.Следующая функция вызывается с помощью двух аргументов:первый - наименьшее 
число диапазона,а второе - наибольшее число 

function rndNum(from, to) {
	return Math.floor((Math.random()* (to - from + 1)) + from);
}

Потом вызовим эту функцию:

var dieRoll = rndNum(1,6);//получения числа от 1 до 6


									Дата и время 
Если мы хотим отслеживать время и дату,нужно обратится к обьекту Date.Этот специальный 
обьект позволяет определить год,месяц,день недели,время и многое другое.Чтобы использовать 
его,нужно создать переменную и сохранить в ней новый обьект Date:

var now = new Date();

Команда new Date создает обьект Date,содержащий текущую дату и время.После его создания мы 
можем получить доступ к различным фрагментам информации относительно даты и времени,
используя различные методы.Например,чтобы выяснить текущий год,используем функцию 
getFullYear():

var now = new Date();
var year = now.getFullYear();

Фрагмент new Date() возвращает текущее время и дату,определенную компьютером пользователя.
Другими словами,если у кого-то на компьютере неправильно установлены часы,то дата и время 
не будет точны.

Перечень функций для доступа к частям обьекта Date:

getFullYear()  --- Год,например 2014 
getMonth()  --- Месяц,от 0 до 11:  0 - это январь,а 11 - это декабрь 
getDate()  --- Число месяца от 1 до 31 
getDay()  --- День недели от 0 до 6.  0 - это воскресенье,а 6 - это суббота
getHours()  --- Час от 0 до 23
getMinutes()  --- Количество минут от 0 до 59 
getSeconds()  ---Количество секунд от 0 до 59 
getTime()  --- Общее количество миллисекунд,прошедших с полуночи 1 января 1970 года 

							

							Получение информации о месяце 
Чтобы извлечь из обьекта Date число соответствующее месяцу,используем метод getMonth():

var now = new Date();
var month = now.getMonth();

Однако вместо того,чтобы возвращать число,имеющее какой-то смысл(например,1 для января),
эта функция возвращает число на единицу меньше.Например,январь - это 0,февраль - это 1 ... 
Если мы хотим извлечь привычное для нас число,нуэно просто добавить 1:

var now = new Date();
var month = now.getMonth() + 1;//привычное число 
	
Язык javaScript не предусматривает команды,сообщающейс название месяца.К счастью,странный 
способ нумерации месяцев может пригодится,когда мы хотим определить название месяца.Мы 
можем решить эту задачу,создав массив,содержащий названия месяцев,а затем получить доступ 
к названию,используя индекс этого месяца:

var months = ["Январь", "Февраль", "Март", "Апрель", "Май", "Июнь", "Июль", "Август", "Сентябрь", "Октябрь", "Ноябрь", "Декабрь"];
var now = new Date();
var month = months[now.getMonth()];//now.getMonth() возвращает число,и это число соответствует нужному месяцу в массиве



							Получение информации о дне недели
Функция getDay() возвращает день недели: 0 - воскресенье,а 6 - суббота.Поскольку название 
дня недели обычно полезнее для наших посетителей,мы можем использовать массив для хранения
названий дней недели и использовать метод getDay() для получения доступа к конкретному дню:

var days = ["Воскресенье", "Понедельник", "Вторник", "Среда", "Четверг", "Пятница", "Суббота"];
var now = new Date();
var day = days[now.getDay()];


							Получение информации о времени 
Обьект Date также содержит информацию о текущем времени,так что мы можем отобразить его 
на веб-странице или использовать время для определения того,в какой половине дня ее 
просматривает посетитель.Затем мы можем как-то использовать эту информацию,например,
отобразить фоновое изображение солнца в течении дня, или луны ночью.

/*
							Как работает обьект Date
Язык javaScript позволяет нам получить доступ к таким элементам обьекта Date,как год,число 
или месяц.Однако интерпритатор javaScript воспринимает дату как количество миллисекунд,
прошедших с полночи 1 января 1970 года.Например,среда,1 декабря 2014 года - это на самом 
деле - 1417420800000 для интерпритатора javaScript.

Это не шутка: для интерпритатора javaScript отсчет времени идет с 1 января 1970 года.
Эта дата(которая называется "Эпоха Unix")была выбрана в 70-х годах программистами,
работающими над операционной системой Unix,чтобы они могли договориться о способе 
отслеживания времени.С тех пор этот способ стал использоваться во многих языках 
программирования и платормах.

Каждый раз при использовании метода обьекта Date,например,getFullYear(),интерпритатор 
javaScript вычисляет текущий год(на основании количества секунд,прошедших с 1 января 1970 
года).Если мы хотим увидеть количество миллисекунд,соответствующей конкретной дате,мы 
используем метод getTime():

var sometime = new Date();
var msElapsed = sometime.getTime();

Отслеживание даты и времени в миллисекундах упрощает расчет разницы между датами.Например,
мы можем определить,сколько осталось до нового года,получив количество миллисекунд,которое 
должно пройти с 1.1.1970 до 1 января следующего года,а затем вычтя из получившегося 
значения количетсво миллисекунд,прошедшее с 1.1.1970 до сегодняшнего дня:

var today = new Date();//колличество миллисекунд с 1.1.1970 до сегодняшнего дня
var nextYear = new Date(2015, 0,1);//Количество миллисекунд с 1.1.1970 до 1-января 2015 
var timeDiff = nextYear - today;//Количество миллисекунд с сегодняшнего дня до нового года 

Результат вычитания одной даты из другой - это разница между ними в миллисекундах.Если мы 
хотим преобразовать это число в нечно полезное,просто разделим его на количество 
миллисекунд в дне:

var second = 1000;//1000 миллисекунд в секунду
var minute = 60 * second; //60 секунд в минуте
var hour = 60 * minute;//60 минут в часе
var day = 24 * hour;//24 часа в сутках
var totalDays = timeDiff/day;//общее количество дней 

//Вообщем легче в Интернете найти готовые решение 
*/

Мы можем использовать функции getHours(),getMinutes(),getSeconds() для получения значений 
часа,минут и секунд.Чтобы отобразить время на веб-странице,добавим следующий фрагмент в 
раздел HTML-кода,в котором мы хотим расположить часы:

var now = new Date();
var hours = now.getHours();
var minutes = now.getMinutes();
var seconds = now.getSeconds();
document.write(hours + ":" + minutes + ":" + seconds);

Этот код возвращает значение в виде 6:35:56,что означает 6 часов утра,35 минут и 56 секунд 
Однако он также может возвратить значение,которое нам не понравится,например, 18:4:9
для обозначения 18 часов,4 минут и 9 секунд.Проблема в том,что время должно отображаться 
в формате предусматривающем по два знака для минут и секунд,например 6:04:09


					Приведение показания часов к 12-часовому формату
Для изменения часового формата с 24-часового на 12-часовой нам нужно выполнить два 
действия.Сначала нам необходимо определить,показывают ли часы утренее время(тогда можно 
добавить после значения времени "до полудня" или "am") или вечернее(тогда добавить 
"после полудня" или "pt").Далее нам нужно преобразовать количество часов больше 12 в их 
12-часовой эквивалент(например,поменять 14 на 2 после полудня или на 2pm)

Например:

var now = new Date();
var hour = now.getHours();
var am_pm;
if (hour < 12) {
	am_pm = "am";//Определяет половину дня: если значение меньше 12 то это время до полудня am
}else {
	am_pm = "pm";//в противном случае - это время после полудня
}
hour = hour % 12;
if (hour == 0) {
	hour = 12;//12 на 12 = 0 ,поэтому нужно чтобы было не 0 ,а 12 
}
hour = hour + " " + am_pm;

/*
hour = hour % 12; - представляет математичискую операцию,называемую "Модулем" и 
обозначаемую знаком % .Он возвращает остаток от деления.Например,5 делится на 2 с остатком
1 .Иначе говоря 5 % 2 = 1 .Поэтому в данном случае,если значение часа равно 18 то
18 % 12 = 6 .Таким образом 18 часов равнозначно 6 часам после полудня или 6pm ,что нам и 
нужно.Если делимое меньше делится(например,при делении 8 на 12) то результатом будет 
исходное число.Например, 8 % 12 = 8 иначе говоря,операция модуля не меняет значение часа 
до полудня 
*/

							Отступы для одиночных цифр
Как обсуждалось ранее,когда значение минут или секунд не превышают десяти,то мы можем 
получить странный результат вроде 7:3:2 pm.Чтобы изменить этот результат на более 
привычный 7:03:02 pm, нам нужно добавить 0 перед одиночной цифрой.Это легко сделать с 
помощью просто управляющей инструкции:

var minutes = now.getMinutes();
if (minutes < 10) {
	minutes = "0" + minutes;//строка "0" добавляется к числу(minutes) 
}
//Мы не можем добавить число к переменной minutes, 0 + minutes -НЕ будет работать 
 
/*
	Пример готого времени(готовые часы):
	
function time() {
	var now = new Date();
	var hour = now.getHours();
	var minute = now.getMinutes();
	var second = now.getSeconds();
	if (minute < 10) {
		minute = "0" + minute;
	}
	if (second < 10) {
		second = "0" + second;
	}
	var showResult = hour + ":" + minute + ":" + second;
	return showResult;
}

function displayTime() {
	$('body').text(time());
}
	displayTime();
	setInterval(displayTime,1000);//будет вызывать функцию времени каждую секунду тем 
//самым на веб-странице каждую секунду будет тикать секунды 
*/

						Создание даты,отличающей от сегодняшней
Мы видели,как использовать функцию new Date() для получения текущей даты и времени на 
компьютере посетителя.Но что если мы хотим создать обьект Date для следующего Нового 
года или Рождества?Язык javaScript позволяет нам создать дату,отличную от сегодняшней 
разными способами.Мы можем это сделать рассчитав разницу между двумя датами: например,
"Сколько дней осталось до Нового года?" При использовании метода Date() мы также можем 
указать дату и время в будущем или в прошлом.Вот базовый формат:

new Date(год, месяц, день, час, минуты, секунды, миллисекунды);

Например,чтобы создать обьект Date для полудня 1-го января 2015 года:

var ny2015 = new Date(2015,0,1,12,0,0,0);

Этот код переводится так: "Создай новый обьект Date для 1 января,2015 года,12 часов,0 минут,0 секунд,0 миллисекунд"
Мы должны предоставить как минимум год и месяц,однако если нам не обязательно указывать 
точное время,то мы можем опустить миллисекунды,секунды,минуты...Например,чтобы просто 
создать обьект Date для 1 января 2015 года:

var ny2015 = new Date(2015,0,1);//0 это январь,отсчет начинается с 0 


					Создание даты отстоящей от сегодняшней на 1 неделю 
Так как интерпритатор javaScript воспринимает дату как количество миллисекунд,прошедших 
с 1 января 1970 года.Еще одним способом создания даты является передача значения,
представляющего количество миллисекунд,соответствующее этой дате:

new Date(миллисекунды);

Поэтому другим способом создания даты для 1 января 2015 года является:

var  ny2015 = new Date(1420099200000);

Мы не воспринимаем такую дату.Однако количество миллисекунд может пригодится при создании 
новой даты,которая отстоет от другой даты на определенное время.Например,при установке 
cookie,используя язык javaScript мы должны указать дату,когда данные cookie будут удалены 
из браузера посетителя.Чтобы быть уверенными,что cookie исчезнут через одну неделю нам 
нужно указать эту дату.Чтобы указать день через неделю:

var now = new Date();//сегодня,cохраняет текущую дату
var nowMS = now.getTime();//получаем количество миллисекунд,соответствующее сегодняшнему дню 
var week = 1000 * 60 * 60 * 24 * 7;//количество миллисекунд,соответствующее дню через 1 неделю 
var oneWeekFromNow = new Date(nowMS + week);

/*
var week = 1000 * 60 * 60 * 24 * 7; - Вычесляет общее количество миллисекунд в одной 
недели(1000 миллисекунд * 60 секунд * 60 минут * 24 часа * 7 дней)
var oneWeekFromNow = new Date(nowMS + week); - Создает новую дату,добавляя количество 
миллисекунд в неделе к сегодняшнему дню
*/

Нам не нужно беспокоится о разных часовых поясах,браузер сам все настроит.Для провери 
часового пояса можно использовать:

var now = new Date();
var offset = now.getTimezoneOffset();


							Оптимизация сценариев JavaScript
Ниже приведены пути ускорения работы и уменьшения количества строк кода:

1.Сохранение параметров в переменных.Например,мы хотим,чтобы при щелчке кнопкой мыши по 
фрагменту текста шрифта менялся на оранжевый:
 
$("p").click(function(){
	$(this).css("color", "F60");
});


Допустим мы хотим применить этот же цвет и на других этапах,вместо того чтобы использовать 
этот цвет напрямую,лучше создать переменную и поместить нужный нам цвет в эту переменную:
 
$("p").click(function(){
	var pColor = "F60";
	$(this).css("color", pColor);
});

$("td").hover (function(){
	$(this).css("backgroundColor", pColor);
},
function(){
	$(this).css("backgroundColor", "transparent");
});
						
Если в будущем мы захотим поменять цвет,то мы это сделаем только в переменной,а не будем 
искать во всем сценарии.

Данный код можно сделать еще более гибким создав вторую переменую:

$("p").click(function(){
	var pColor = "F60";
	var tdColor = pColor;
	$(this).css("color", pColor);
});

$("td").hover (function(){
	$(this).css("backgroundColor", tdColor);
},
function(){
	$(this).css("backgroundColor", "transparent");
});
							
Теперь призамене цвета можно сделать var tdColor = "red";
Особенно полезно помещать текст в переменные в начале сценария.Например, 
"Введите корректный электронный адрес" или "Спасибо за внимание",если группировать их 
в начале сценарие,то потом легче их редактировать. 

2.Сохранение параметров в обьектах.Более продвинутый способ - это сохранения параметров 
с помощью обьекта.В примере выше,много отдельных переменных,это не плохо просто в обьекте 
мы можем сразу все сгруппировать в одном обьекте,что более удобно:

var siteSettings = {
	highlightColor: "#33A",
	upArror: "ua.png",
	downArror: "da.png",
	imagePath: "/images/",
	delay: 1000 
};

$("p").css("color",siteSettings.highlightColor);

Мало того что этод поход держит все в одном месте,так он еще и позволяет избежать 
возникнования проблем при использовании одного и того же имени переменных. 


3.Тернарная операция.Часто в процессе программирования стоит задача присвоить значение 
переменной на основе,определенного условия.Например,нам нужно создать переменную,
содержащую текст со статусом авторизации пользователя.В нашем сценарии есть переменная 
login,содержащая логическое true,если посетитель авторизован,или false если не авторизован 
Вот один из способов создать переменную для этой ситуации:

var status;
if (login) {
	status = "Авторизован";
}else {
	status = "Не авторизован";
}

В данном случае базовая управляющая инструкция задает значение переменной status, 
основываясь на том,авторизован пользователь или нет.Язык javaScript предлагает простое 
решение этой задачи с помощью тернарной операции.Тернарная операция позволяет с помощью 
одной строки кода создать простую условную инструкцию.Базовый формат тернарной операции:

(условие) ? A : B 

В зависимости от результата условие операции возвращает A(если условвие истинно(true)) или 
B(если условие ложно(false)).Знак ? стоит перед значением true,тогда как знак : 
предшествует значению false.Так,например,приведенный выше код можно переписать:

var status = (login) ? "Авторизован": "Не авторизован";

Тернарная операция позволяет писать однострочные управляющие инструкции.В данном примере 
(login) - это условие,Если оно истинно возвращается код непостредственно следующий за 
знаком ? "Авторизован" .Если условие ложно,возвращает код непосредственно следующий за 
знаком : "Не авторизован"

Однако ее нельзя использовать по отношению к многострочным инструкциям,где выполнение 
строк кода зависит от определенного условия. 


4.Инструкция-переключатель.Предлагает более простой способ создания серий инструкций 
if/else.Например,мы просим посетителей нашего сайта ввести названия любимых цветов в поле 
формы,а затем отображаем разные сообщения в зависимости от выбранного цвета.Вот как можно 
написать часть такого кода,используя обычную управляющую инструкцию: 

if(favoriteColor == "голубой") {
	message = "Голубой - это холодный цвет.";
}else if (favoriteColor == "красный") {
	message = "Крассный - это теплый цвет.";
}else if (favoriteColor == "зеленый") {
	message = "Зеленый - это цвет листьев.";
}else {
	message = "Что это за цвет";
}

В этом коде много favoriteColor="значение".Если все,что нам нужно сделать - это несколько 
раз проверить значение переменной,то инструкция-переключатель предлагает более элегантное 
(и легкое для чтения) решения.Базовая структура:

switch (переменная) {
	case "значение1":
	//выполняется некоторое действие,если переменная == "значение1"
	break;
	case "значение2":
	//выполняется некоторое действие,если переменная == "значение2"
	break;
	case "значение3":
	//выполняется некоторое действие,если переменная == "значение3"
	break;
	default: 
	//действие запускается,если не выполняется ни одного из вышеперечисленных условий 	
}  

Первая строка операции начинается с ключевого слова switch,за которым следует имя 
переменной в круглых скобках.В сущности,код говорит
"Давайте получим значение переменной и посмотрим,совпадает ли оно с каким-либо другим значением"
Каждый тест называется case(случай).Ключевое слово case определяет начало случая,затем 
следует значение и  двоеточие.Значение переменной может быть числовым,строковым или 
логическим.Например,мы хотим проверить равно ли значение 37:

case 37: 
//какие-то действия
break; 

А чтобы проверить,является значение переменной истинным или нет:

case true: 
//какие-то действия
break; 

break - Операция выхода,определяет выход из инструкции-переключателя 

Вот как мы можем преобразовать код в начале раздела:

switch (favoriteColor) {
	case "голубой":
		message = "Голубой - это холодный цвет.";
	break;
	case "крассный":
		message = "Крассный - это теплый цвет.";
	break;
	case "зеленый":
		message = "Зеленый - это цвет листьев.";
	break;
	default: 
		message = "Что это за цвет";	
} 



						Обьединение массивов и разбиение строк
Иногда нам может потребоваться извлечь все элементы списка(массива) в виде строки,когда 
необходимо вывести на экран все содержимое массива.В этом случае мы можем использовать 
метод join()

------------------------------------------------------------------------------------------
join()  --- берет все элементы массива и преобразует их в одну строку.Элементы массива 
разделяются либо запятой,либо другим разделителем,который мы укажим.Например,

var days = ["Понедельник", "Вторник", "Среда", "Четверг", "Пятница", "Суббота", "Воскресенье"];
var weekdays = days.join();//Понедельник,Вторник,Среда...

Если мы не предоставим методу join() никаких аргументов,то в качестве разделителя будет 
использоваться запятая.Тем не менее мы можем выбрать любой другой разделитель:

var weekdays = days.join(":");//Понедельник:Вторник:Среда...

JavaScript не добавляет пробелов между элементами списка и разделителями поэтому,если нам 
нужно,чтобы за элементом следовала запятая и пробел:

var weekdays = days.join(", ");//Понедельник, Вторник, Среда...
------------------------------------------------------------------------------------------

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
split()  --- Мы можем взять строку и превратить ее в массив,используя метод split() ,
если в строке используется какой-либо разделитель,показывающий где заканчивается один 
элемент и начинается другой.Например,у нас есть такая строка: 

var weekdays = "Понедельник,Вторник,Среда,Четверг,Пятница,Суббота,Воскресенье";

Мы можем взять эту строку и разбить ее на массив:

var dayList = weekdays.split(",");//теперь это массив
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
//Можно привести к строке,вырезать что-надо,потом через split() привести к массиву,и сложить два массива и получится один 


						
						Ускорение загрузки файлов javaScript
При использовании внешних файлов javaScript,посетители почувствуют,что сайт стал работать 
быстрее.При первой загрузке,внешний файл хранится в кэше браузера,поэтому его повторной 
загрузки не требуется.Тем не менее существует еще один способ ускорить,загрузку 
содержимого нашего сайта - сжатие внешних файлов javaScript 

/*
Файлы,посылаемые по протоколу безопасных соединений (SSL - Secure Socket Layer),как 
правило не кэшируются.Поэтому,если посетители заходят на страницы нашего сайта,используя 
протокол https://(например, https://www.sawmac.com),то любые файлы,которые они загружают 
включая внешние файлы javaScript,должны загружаться всякий раз,когда они нужны.(Мы можем 
изменить настройки сервера,чтобы разрешить кэширование файлов,посылаемых по протоколу 
безопасных соединений)
*/

Чтобы сделать сценарий более понятным,программисты вставляют пустые строки,комментарии...
Все эти дополнения важны для программиста,но не для браузера,который все это прекрасно 
понимает и без табуляции,пустых строк или комментариев.С помощью программ сжатия мы можем 
минимизировать пространство,занимаемое кодом javaScript.Например,версия библиотеки jQuery
используемая в данной книге,является минимизированной и имеет размер файла,примерно вдвое 
меньше,чем размер несжатой версии.

Существуют программы для уменьшения размеров файлов javaScript.В качестве примеров можно 
привести JSMin(crockford.com/javascript/jsmin.html) и Packer(dean.edwards.name/packer)
Однако мы будем работать с тем же компрессором,который используется системой Yahoo 
(и библиотекой jQuery),поскольку он позволяет весьмя эффективно сжимать файл,не изменяя 
при этом его кода(некоторые компрессоры на самом деле переписывают код,что подчас может
даже повредить сценарий).JavaScript-компрессор Yahoo(YUI) доступен по адресу:
developer.yahoo.com/yui/compressor

Существует простой онлайн инструмент,который позволяет нам использовать компрессор YUI,
не устанавливая его на свой компьютер:

1.Запустим веб-браузер и посетим сайт:  refresh-sf.com 
Этот сайт посвящен онлайн-компрессору YUI 

2.Щелкним по вкладке YUI Compressor.Мы также можем сразу скопировать наши код и вставить в 
большое текстовое поле на домашней странице сайте.(В этом случае можем сразу перейти к шагу 4)

3.Найдем внешний файл javaScript на своем компьютере и перетащим его в большое тексторое 
поле на стрнице сайта.Файл должен содержать только код JavaScript.Например,мы не можем 
выбрать HTML-файл,который также содержит код на языке javaScript.

4.Нажмем кнопку JavaScript. Веб-сайт обработает наш код 

5.Нажмем кнопку Save .Теперь мы сохраняем сжатый файл на наш компьютер.Также после сжатия 
нам предоставляют такие данные,как исходный размер файла,размер нового файла и процентное 
значение сжатия.



							Диагностика и отладка ошибок
Консоль ошибок браузера Firefox предоставляет наиболее ясное описание синтаксических ошибок:

      Сообщение об ошибке Firefox        |                    Описание 
------------------------------------------------------------------------------------------
Unterminated  string literal             | Пропущена открывающая или закрывающая кавычка: 
(Незавершенный строковый литерал)        | var name = Жана";
                                         | Ошибка будет выдана и в случае использования 
                                         | разных видов кавычек:
							             | var name = 'Жана";
------------------------------------------------------------------------------------------
Missing) after arguments list            | Пропущена закрывающая круглая скобка при 
Пропущена ) после списка аргументов      | вызове функции или метода:
	                                     | alert("привет" ;  
------------------------------------------------------------------------------------------
Missing ) after condition                | Пропущена закрывающая круглая скобка внутри 
Пропущена ) после условия 	             | управляющей инструкции:
	                                     | if (x == 0
------------------------------------------------------------------------------------------
Missing ( before condition	             | Пропущена открывающая круглая скобка внутри
Пропущена ( перед условием	             | управляющей инструкции:
	                                     | if x == 0)
------------------------------------------------------------------------------------------
Missing } in compound statement          | Пропущена закрывающая фигурная скобка как 
Пропущена } в составной инструкции 	     | часть управляющей инструкции:
	                                     | if(score == 0) {
										 |	alert("игра окончена");
										 | //здесь пропущена }
------------------------------------------------------------------------------------------
Missing } after property list            | Пропущена закрывающая фигурная скобка для 
Пропущена } после списка свойств         | обьекта JavaScript:
                                         | var x = {
										 |	fName: "иван",
										 |	lName: "иванов"
										 |	//здесь пропущена }
------------------------------------------------------------------------------------------
Syntax Error                             | Общая проблема,мешающая интерпритатору  
Синтаксическая ошибка                    | JavaScript прочесть сценарий 
------------------------------------------------------------------------------------------
Missing ; before statement               | Попытка выполнить две инструкции,не разделенные
Пропущена ; перед инструкцией            | точкой с запятой.Это сообщение также появляется 
                                         | если мы неверно разместили вложенные кавычки:
                                         | var name = 'Жанна д'Арк';
------------------------------------------------------------------------------------------
Missing variable name                    | Попытка применить зарезервированное слово языка 
Пропущено имя переменной                 | javaScript в качестве имени переменной:
                                         | var if = "Syntax error";
------------------------------------------------------------------------------------------


console.log("%s Get %s", name, sirName); 
console.log(name + " Get " + sirName); 
//Это одно и тоже 

Сочетание %s - означает "замени меня значением переменной".Другими словами,первое 
сочетание, %s будет заменена значением переменной name,а второе сочетание %s - значением 
переменной score 

































































												
	
	
	
	
	
										
										
										
										Internet Explorer
Не все браузеры имеют встроеную функцию нахождения элементов по классу(IE8 и более рание версии),то такая библиотека как jQuery учитывает особенности всех браузеров просто бесценна									
			







				
										Полезные ссылки
									
api.jquery.com // Документация по jQuery, она написана для програмистов(кратко и технически) 									
http://api.jquery.com/category/selectors/ --- Полный список селекторов jquery 
http://api.jquery.com/category/manipulation/ ---Полный список функций которые добавляют и изменяют содержимое на странице
api.jqueryui.com/easings --- полный список методов (easing --управление скоростью анимации)
api.jquery.com/jQuery.queue --- более подробно как работает очередь эффектов
http://codepen.io/pens/ --- Обалденные примеры работы JS,CSS
http://plugins.jquery.com/ --- каталог плагинов 

									Плагины для навигации и прокрутки
http://xiper.net/collect/js-plugins/effects/scrollto  --- использование плагина для плавной прокрутки
https://github.com/flesler/jquery.scrollTo/blob/master/jquery.scrollTo.min.js -- и сама ссыллка на этот плагин прокрутки
http://plugins.jquery.com/ --- каталог плагинов 
http://www.sitepoint.com -- еще больший каталог плагинов но неудобно искать, все в куче
http://www.smartmenus.org/ --- плагин для навигационого меню,позволяет быстро создать меню навигации 
http://www.smartmenus.org/docs/ --- принципы работы и управления плагином smartmenus
http://jpanelmenu.com/ --- плагин создает меню навигации котороя выезжает при шелчке
http://multi-level-push-menu.make.rs/ --- еще один способ навигации котороя выезжает при шелчке,очень прикольная и хороша для большой колекции ссылок
speckyboy.com/2013/08/01/15-responsive-navigation-jqueryplugins --- большой список для навигации
jqueryvalidation.org --- Плагин jQuery Validation (для проверки форм)
jqueryvalidation.org/validate --- Полный список настроек 


api.jqueryui.com --- документация на плагин jQuery UI
http://jqueryui.com/dialog -- полный список вариантов и информации о виджете Dialog 
https://developer.mozilla.org/en-US/docs/Web/API/Location --- более детально об информации об URL-адресов
api.jqueryui.com/theming/icons/ --- полный список иконок для аккордеона 
api.jqueryui.com/datepicker/#utility-formatDate --- Полный список форматов,принимаемых выджетом Datepicker jQuery UI
api.jqueryui.com/datepicker/ --- Все параметры для виджета Datepicker
api.jqueryui.com/selectmenu --- Документация для виджета selectmenu(раскрывающие списки)
api.jqueryui.com/button/ --- документация на виджет button(документация маленькая и врятли будет нужна)

http://jqueryui.com/themeroller/ --- ThemeRoller редактирование тем плагина jQuery UI
developer.mozilla.org/en-US/docs/Web/CSS/cursor	 --- виды курсора(мыши)
api.jqueryui.com/draggable/ --- Полный список параметров виджета Draggable
api.jqueryui.com/droppable/ --- Полный список параметров виджета Droppable
api.jqueryui.com/sortable/ --- Полный список параметров виджета Sortable
api.jqueryui.com/sortable/#method-serialize	 --- документация на метод serialize
api.jqueryui.com/category/effects/ --- Документация на эффекты
api.jqueryui.com/easings/ --- Документация на easings

									Ajax
http://www.wbotelhos.com/raty/ --- Плагин для рейтинга(страница не грузилась в момент добавления в этот список)									
www.w3.org/Protocols/rfc2616/rfc2616-sec10.html  --- Полный список кодов ошибок(404...)
docs.jquery.com/Utilities/jQuery.each#objectcallback --- Документация на функцию $.each() для обработки данных с обьектов JSON 
www.flickr.com/services/feeds/ -- полный список URL-адресов для получения доступа к фидам с сайта Flickr
jsperf.com/sawmac-selector-test - Проверить скорость селекторов 

Использование документации:

api.jquery.com/category/selectors/ --- В эту категорию входят самые полезные функции jQuery.Здесь перечисленно много различных способов выбора элементов страницы.
api.jquery.com/category/attributes/ --- Функции jQuery,которые помогают получить и установить значение атрибутов
api.jquery.com/category/traversing/ --- Функции обхода модели DOM
api.jquery.com/category/manipulation/ --- В этот раздел документации включены сведения о функциях для редактирования страницы(например .html() или .text())
api.jquery.com/category/css/ --- Таблицы стиля css.Предназначены для получения или установки значений свойств,относящихся к таблицам стилей CSS.
api.jquery.com/category/events/ --- События.Можно запрограмировать реагировать на какие-либо действия.Например,наведения указателя мыши
api.jquery.com/category/effects/ --- Эффекты.Функции jQuery предназначены для создание эффектов (slideDoen() ...)
api.jquery.com/category/ajax/ --- Здесь перечислены функции,выполняющие динамические обновление страницы с информацией получаемо или отправляемой на веб-сервер.
api.jquery.com/category/utilities/ --- Библиотека jQuery содержит немало функций,которые могут упростить решение повседневных задач,например,помогают найти элемент в массиве,
обработать каждый элемент массива или любого другого обьекта(например each()).Возможно на данном этапе карьеры эти функции нам еще не понадобатся,однако позже,когда мы наберемся опыта они могут нам существенно упростить работу 

api.jquery.com/category/data/ --- На этой странице перечислены функции для внесения данных в элементы страницы.В библиотеки jQuery есть функция .data(),которая служит для записи данных в элемент  и позволяет добавить  пару имя/значение в 
любой элемент страницы.Элемент таким образом превращается в некое подобие небольшой базы данных.Эта и другие функции для работы с данными могут пригодится при разработке веб-приложения,в которых нужно сохранять данные или отслеживать изменения в них.
Неплохое обзорное руководство по использованию этих функций можно найти на странице: tutorialzine.com/2010/11/jquery-data-method/ 

api.jquery.com/category/deferred-object/ --- Отложенный обьект.Лучше даже не пытатся сейчас с этим разобратся - это довольно сложное понятие.(Во вступительной статье сказано,что отложенный обьект - это вспомогательный обьект,который можно включать в 
цепочки и который служит для регистрации нескольких обратных вызовов в очереди функций обратного вызова,обращения к очереди функций обратного вызова,а также сообщение об удачном или неудачном выполнении синхронных и асинхонных функций)
Этот обьект чаще всего применяется на соответствующей странице сайта с документацией по библиотеки jQuery

api.jquery.com/category/dimensions/ --- Здесь описаны функции для определения высоты и ширины обьектов.Эти же функции перечислены в категории CSS

api.jquery.com/category/internals/ --- Категория содержит много разнообразных функций.Например, свойство jquery возвращает версию библиотеки jQuery использующуюся на данной странице:
alert($().jquery);//например 1.6.2 
Скорее всего мы не разу так и не воспользуемся ни одной из этих функций 

api.jquery.com/category/offset/ --- В этой категории перечислены функции,определяющие местоположение обьекта относительно экрана или родительскоро элемента.
Эти функции используются при определении или задвании позиции элемента на странице

Регулярные выражения:
regexlib.com/Search.aspx?k=postal+code --- регулярка для почтовых индексов разных стран
regexlib.com/Search.aspx?k=phone+number --- регулярка для разных форм записи телефонных номеров 


Сайты по Минимизации файлов javaScript(чтобы сделать их примерно вдвое меньше):
crockford.com/javascript/jsmin.html  --- JSMin
dean.edwards.name/packer  --- Packer(Можно вставить онлайн код и посмотреть как будет выглядеть минимизированная версия)

developer.yahoo.com/yui/compressor  --- JavaScript-компрессор Yahoo позволяет весьмя эффективно сжимать файл,не изменяя 
при этом его кода(некоторые компрессоры на самом деле переписывают код,что подчас может даже повредить сценарий)
Для этого же компрессора YUI существует онлайн-инструмент который позволяет не загружать компрессор на наши компьютер refresh-sf.com выше инструкция


http://salvattore.com/  // Плагин который позволяет наложить сетку,и содержимое контента не будет распадатся при добавлении большего или меньшего содержимого 
bootsnipp.com/	--- Сайт где можно взять кучу готового кода по Bootstrap
												
												
												
												
												SASS
//http://sass-scss.ru/documentation/sassscript/tsvetovie_operatsii.html  - Документация на SASS на русском 
												
											Переменные
											
Переменные доступны только в пределах того уровня вложенности селекторов, на котором они определены. Если они определяются вне 
каких-либо вложенных селекторов, они доступны глобально. Если вы хотите, чтобы объявленная на каком-либо уровне вложенности 
переменная также была доступна глобально, вы можете определить её со специальной меткой !global. Например: 											
				
#main {
  $width: 5em !global;
  width: $width;
}

#sidebar {
  width: $width;
}	

компилируется в
		
#main {
  width: 5em;
}

#sidebar {
  width: 5em;
}

		
												
				Вложенности:

Если в scss написать:

body {
	background-color: $body-bg;
	h1 {
		font-size: $h1-font-size;
		color: $h1-color;
	}
	h3 {
		color: $h3-color;
	}
}

То в css мы получим:

body {
  background-color: aqua; }
  body h1 {
    font-size: 50px;
    color: orange; }
  body h3 {
    color: yellow; }												
										@import в SASS
Если написать @import в обычном css то для каждого @import требуется отдельный 
запрос http,а в SASS все @import грузятся до того как попадают на страницу клиента,а 
затем просто отсылаются клиенту одним файлом(один запрос http)
Например,у нас есть файл _common.css который мы хотим подключить к style.css,
нам нужно прописать:

@import "_common.css";  //Без нижнего подчеркивания

Это нижнее подчеркивание говорит SASS что не нужно его компилировать так как эти стили будут подключатся										
														
												
												Примеси / Mixins
Очень удобно использовать для повторного повторения свойств.Действует как обычная функция 

@mixin box-shadow($hor, $vert, $some1, $some2, $color) {
	box-shadow: $hor $vert $some1 $some2 $color;
}


h1 {
	@include box-shadow(1px, 1px, 1px, 1px, red);
}

h3 {
	@include box-shadow(1px, 1px, 1px, 1px, blue);
}												
												
												
//@mixin - это своего рода функция, а 	@include  примеся при после которой пишется название примеси											
								
Миксины могут быть также вызваны вне какого-либо правила (то есть в корне документа), при условии, 
что они не определяют непосредственно правил и не используют ссылку на родителя. Например:
								
@mixin silly-links {
  a {
    color: blue;
    background-color: red;
  }
}

@include silly-links;

компилируется в	

a {
  color: blue;
  background-color: red; }
	
	
Миксины также могут включать в себя другие миксины. Например:	
	
@mixin compound {
  @include highlighted-background;
  @include header-text;
}

@mixin highlighted-background { background-color: #fc0; }
@mixin header-text { font-size: 20px; }


В миксинах также можно определять значения аргументов по умолчанию, используя обычный синтаксис установки значений переменных. 
Затем, при подключении миксина, если ему не будет передан аргумент, то будет использовано значение по умолчанию. Например:

@mixin sexy-border($color, $width: 1in) {
  border: {
    color: $color;
    width: $width;
    style: dashed;
  }
}
p { @include sexy-border(blue); }
h1 { @include sexy-border(blue, 2in); }	



Иногда имеет смысл миксину или функции принимать неизвестное количество аргументов. Например, миксин для создания тени блока может принимать любое количество значений тени. 
Для подобных ситуаций Sass поддерживает возможность передачи "переменных аргументов" - это такие аргументы, которые передаются последними в функцию или миксин,
получают все остальные переданные параметры и упаковывают их в список. Эти аргументы выглядят как обычные, но после них следует многоточие. Например: 


@mixin box-shadow($shadows...) {
  -moz-box-shadow: $shadows;
  -webkit-box-shadow: $shadows;
  box-shadow: $shadows;
}

.shadows {
  @include box-shadow(0px 4px 5px #666, 2px 6px 10px #999);
}


компилируется в


.shadows {
  -moz-box-shadow: 0px 4px 5px #666, 2px 6px 10px #999;
  -webkit-box-shadow: 0px 4px 5px #666, 2px 6px 10px #999;
  box-shadow: 0px 4px 5px #666, 2px 6px 10px #999;
}


Переменные аргументы также можно использовать в миксинах. Используя тот же синтаксис, можно развернуть список значений так, 
что каждое значение будет передано как отдельный параметр или развернуть карту значений так, что каждая пара будет трактована как именованный аргумент. 
Например:

@mixin colors($text, $background, $border) {
  color: $text;
  background-color: $background;
  border-color: $border;
}

$values: #ff0000, #00ff00, #0000ff;
.primary {
  @include colors($values...);
}

$value-map: (text: #00ff00, background: #0000ff, border: #ff0000);
.secondary {
  @include colors($value-map...);
}

														Блоки контента в миксинах

@mixin apply-to-ie6-only {
  * html {
    @content;
  }
}
@include apply-to-ie6-only {
  #logo {
    background-image: url(/logo.gif);
  }
}

компилируется в

* html #logo {
  background-image: url(/logo.gif);
}

//Это даёт возможность создания абстракций, зависящих от конструкций селекторов или директив

											Область видимости переменных и блоков контента

Блоки контента, переданные в миксин, вычисляются в той же области видимости, где определён этот блок, а не миксин. 
Это значит, что локальные переменные миксина не могут быть использованы в передаваемом блоке контента и переменные будут восприняты как глобальные: 	


$color: white;
@mixin colors($color: blue) {
  background-color: $color;
  @content;
  border-color: $color;
}
.colors {
  @include colors { color: $color; }
}

компилируется в

.colors {
  background-color: blue;
  color: white;
  border-color: blue;
}


							


															Функции
Существует возможность определить собственные функции в Sass и использовать их в любом значении или контексте скрипта. Например:

$grid-width: 40px;
$gutter-width: 10px;

@function grid-width($n) {
  @return $n * $grid-width + ($n - 1) * $gutter-width;
}

#sidebar { width: grid-width(5); }

компилируется в

#sidebar {
  width: 240px; }

  
Также, как и миксины, определённые в Sass функции могут быть вызваны с именованными аргументами. В предыдущем примере мы могли бы вызвать функцию так:

#sidebar { width: grid-width($n: 5); }



												



  


												Наследование с помощью @extend 
												
.message {
	font-size: 50px;
	font-weight: bold;
	line-height: 20px;
	color: blue;
}

.success {
	@extend .message;
	color: green;
}

.warning {
	@extend .message;
	color: yellow;
}

.danger {
	@extend .message;
	color: red;
}

В результате font-size,font-weight,line-height будет наследоватся у класса message, а цвет для каждого 
из ниже классов будет свой 

Так же можно наследовать такое:

h3:hover{
	background-color: red;
}

p:hover {
	@extend h3:hover;
}
					
@extend не передается в медиа скрины,например:

НЕПРАВИЛЬНО:
p:hover {
	background-color:blue;
}


@media screen and (max-width: 700px) {

	body {
		@extend p:hover;
	}
}

ПРАВИЛЬНО:

@media screen and (max-width: 700px) {
	p:hover {
		background-color:blue;
	}
	body {
		@extend p:hover;
	}
}

//То что мы наследуем должно быть в media иначе выдаст ошибку 




					
												
												Ссылка на родителя селектора
Иногда полезно использовать родительский селектор с другим предназначением, чем по умолчанию. 											
												
a {
  font-weight: bold;
  text-decoration: none;
  &:hover { text-decoration: underline; }
  body.firefox & { font-weight: normal; }
}												
												
компилируется в:											
												
a {
  font-weight: bold;
  text-decoration: none; }
  a:hover {
    text-decoration: underline; }
  body.firefox a {
    font-weight: normal; }												
												
Символ & будет заменен на родительский селектор, каким он компилируется в CSS												
												
															
															
															Вложенные свойства
CSS имеет довольно много свойств в пространстве имен, например, font-family, font-size и font-weight находятся в пространстве имен font												
												
#lang scss
.funky {
  font: {
    family: fantasy;
    size: 30em;
    weight: bold;
  }
}
	
компилируется в:

.funky {
  font-family: fantasy;
  font-size: 30em;
  font-weight: bold; 
}


															Шаблонные селекторы
Sass поддерживает специальный тип селекторов под названием шаблонные селекторы. Они похожи на селекторы классов и идентификаторов, 
только вместо # или . указывается %. Они предназначены для использования с директивой @extend															
Сами по себе, без использования @extend, наборы правил, которые используют шаблонные селекторы, не окажут влияния на CSS. Например:															

%inline-type {
  display: inline-block;
  *display: inline;
  *zoom: 1;
  margin-right: -4px;
  vertical-align: top;
}

%for-grids {
    min-height: 1px;
    position: relative;
    padding-left: 10px;
    padding-right: 10px;
    margin-bottom: 20px;
}

.sgrid-N {
    @extend %for-grids;
}

компилируется в:	
												
.sgrid-N {
  min-height: 1px;
  position: relative;
  padding-left: 10px;
  padding-right: 10px;
  margin-bottom: 20px; }
												
												
														Комментирование
														
Sass поддерживает стандартный многострочный CSS комментарий, обозначаемый /* */, а также однострочный комментарий, обзначаемый //. 
Многострочные комментарии сохраняются на выходе в файле CSS, где это возможно, в то время как однострочные комментарии удаляются. 
Например: 												
			
/* Это многострочный комментарий.
 * Так как этот тип комментирования
 * поддерживается в CSS, то он
 * попадет в скомпилированный CSS-файл. */
body { color: black; }

// Это однострочный комментарий.
// CSS не поддерживает данный вариант комментирования.
// Поэтому данного комментария не будет в CSS-файле.
a { color: green; }


компилируется в:


/* Это многострочный комментарий.
 * Так как этот тип комментирования
 * поддерживается в CSS, то он и
 * попадет в скомпилированный CSS-файл. */
body { color: black; }

a { color: green; }


													Интерполяция
Мы также можете использовать переменные SassScript в селекторах и в названиях свойств используя синтаксис #{} интерполяции: 

$name: foo;
$attr: border;
p.#{$name} {
  #{$attr}-color: blue;
}
													
													
компилируется в

p.foo {
  border-color: blue; }													
													
													
														Медиа скрины
@media screen and (max-width: 600px) {
	body {
		background-color: red;
	}
}

Или так:

@media screen and (orientation: portrait) {
	body {
		background-color: red;
	}
}
														
//orientation: portrait нужно указать тип устройства.													
													
													
														!optional
Например если мы напишем 

p:hover {
	color:blue;
}

p {
	@extend p:hove !optional; //hover нету r,поэтому если мы не напишем  !optional будет ошибка,а так !optional говорит о том что это необязательно
}														
													
//!optional - создает метку необязательности													
													
													Директива @at-root
@at-root изымает одно или несколько правил из родительского селектора в корневой уровень документа. 
Такой способ можно использовать с селекторами первого уровня вложения: 													
													
.parent {
  ...
  @at-root {
    .child1 { ... }
    .child2 { ... }
  }
  .step-child { ... }
}													
													
компилируется в													
													
													
.parent { ... }
.child1 { ... }
.child2 { ... }
.parent .step-child { ... }

По умолчанию @at-root изымает только селекторы. Тем не менее, @at-root можно использовать и для изъятия селекторов, 
вложенных в директивы, таких как @media. Например: 													
													
@media print {
  .page {
    width: 8in;
    @at-root (without: media) {
      color: red;
    }
  }
}													
													
компилируется в													
													

@media print {
  .page {
    width: 8in;
  }
}
.page {
  color: red;
}

Вы можете использовать @at-root (without: ...) для изъятия из любой директивы. Также вы можете изымать селекторы сразу из нескольких директив, 
просто разделив их пробелами: @at-root (without: media supports) изымет элементы из запросов @media и @supports. 			
												
Команда @at-root (without: rule) имеет такое же значение, как и @at-root без запросов.
Команда @at-root (without: all) обозначает, что стили должны быть изъяты из всех директив и правил CSS												
												
												
													Директива @debug
@debug выводит значения функций Sass средствами стандартного вывода ошибок. Это полезно для отладки функций Sass, 
особенно для тех, что содержат сложную структуру данных. Например: 												
												
@debug 10em + 12em;												
												
получим результат:												
												
Line 1 DEBUG: 22em
												

//Наподобие console.log только в SASS 

													
													Директива @warn
Используется для предупреждения.В консоле просто выводится WARNING: значение.Например:

@warn HELLO;

WARNING: HELLO on line 41 styles.scss


													Директива @error
@error отображает значение выражений и функций Sass как фатальную ошибку.Просто выводит Error: значение 



													Директива @if

$type: monster;
p {
  @if $type == ocean {
    color: blue;
  } @else if $type == matador {
    color: red;
  } @else if $type == monster {
    color: green;
  } @else {
    color: black;
  }
}

//То же самое что и в JS только через @ и без скобок 




														Директива @for
Директива имеет две формы: @for $var from <начало> through <конец> и @for $var from <начало> to <конец>. Заметьте различие в словах through и to. 
$var может быть любым именем переменной, таким как $i; <начало> и <конец> - выражения SassScript, которые должны возвращать целые числа. 
Если <начало> больше, чем <конец>, счётчик будет убывать, вместо того, чтобы расти.
Форма from ... through, диапазон включает значения <начало> и <конец>, а форма from ... to не включает значение <конец>. При использовании синтаксиса through

@for $i from 1 through 3 {
  .item-#{$i} { width: 2em * $i; }
}

компилируется в

.item-1 {
  width: 2em; }
.item-2 {
  width: 4em; }
.item-3 {
  width: 6em; }


А при использовании to:

@for $i from 1 to 3 {
  .item-#{$i} { width: 2em * $i; }
}

компилируется в

.item-1 {
  width: 2em; }
.item-2 {
  width: 4em; }



  
														Директива @each
Директива @each обычно имеет вид @each $var in <список или карта значений>. $var может быть любой переменной, такой как $length или $name, 
и <список или карта значений> - это выражение SassScript, возвращающее список или карту значений. Директива @each устанавливает $var в 
каждое из значений списка или карты и выводит содержащиеся в ней стили, используя соответствующее значение $var. Например: 

@each $animal in puma, sea-slug, egret, salamander {
  .#{$animal}-icon {
    background-image: url('/images/#{$animal}.png');
  }
}


компилируется в

.puma-icon {
  background-image: url('/images/puma.png'); }
.sea-slug-icon {
  background-image: url('/images/sea-slug.png'); }
.egret-icon {
  background-image: url('/images/egret.png'); }
.salamander-icon {
  background-image: url('/images/salamander.png'); }


Директива @each также может использовать несколько переменных по следующему принципу:

@each $animal, $color, $cursor in (puma, black, default),
                                (sea-slug, blue, pointer),
                                (egret, white, move) {
  .#{$animal}-icon {
    background-image: url('/images/#{$animal}.png');
    border: 2px solid $color;
    cursor: $cursor;
  }
}

компилируется в

.puma-icon {
  background-image: url('/images/puma.png');
  border: 2px solid black;
  cursor: default; }
.sea-slug-icon {
  background-image: url('/images/sea-slug.png');
  border: 2px solid blue;
  cursor: pointer; }
.egret-icon {
  background-image: url('/images/egret.png');
  border: 2px solid white;
  cursor: move; }


Так как мапы обрабатываются как списки или пары значений, множественное присваивание с ними тоже работает. Например: 

@each $header, $size in (h1: 2em, h2: 1.5em, h3: 1.2em) {
  #{$header} {
    font-size: $size;
  }
}

компилируется в


h1 {
  font-size: 2em; }
h2 {
  font-size: 1.5em; }
h3 {
  font-size: 1.2em; }


														
														Директива @while
Директива @while принимает выражение SassScript и циклично выводит вложенные в неё стили, пока выражение вычисляется как true. 
Она может быть использована для создания более сложных циклов, чем тех, для которых подходит @for, хотя она бывает необходима довольно редко. 
Например:

$i: 6;
@while $i > 0 {
  .item-#{$i} { width: 2em * $i; }
  $i: $i - 2;
}

компилируется в

.item-6 {
  width: 12em; }

.item-4 {
  width: 8em; }

.item-2 {
  width: 4em; }




											
											
											
											GIT
Первое что нужно сделать это включить свои данные в GIT так как при коммите эти данные будет показыватся

git config --global user.name "Alexey Kapitonenko"
git config --global user.email "Alexey Kapitonenko"

//global достаточно сделать 1н раз,и настройки будут использоватся всегда

git config --list    --- Для просмотра данных включая user.name и user.email
git help remote   --- Показывает информацию о любой команде (в данном случае о remote)
git init  --- Что бы создать репозиторий нужно написать  
git status   --- Для просмотра статуса(какие файли отслеживаются,а какие нет)  
git add   --- Добавить файлы для отслеживания 
git add .   --- Точка означает - добавить все файлы  
git add "*.php"   --- Добавить все файлы расширения .php  
git commit -m "first commit" --- коммит "first commit" -это коминтарии
git clone https://github.com/jquery/jquery.git  --- клонирует(скачивает)
git rm --cached -r docs/   --- Удаляет папку docs и все что в ней находится 
git push -u origin master --- Заливает на выбранный репозиторий и ветку коммиты 
/*
	origin  Название репозитория на удаленном сервере 
	master  Название ветки 
	-u   - это ключ,при следующем пуше автоматически будет заливатся именно в это месте,без этого ключа прийдется каждый раз прописывать путь куда нужно заливать 
*/

git fetch   --- Копирует изменения в папку .git(которую не видно) и больше никуда 
git pull   --- Копирует изменения в наши файлы,например другой разработчик добавил что-то на удаленный репозиторий и чтобы не клонировать весь проект,мы можем при помощи этой команды скопировать только то что он изменил или добавил 

git config --global push.default simple   ---Стоит По умолчанию, при пуше заливается только та ветка которую мы пушим 
git config --global push.default matching   ---Если на удаленном резозитории залито 2 ветки а в гите допустим 3 до зальются 2 ветки которые там уже есть,если на удалленом резозитории 1 ветка из 3х то загрузится 1 ветка  

git commit -a -m "init"   --- Здесь мы выполняем две операции, -а(индексируем (git add)) и комитим сразу,например после 
того как мы удалили что либо,что бы не писать сначала git add ,а затем git commit,мы можем использовать данную команду как 2 в 1

git checkout -- yourfile.html   //Откат,Допустим мы сделали изменения в файле yourfile.html,но хотим вернуть 
изменения которые мы залили на удаленный репозиторий в последний раз, yourfile.html -- это файл который мы хотим откатить 

git log --- Показывает историю коммитов,если большой список то чтобы выйти нужно нажать клавишу Q 
git log --pretty=format:"%h - %an, %ar : %s"   --- Меняет формат вывода истории коммитов на более удобный 
git log --since=2.weeks   --- Показать историю коммитов за последние 2 недели(например если прокты подерживаются очень долго)
git log -p -2    --- Показывает какие изменения произошли 

git config --global core.editor "'C:\Program Files (x86)\Notepad++\notepad++.exe' -multiInst -notabbar -nosession -noPlugin"?       ---Позволяет при написании git config открывать Notepad++ и там делать коммиты

git remote   --- Показывает список удаленных репозиториев(например на github) 
git remote  -v    --- Показывает путь к данным репозиториям, fetch -откуда будем забирать, push - куда мы будем слаживать

Что бы залить репозиторий на удаленный репозиторий(например, GITHUB) нужно:

1.Создать акаунт на github 
2.Создать там репозиторий 
3.В консоле создать репозиторий который нужно заливать(git init)
4.Добавляем эти файлы (git add)
5.Делаем комит git commit -m "first commit"
6.Дальше копируем 2 скрочки из Push an existing resipitory from the commad line и вставляем в консоль и все

/*
	git remote add origin https://github.com/lex-dp/NewRepository.git 
	git remote add  --- Мы говорим github что будем заливать новый репозиторий
	origin  --- Название репозиторий,мы можем указать что угодно 
	https://github.com/lex-dp/NewRepository.git    --- Путь к данному репозиторию
*/


Чтобы потом просто добавить коммиты нужно написать 2ю строчку из Push an existing resipitory from the commad line
То есть, например так git push -u origin master

Что бы скачать что-то из github нужно:

1.Найти то что ищем(через поиск)
2.Скопировать ссылку через https
3.Создать папку куда мы хотим загрузить это и зайти в нее
4.В консоле написать git clone https://github.com/jquery/jquery.git   



									ИГНОРИРОВАНИЕ ФАЙЛОВ
Для того что бы игнорировать некоторые файлы,которые мы не хотим загружать в git 
нужно создать текстовый файл по названием .gitingore    и добавить в него все что мы хотим игнорить,например:

#will ignore this folder
styles/  

#will ignore all files .php
php/*.php 


/*
	#will ignore this folder --- это комментарий 
	styles/   --- будет игнорировать данную папку и все что в ней находится 
	php/*.php --- будет игнорировать данные расширенния в этой папке
*/

git status --untracked-files=all   //Показывает какие файлы не отслеживаются,игнорируются 



									Создание веток

git checkout -b new_f   --- Создаст новую ветку под названием new_f и сразу же на нее перейдет(git checkout -b)
git branch  --- Показывает какие ветки у нас есть 
git branch -v --- Показывает какие какие коммиты произошли в ветках

git branch new_f2   --- Еще один способ создания веток,мы создали ветку но не переключились на нее 
git checkout new_f2   --- Способ перемещения по веткам,в данном случае мы перешли на ветку new_f2 

										Merge (слияние веток)
Перед слиянием нужно указать утилиту котороя будет разрешать конфликты 

git config --global merge.tool kdiff3    //мы указали утилиту 

git merge master   // Слияние,мы зашли в ветку new_f и сюда заливаем ветку главную ветку master для тестирования,если все ок то потом заливаем new_f на главную ветку master 

git mergetool   //Этой командой мы запускаем утилиту и она разрешает конфликты,(после этой команды нужно нажать enter для старта)
/*
The merge tool kdiff3is not abailable as "kdiff3"    
Если выдает такую строчну то нужно установить этот kdiff3, а если мы ее не устанавливали то так скорее всего и есть 
так как по умолчанию его в git нету нужно скачать: kdiff3.sourceforge.net
*/


									Откатить изменения до нужного коммита
git checkout 1af986e8665f08c58a80a889b8948ad4ae4a490d   //Переходим к определенному коммиту по хэшу 
/*
https://github.com/lex-dp/Traning/commit/1af986e8665f08c58a80a889b8948ad4ae4a490d

	1af986e8665f08c58a80a889b8948ad4ae4a490d    - Хэш
*/
									
Удаление предыдушх коммитов:									
git reset --hard HEAD~2   //делаем откат изменений в репозитории для примера на два коммита назад НО УДАЛИТ ПРЕДИДУЩИЕ КОММИТЫ 
git push -f origin master   // Далее делаем принудительный коммит в основной репо на гитхабе,без -f будет ругаться что у вас версия младше чем в гитхабе и вам надо сделать pull 
									

												
												
												
										
											WORDPRESS
Итеграция верстки css/html в wordpress тему:

1.Заходим на http://underscores.me/ и пишем название тему потом качаем(это обичная пустая тема которую мы будет переделывать)
2.В админке WP заходим в раздел Темы и загружаем только что скачанные .zip архив
3.Заходим в wp-content/themes/{"название нашей темы"} и копируем туда все файлы из обычной верстки кроме .html
4.Открываем index.php и копируем туда все содержимое index.html
5.Что бы css,js,img заработал нужно перед каждым css,js,img файлом поставить <?php bloginfo("template_directory");?>/  , например <link rel="stylesheet" href="<?php bloginfo("template_directory");?>/css/styles.css"> или <script src="<?php bloginfo("template_directory");?>/js/scripts.js"></script> 
Это делается для того что бы помочь найти пути,так как сейчас в темы пути стали намного сложнее и нужно помочь WP найти эти путя 
//По сути после этих шагов у нас уже есть тема,только редактирвоать в ней ничего нельзя,что бы это сделать нужно добавить php функции 

Для того что бы мы в WP смогли редактировать заголовок нужно поставить:

<h1><?php the_title(); ?></h1>
//Моджно использовать для всех h2,h4...										
												
Для контента:

<?php the_post(); ?>												
<?php the_content(); ?>												
												
					
Имя сайта.Чтобы задать имя и описание сайте нужно поставить первую и вторую конструкцию в нужных местах:

<?php bloginfo("name"); ?>
<?php bloginfo("description"); ?>

//Например: <h1><a href="/"><?php bloginfo("name"); ?></a></h1>   (a href="/" - ccылка на главную)


Меню:
Чтобы вывести меню, добавим вместо списка <ul> следующую конструкцию:
Перед этим нужно создать меню, Внешний вид > Меню 

<?php wp_nav_menu("primary"); ?>




									Теперь более подробнее о функциях WP:
http://wp-kama.ru/  //Сайт где можно посмотреть русскую документацию функций WP


<?php bloginfo(); ?>   //Используется для названия сайта,в title или в заголовках 
<?php bloginfo("description"); ?>  //Описание сайта 

//Можно использовать в тегах или напримую например, <h1><?php bloginfo("name");?></h1> или <?php bloginfo("description"); ?>

<a href="<?php echo home_url(); ?>">Главная страница</a>  //Ссылка на главную страницу 
<?php bloginfo("template_url"); ?>   //Относительный путь к папку с текущей темой (без слеша в конце так что нужно будет его написать если будем ссылатся на какуето папку)
<?php bloginfo("stylesheet_url"); ?>  //Относительный путь к таблице со стилями ,например мы можем его использовать для указания пути к стилям: <link rel="stylesheet" href="<?php bloginfo("stylesheet_url"); ?>">


										ЗАПИСИ в Wordpress
Вывести одну запись под определенным id: 

<?php 
	$post = get_post($post_id = 90); // Записываем все данные записи 1 в объект $post
	echo '<h1 class="text-center">'.$post->post_title.'</h1>'; // Выводим заголовок записи;
	echo $post->post_content; // Выводим контент записи;
?>										
										
										
										
<h2><?php the_title(); ?></h2>  //Заголовки, в админке это раздел ЗАписи,по умолчанию выводит последний добавленный заголовок 

Вывести все записи <h2> уровнем можно таким способом
<?php if ( have_posts() ) : while ( have_posts() ): the_post(); ?>
	<!-- post -->
	
	<h2><?php the_title(); ?></h2>
	
	<?php endwhile; ?>
	<!-- post navigation -->
	<?php else: ?>
	<!-- no post found -->
	<?php endif; ?>
	

Вывести все записи <h2> уровнем и контент для каждой записи 
<?php if ( have_posts() ) : while ( have_posts() ): the_post(); ?>
	<!-- post -->
	<h2><?php the_title(); ?></h2>
	
	<?php the_content(); ?>
	
	<?php endwhile; ?>
	<!-- post navigation -->
	<?php else: ?>
	<!-- no post found -->
	<?php endif; ?>

Если мы добавим в записи много текста то будет неудобно просматривать,поэтому можно добавить короткую запись 
и ссылку на остальную часть текста:

<?php if ( have_posts() ) : while ( have_posts() ): the_post(); ?>
	<!-- post -->
	<h2><?php the_title(); ?></h2>
	
	<?php the_excerpt(); ?>// Так будет показыватся только 55 символов,а после будет ... ,но текст будет разрыватся не совсем коректно
	
	<?php endwhile; ?>
	<!-- post navigation -->
	<?php else: ?>
	<!-- no post found -->
	<?php endif; ?>


В самом WP в разделе записи можно поставить галочку в верху на "Цитата" и внизу появится текстовое поле цитата и туда можно вставить 
текст с цитатой которая будет появлятся без ... (для этого нужно вставить код выше с the_excerpt) 



<?php var_dump($post)?>   //Выводит последнюю запись в виде ключ - значение 
<?php echo $post->post_content?>  //Затем мы можем обратится к какому то ключу например к контенту 
<?php var_dump($posts)?>  //Выводит все записи в цикле 

												Цыкл
<?php foreach($posts as $item_post) : ?>
	<h3><?php echo $item_post->post_title?></h3>
	<p><?php echo $item_post->post_content?></p>
<?php endforeach; ?>

//Мы создали свой цикл который выводит название и контент каждой записи


										Разместить контент в разные шаблоны
Можно разместить контент из главной страницы в разные шаблоны WP для того чтобы потом просто одной командой вызывать
этот кусок кода,например просто берем кусок кода например в шаблон header.php вырезаем из главной страницы index.php 
и вставляем в  header.php(в этом шаблоне просто все удаляем и вставляем нужный контент),и все,и пишем в том месте 
где нужен этот кусок кода команду например, <?php get_header(); ?>
Аналогичные команды для sidebar,footer...
<?php get_sidebar(); ?>
<?php get_footer(); ?>

Так же нужно в header.php перед закрывающим тегом head поставить <?php wp_head(); ?> , а в файле 
footer.php перед закрывающим тегом body поставить <?php wp_footer() ?>

<?php wp_head(); ?>  // Обеспечивает коректную работу с плагинами
<?php wp_footer() ?>   //Показывает меню настроек Админке вверху страници

Так же нужно поставить в title две функции первая будет показывать название сайта,а вторая при следующий страницах 
будет показывать названия этих страниц 
<title><?php bloginfo("name"); wp_title(); ?> </title>



										Безопасное подключение css/js
1.В шаблон header.php добавить ОБЯЗАТЕЛЬНО <?php wp_head(); ?>  без этой функции работать не будет(перед закрывающим тегом head) 
2.Создать файл functions.php (его подключать не нужно он по умолчанию подключен)
3.По образу создать путя в файле functions.php(в этом файле можно все удалить): 
<?php 
	/*Start of Upload scripts and styles*/
		
	function load_styles_scripts() {
		wp_enqueue_style("jquery-ui.min.css", get_template_directory_uri() . "/plugins/jquery-ui-1.11.4.custom/css/jquery-ui.min.css");
		wp_enqueue_style("styles", get_template_directory_uri() . "/css/styles.css");
		wp_enqueue_script("jquery-1.11.3.min.js", get_template_directory_uri() . "/js/jquery-1.11.3.min.js");
		wp_enqueue_script("jquery-ui-1.11.4.custom", get_template_directory_uri() . "/plugins/jquery-ui-1.11.4.custom/js/jquery-ui.min.js");
		wp_enqueue_script("scripts.js", get_template_directory_uri() . "/js/scripts.js");
	}	
		
		add_action("wp_enqueue_scripts", "load_styles_scripts");
	
	/*End of Upload scripts and styles*/
?>

<p><?php the_tags(); ?></p>   //Вызов меток 

										Добавить миниатюры
В файлике functions.php нужно дабавить строку: add_theme_support("post-thumbnails");
и после этого в админке в разделе ЗАписи внизу справа появятся миниатюры 
После этого нужно вызвать эту миниатюру

<?php the_post_thumbnail(); ?> //Вызывает миниатюру

<?php the_post_thumbnail("full", "class='img-style'"); ?>
//Так же можно передавать параментры, 1й - это размер, второй это имя класса


									Добавляем меню 
В файлике functions.php нужно дабавить строку:
register_nav_menu("menu", "Меню"); //Мы регистрируем 1 меню, register_nav_menus(); для более чем 1го меню 
//Первый параметр это идетификатор,а второй название меню 						

Потом мы в админке создаем само меню и вызываем его с помощью функции:

<?php wp_nav_menu(array("theme_location" => "menu")); ?>  //мы указываем имя первого параметра register_nav_menu("menu", "Меню"); то есть menu 
 
<?php wp_nav_menu(array("theme_location" => "menu", "container" => false)); ?> //По умолчанию у нас содержимое обворачивается тегом div, если мы поставим значение false то его не будет 

<?php wp_nav_menu(array("theme_location" => "menu", "container" => false, "menu_class" => "", "before" => "-")); ?> // "menu_class" => "" убираем класс по умолчанию,чтобы меню было без фона, "before" => "-"  перед каждой записью ставим - 

 
									Добавить виджет 
По умолчанию в админке в разделе Внешний вид > нету виджетов,что бы там появился раздел Виджеты 
нужно:

1.В functions.php добавить: 
register_sidebar(array( 
	"name" => "Виджеты сайдбара", //Название виджета
	"id" => "sidebar",  //Идентификатор
	"description" => "Здесь размещайте виджеты сайдбара",
	"before_widget" => "<div class='vidget'>", //Перед виджетом
	"after_widget" => "</div"//После виджета 
));

2.В sidebar.php нужно вызвать этот виджет:

<div class="share">
	
	<?php if(!dynamic_sidebar("sidebar")) : ?>
		<p>SHARE:</p>
		<a href="#"><img src="<?php bloginfo("template_directory");?>/images/share1.jpg" alt="share1"></a>
		<a href="#"><img src="<?php bloginfo("template_directory");?>/images/share2.jpg" alt="share2"></a>
		<a href="#"><img src="<?php bloginfo("template_directory");?>/images/share3.jpg" alt="share3"></a>
		<a href="#"><img src="<?php bloginfo("template_directory");?>/images/share4.jpg" alt="share4"></a>
	<?php endif; ?>
					
</div>

/*
	Мы задали условие,если сайдбар пустой if(!dynamic_sidebar("sidebar"))"sidebar" - это идентификатор,какой именно сайдбар 
то мы выводим следующее содержимое 	
*/

Или например так: 
<?php if(!dynamic_sidebar("sidebar")) : ?>
	<ul>
		<?php wp_list_categories(array("title_li" => "")); ?>
	</ul>
<?php endif; ?>

//Если виджет не заполнен то мы вызвает рубрики, "title_li" => "" убирает слово Рубрики,которое идет вне тега li

									single.php
Данный шаблон отвечает за открытие скажем Читать далее в новой странице,он открывает Записи
Для того чтобы коректно отображалось содержимое читать далее мы делаем следующее:

1.Создаем файлик  single.php
2.Копируем содержимое из index.php в single.php
3.И делаем косметику,убираем цитаты и ссылки на Читать далее (<?php the_excerpt(); ?> и <a href="<?php the_permalink(); ?>">Read More ></a>	)
И добавляем отображение полного контента вместо цитаты <?php the_content(); ?>


									page.php 
Данный шаблон отвечает за меню, или раздел Страници в админке.Что бы он коректно отображался 
нужно сделать примерно теже шаги что и выше в single.php:
								
1.Создаем файлик  page.php 
2.Копируем содержимое из index.php в page.php 
3.И делаем косметику,убираем или добавляем что нам нужно 


<?php single_cat_title(); ?>  //Выводит название Рубрики 
<?php single_cat_title("Рубрика: "); ?>  //Выведет: Рубрика: и ее название 

								category.php 
Данный шаблон отвечает за Рубрики в сайтбаре.Схема та же что и више 

									
								search_form 
Данный шаблон предназначен для непосредственно самой разметки html формы которую мы потом вызваем 
например в эту форму заносим:
<form class="search-main" action="<?php echo home_url("/"); ?>" method="">
   <p><input type="search" name="s" placeholder="Поиск по сайту"> 
   <input type="submit" value="Найти"></p>
</form> 

а потом вызваем скажем в header.php  : <?php get_search_form(); ?>



								search.php 
Данный шаблон отвечает за поиск по сайту.Что бы его запустить нужно.

1.Создать сам файл search.php 
2.В этом файле в цикле обязательно нужно добавить в else(когда клиент ничего не может найти) 
уведомить его например: 

<div class="main-content">
	<h1 class="brand-name"><?php bloginfo("name"); ?></h1>
		<?php get_header(); ?>
	<div class="content">
		<?php if ( have_posts() ) : while ( have_posts() ): the_post(); ?>
		<!-- post -->
		<h1><?php single_cat_title("Рубрика: "); ?></h1>
		<h2><?php the_title(); ?></h2>
		<br />
		<p><?php the_time('j F Y'); ?></p>
		<p>Email: <?php bloginfo("admin_email"); ?></p>
		<?php the_content(); ?>	
	
		<a href="<?php the_permalink(); ?>">Read More ></a>	
		<?php endwhile; ?>
		<!-- post navigation -->
		<?php else: ?>
		<!-- no post found -->
		<p>По запросу ничего не найдено </p>
		<?php endif; ?>		
		<?php wp_nav_menu(array("theme_location" => "menu")); ?>
	</div>
	<?php get_sidebar(); ?>
	<?php get_footer(); ?>
</div>


3.И самое главное в input поиске поставить название s так заработает форма,например: 

<form class="search-main" action="<?php echo home_url("/"); ?>" method="">
   <p><input type="search" name="s" placeholder="Поиск по сайту"> 
   <input type="submit" value="Найти"></p>
</form>

//action="<?php echo home_url("/"); ?>" если включен ЧПУ то поиск не будет работаь,а с этим кодом будет работать поиск 


									Добавления пагинации(листание страничек)
Обычно используют плагины но можно зайти на WP сайт и найти функцию paginate links
и от туда скопировать пример:

<?php
	global $wp_query;

	$big = 999999999; // need an unlikely integer

	echo paginate_links( array(
		'base' => str_replace( $big, '%#%', esc_url( get_pagenum_link( $big ) ) ),
		'format' => '?paged=%#%',
		'current' => max( 1, get_query_var('paged') ),
		'total' => $wp_query->max_num_pages
	) );
?>

Потом этот код нужно скопировать и вставлять во все старички (index.php,single.php ...)			
например:

<div class="content">
		<?php if ( have_posts() ) : while ( have_posts() ): the_post(); ?>
		<!-- post -->
		<h2><?php the_title(); ?></h2>
		<?php the_post_thumbnail(); ?>
		<p><?php the_time('j F Y'); ?></p>
		<p><?php the_tags(); ?></p>
		<p>Email: <?php bloginfo("admin_email"); ?></p>
		<?php the_excerpt(); ?>	
	
		<a href="<?php the_permalink(); ?>">Read More ></a>	
		<?php endwhile; ?>
		<!-- post navigation -->
		
		<div class="pagination">
			
			<?php
				global $wp_query;

				$big = 999999999; // need an unlikely integer

				echo paginate_links( array(
					'base' => str_replace( $big, '%#%', esc_url( get_pagenum_link( $big ) ) ),
					'format' => '?paged=%#%',
					'current' => max( 1, get_query_var('paged') ),
					'total' => $wp_query->max_num_pages
				) );
			?>
		
		</div>
		
		
		<?php else: ?>
		<!-- no post found -->
		<?php endif; ?>		
		<?php wp_nav_menu(array("theme_location" => "menu")); ?>
	</div>

//И все наши записи буду добавлятся к каждой странице допустим мы записали 9 записей по возможности показа только 3 и в результате 
//у нас автоматом будет 3 страники по 3 записи 
//<div class="pagination"> для css редактирования этого блока 


										tag.php 
Данный шаблон отвечает за Метки.Похожая система настройки.

<?php single_tag_title(); ?>  //Выводит название метки 

Например код примерно такой: 

<div class="main-content">
	<h1 class="brand-name"><?php bloginfo("name"); ?></h1>
		<?php get_header(); ?>
	<div class="content">
		<?php if ( have_posts() ) : while ( have_posts() ): the_post(); ?>
		<!-- post -->
		<h1> Записи по метке "<?php single_tag_title(); ?>"</h1>
		<h2><?php the_title(); ?></h2>
		<br />
		<p><?php the_time('j F Y'); ?></p>
		<p><?php the_tags(); ?></p>
		<p>Email: <?php bloginfo("admin_email"); ?></p>
		<?php the_content(); ?>	
	
		<a href="<?php the_permalink(); ?>">Read More ></a>	
		<?php endwhile; ?>
		<!-- post navigation -->
		
		<?php
				global $wp_query;

				$big = 999999999; // need an unlikely integer

				echo paginate_links( array(
					'base' => str_replace( $big, '%#%', esc_url( get_pagenum_link( $big ) ) ),
					'format' => '?paged=%#%',
					'current' => max( 1, get_query_var('paged') ),
					'total' => $wp_query->max_num_pages
				) );
			?>
		<?php else: ?>
		<!-- no post found -->
		<?php endif; ?>		
		<?php wp_nav_menu(array("theme_location" => "menu")); ?>
	</div>
	<?php get_sidebar(); ?>
	<?php get_footer(); ?>
</div>


										404.php 
Данный шаблон предназначен для тех случаев когда ничего не может найти клиент либо ввел 
не тот адрес тогда его редиректит на эту страницу.

1.Создать файлик 404.php 
2.Добавить header.php,footer.php 
3.Дать понять пользователю что страница не найдена 


Если не идет переадресация на 404.php то нужно создать файл .htaccess
и в нем написать: ErrorDocument 404 /index.php?error=404 


									Добавить Коментарии 
Нужно зайти скажем в шаблон single.php(отвечающий за Записи) и добавить функцию:

<?php comments_template(); ?>


Вывести испорияю коментов

<?php  $args = array(
	'number' => 10,
	'orderby' => 'comment_date',
	'order' => 'DESC',
	//'post_id' => 0,
	'type' => 'comment', // только комментарии, без пингов и т.д...
);

if( $comments = get_comments( $args ) ){
	echo '<h3>Recent Blog Posts</h3>';
	foreach( $comments as $comment ){
		$comm_link = get_comment_link( $comment->comment_ID ); // может быть тяжелый запрос ...
		$comm_short_txt = mb_substr( strip_tags( $comment->comment_content ), 0, 50 ) .'...';

		echo '<a class="text-success" rel="nofollow" href="'. $comm_link .'">'. $comm_short_txt .'</a>';
		echo '<p>'.get_comment_time().'</p>';
	}
}?>


									
									Слайдер 
Обычно используется плагины.Но в нашем случае мы сделали без плагина вот порядок:

1.В functions.php пишем:

add_action("init", "slider"); //На функцию init мы будем цеплять функцию slider
function slider() {
	register_post_type("slider", array(
		"public" => true, //Добавляет в админке новый раздел Записи 
		"supports" => array("title", "thumbnail"), //Название и картинка по умолчанию отключена,мы подключили 
		"labels" => array(  //мы менаем названия а админке 
			"name" => "Слайдер",
			"all_items" => "Все слайды",
			"add_new" => "Добавить новый",
			"add_new_item" => "Добавление слайда"
		)
	));
}
//slider это название записи, далее массив с параметрами 									


2.Там где мы будем вставлять Слайдер нужно написать: 


<?php $slider = new WP_Query(array("post_type" => "slider", "posts_per_page" => -1, "order" => "ASC")); ?>

	<div id="#slider">
		<ul id="cycle">
<?php if ( $slider->have_posts() ) : ?> 

<?php while ( $slider->have_posts() ): $slider->the_post(); ?>
<!-- post -->
			<li><?php the_post_thumbnail("full"); ?></li>
<?php endwhile; ?>
<!-- post navigation -->
	
		</ul>
		<div id="cyclePager"></div>
	</div>
<?php else: ?>
<!-- no post found -->
<p>Место для Слайдера</p>
<?php endif; ?>	
<?php wp_reset_query(); ?> //Сброс цикла,рекомендуется использовать после любого цикла 

//Лучше пожалуй скачать плагин)



								Создание темы на Wordpress
Скачиваем готовый архив темы на http://underscores.me/
Создаем главную страницу, в свойствах пишем название например home-page
Создаем файл page-home-page.php копируем в этот файл все содержимое файла page.php 
Затем в этом файле (page-home-page.php) делаем косметику,например убираем get_slider()..

Дальше в папке template-parts создаем файлик content-home.php и копируем в этот файл все содержимое файла content-page.php
Затем в этом файле (content-home.php) удаляем все,оставляем только the_content()

И в файле page-home-page.php вместо "page" ставим "home":   get_template_part( 'template-parts/content', 'home' );


Затем скачаем плагин "tgm plugin activation" для того что бы в админке было уведомление о том что нужно 
установить "Unyson" плагин(ибо без него работать не будет)
В папке с темой, создаем папку "tgm" и в нее копируем все содержимое данного плагина 
Создаем файл например "example-theme.php" и копируем в этот файл все содержимое файла "example.php"
Скачиваем плагин wordpress unyson plugin и в корне(когда мы заходим в папку с темой) создаем папку
"lib" в ней другую папку "plugins" и туда сохраняем наш архив с плагином.

Дальше в файлике "example-theme.php" в массиве plugins оставляем только:
$plugins = array(

	// This is an example of how to include a plugin bundled with a theme.
	array(
		'name'               => 'TGM Example Plugin', // The plugin name.
		'slug'               => 'tgm-example-plugin', // The plugin slug (typically the folder name).
		'source'             => get_stylesheet_directory() . '/lib/plugins/tgm-example-plugin.zip', // The plugin source.
		'required'           => true, // If false, the plugin is only 'recommended' instead of required.
		'version'            => '', // E.g. 1.0.0. If set, the active plugin must be this version or higher. If the plugin version is higher than the plugin version installed, the user will be notified to update the plugin.
		'force_activation'   => false, // If true, plugin is activated upon theme activation and cannot be deactivated until theme switch.
		'force_deactivation' => false, // If true, plugin is deactivated upon theme switch, useful for theme-specific plugins.
		'external_url'       => '', // If set, overrides default API URL and points to an external URL.
		'is_callable'        => '', // If set, this callable will be be checked for availability to determine if a plugin is active.
	),

);

И здесь нужно указать путя и названия плагина:

$plugins = array(

	// This is an example of how to include a plugin bundled with a theme.
	array(
		'name'               => 'Unyson', // The plugin name.
		'slug'               => 'unyson', // The plugin slug (typically the folder name).
		'source'             => get_stylesheet_directory() . '/lib/plugins/unyson.2.5.5.zip', // The plugin source.
		'required'           => true, // If false, the plugin is only 'recommended' instead of required.
		'version'            => '2.5.5', // E.g. 1.0.0. If set, the active plugin must be this version or higher. If the plugin version is higher than the plugin version installed, the user will be notified to update the plugin.
		'force_activation'   => true, // If true, plugin is activated upon theme activation and cannot be deactivated until theme switch.
		'force_deactivation' => false, // If true, plugin is deactivated upon theme switch, useful for theme-specific plugins.
		'external_url'       => '', // If set, overrides default API URL and points to an external URL.
		'is_callable'        => '', // If set, this callable will be be checked for availability to determine if a plugin is active.
	),

);

И что бы подключить это все нужно зайти в functions.php и в самом конце добавить путь к файлу tgm plugin:

/**
 * Load TGM Plugins.
 */
require get_template_directory() . '/tgm/example-theme.php';


И все теперь в админке во вкладке "Консоль" в самом верху появится сообщение что нужно установить плагин Unyson:
This theme requires the following plugin: Unyson. Begin installing plugin | Dismiss this notice 



													Добавить класс 
Для того что бы добавить класс в секцию нужно:

1.Создать папку в корне с темой под названием "framework-customizations"
2.В этой папке нужно создать другие папки "extensions/shortcodes/shortcodes/section/views"
3.Из "wp-content/plugins/unyson/framework/extensions/shortcodes/shortcodes/section" копируем файлик "options.php" и вставляем в нашу папку "section"
4.И заодно в папку views копируем файлик views.php 
5.В "options.php" добавляем новый класс:

'customclass' => array(
	'label' => __('Custom Section Class', 'fw'),
	'desc'  => __('Insert Custom Section Class', 'fw'),
	'type'  => 'text',
)

//После этого шага мы можем добавить класс в секцию,она у нас добавится только в back-end ,а чтобы добавить и в front-end нужно сделать шаг ниже 

6.В файлике "view.php" удаляем все содержимое и заменяем на это:

<?php if ( ! defined( 'FW' ) ) {
	die( 'Forbidden' );
}

$bg_color = '';
if ( ! empty( $atts['background_color'] ) ) {
	$bg_color = 'background-color:' . $atts['background_color'] . ';';
}

$bg_image = '';
if ( ! empty( $atts['background_image'] ) && ! empty( $atts['background_image']['data']['icon'] ) ) {
	$bg_image = 'background-image:url(' . $atts['background_image']['data']['icon'] . ');';
}

$bg_video_data_attr    = '';
$section_extra_classes = '';
if ( ! empty( $atts['video'] ) ) {
	$filetype           = wp_check_filetype( $atts['video'] );
	$filetypes          = array( 'mp4' => 'mp4', 'ogv' => 'ogg', 'webm' => 'webm', 'jpg' => 'poster' );
	$filetype           = array_key_exists( (string) $filetype['ext'], $filetypes ) ? $filetypes[ $filetype['ext'] ] : 'video';
	$data_name_attr = version_compare( fw_ext('shortcodes')->manifest->get_version(), '1.3.9', '>=' ) ? 'data-background-options' : 'data-wallpaper-options';
	$bg_video_data_attr = $data_name_attr.'="' . fw_htmlspecialchars( json_encode( array( 'source' => array( $filetype => $atts['video'] ) ) ) ) . '"';
	$section_extra_classes .= ' background-video';
}

$section_style   = ( $bg_color || $bg_image ) ? 'style="' . esc_attr($bg_color . $bg_image) . '"' : '';
$container_class = ( isset( $atts['is_fullwidth'] ) && $atts['is_fullwidth'] ) ? 'fw-container-fluid' : 'fw-container';
$custom_class = ( isset( $atts['customclass'] ) && $atts['customclass'] ) ? " " . $atts['customclass'] . "" : '';
?>
<section class="fw-main-row <?php echo $custom_class; ?>" <?php echo $section_style; ?> <?php echo $bg_video_data_attr; ?>>
	<div class="<?php echo esc_attr($container_class); ?>">
		<?php echo do_shortcode( $content ); ?>
	</div>
</section>


И после этого мы увижим добавленный класс



												Добавить ID 
Добавить id в секцию можно по такому же принципу как и класс:

1.В "options.php" добавляем:

'customid' => array(
	'label' => __('Custom Section Id', 'fw'),
	'desc'  => __('Insert Custom Section Id', 'fw'),
	'type'  => 'text',
)

2.В файле "view.php" дублируем строку $custom_class = ( isset( $atts['customclass'] ) && $atts['customclass'] ) ? " " . $atts['customclass'] . "" : ''; и изменяем ее на:

$custom_id = ( isset( $atts['customid'] ) && $atts['customid'] ) ? "id='" . $atts['customid'] . "'" : '';
//или просто добавим эту строку ниже

3.И изменим строку <section class="fw-main-row <?php echo $custom_class; ?>" <?php echo $section_style; ?> <?php echo $bg_video_data_attr; ?>>

на 

<section <?php echo $custom_id; ?> class="fw-main-row <?php echo $custom_class; ?>" <?php echo $section_style; ?> <?php echo $bg_video_data_attr; ?>>


Все теперь мы можем добавлять id 













					
												ANGULAR JS
<div ng-app="">  	
	<p>Введите какой-то текст</p>
	<p>Ваше имя:<input type="text" ng-model="name"></p>
	<p ng-bind="name"></p>
</div>
//При вводе текста в input этот тект помимо input выводится и в p 	
	
ng-app="" - Директива котороя находит ANGULARJS  приложения.В нашем случае эта директива 
говорит	что элемент div является "владельцем" AngularJS приложения

ng-model="name" - эта директива связывает значения поле для input,select,textarea с именем
которое мы вписали в него(name) 			

ng-bind="name" - эта директива связывает данные приложения с HTML
							
											
<div ng-app="" ng-init="firstName='John'">
	<p>ваше имя:<span ng-bind="firstName"></span></p>
</div>

ng-init  - эта директива иницилизирует приложения AngularJS как переменные

									
								Валидный AngularJS 
									
НАМ НУЖНО использовать data-ng- перед ng если мы хотим убедится что страничка HTML била валидная 

<div data-ng-app="" data-ng-init="firstName='John'">
<p>The name is <span data-ng-bind="firstName"></span></p>
</div>											   
											   
											   
								AngularJS Выражения		   
AngularJS выражения пишутся внутри двойных кавычек {{выражение}}											   
AngularJS решит выражение именно в том месте где мы его вставим											   

<div ng-app="">
 	<p>My first expression: {{ 5 + 5 }}</p>
</div>											   
											   
AngularJS соединяет данные к HTML используя Выражения,то есть:
AngularJS выражения можно написать внутри двойных кавычек {{выражение}} , но 											   
AngularJS выражения могут также быть написаны внутри директивы: ng-bind="выражение"
AngularJS решит выражение и возвратит результат именно там где выражение написанно 
AngularJS выражение работают как и выражения JavaScript,например:
{{ 5 + 5 }} or {{ firstName + " " + lastName }}

<div ng-app="">
 	<p>My first expression: {{ 5 + 5 }}</p> //В результате будет : My first expression: 10
</div>

Если мы удалим ng-app директиву, HTML покажет выражение как оно написано:

<div >
 	<p>My first expression: {{ 5 + 5 }}</p> //В результате будет : My first expression: {{ 5 + 5 }}
</div>
											   
											   
Мы можем написать выражения где бы то нибыло,AngularJS просто решит	выражение и возвратит результат 

								AngularJS числа 
								
<div data-ng-app="" data-ng-init="number1=2; number2=4">//Можно так записывать переменные
		<p>Name: {{number1 * number2}}</p>
</div>									   
											   
<div data-ng-app="" data-ng-init="number1='2'; number2='4'">//А можно и так  
		<p>Name: {{number1 * number2}}</p>
</div>											   
											   
Тоже самое используя ng-bind:

<div data-ng-app="" data-ng-init="number1='2'; number2='4'">
		<p>Count: <span data-ng-bind="number1 * number2"></span></p>
</div>											   
											   
								AngularJS строки 
AngularJS строки точно такие как и JavaScript строки:
								
<div ng-app="" ng-init="firstName='John';lastName='Doe'">
<p>The name is {{ firstName + " " + lastName }}</p>
</div>											   
											   
Тоже самое используя ng-bind:

<div ng-app="" ng-init="firstName='John';lastName='Doe'">
<p>The name is <span ng-bind="firstName + ' ' + lastName"></span></p>
</div>											   
											   
								AngularJS обьекты 
AngularJS обьекты такие как и в JavaScript:
								
<div ng-app="" ng-init="person={firstName:'John',lastName:'Doe'}">
<p>The name is {{ person.lastName }}</p>
</div>											   
											   
Тоже самое используя ng-bind:

<div ng-app="" ng-init="person={firstName:'John',lastName:'Doe'}">
<p>The name is <span ng-bind="person.lastName"></span></p>
</div>											   
											   
								AngularJS массивы
AngularJS массивы точно такие как и в JavaScript:

<div ng-app="" ng-init="points=[1,15,19,2,40]">
<p>The third result is {{ points[2] }}</p>
</div>

Тоже самое используя ng-bind:								
											   
<div ng-app="" ng-init="points=[1,15,19,2,40]">
<p>The third result is <span ng-bind="points[2]"></span></p>
</div>											   
											   
						
													AngularJS Модули 
													
													
AngularJS Модули находят приложения.Модули - это контейнеры для различных частей приложения 
Модуль контейрен для контролеров приложения.Контроллеры всегда принадлежат к модулю

								Cоздание модуля
Модуль создается используя AngularJS функцию angular.module


<div ng-app="myApp">...</div>

<script>

var app = angular.module("myApp", []);

</script>


"myApp" - Это параметр обращающий к HTML элементу приложение которого будет запущенно  
Теперь мы можем добавлять контроллеры, директивы, фильтры и многое другое, к нашему приложению AngularJS

[] Параметр в определении может быть использован для определения зависимых модулей.
Без [] параметра, мы не создадим новый модуль, но извлечим существующий.

									Добавление контролера 
<div data-ng-app="myApp" ng-controller="myCtrl">
	{{first + " " + second}}
</div>

<script>
	var app = angular.module("myApp", []);
	
	app.controller("myCtrl", function($scope) {
		
		$scope.first = "Vasia";
		$scope.second = "Vasilkov";
	});
</script>


									Добавление Директив
AngularJS имеет набор встроенных директив, которые можно использовать для добавления функциональности к приложению
Мы можем использовать модуль, чтобы добавить свои собственные директивы для наших приложений									

<div data-ng-app="myApp" dir-directive></div>
<script>
	var app = angular.module("myApp", []);
	app.directive("dirDirective", function(){
		return {
			template: "It was good traning "
		};
	});
</script>

/*
	Нужно обратить внимание на то что если название директивы пишется через дефис то, вызывается слово после дефиса 
	с большой буквы,например:
	
	<div data-ng-app="myApp" dir-directive></div>   --- dir-directive   //идет с маленьких 
	
	а вызывается каждое слово после дефиса с большой dirDirective :
	
	app.directive("dirDirective", function(){  //если написать с маленькой то вызов не произойдет 
*/


										
										Модули и контроллеры в файлах
Это нормально в AngularJS разлаживать модули и контролеры в JS файлах
Например, myApp.js содержит приложение модуля,а myCtrl.js содержит котролер 

 <!DOCTYPE html>
<html>
<script src="http://ajax.googleapis.com/ajax/libs/angularjs/1.4.8/angular.min.js"></script>
<body>

<div ng-app="myApp" ng-controller="myCtrl">
{{ firstName + " " + lastName }}
</div>

<script src="myApp.js"></script>
<script src="myCtrl.js"></script>

</body>
</html>  					


														Директивы
														
														
AngularJS позволяет расширить HTML с новыми атрибутами называемые директивы.						
AngularJS имеет набор встроенных директив, которые предлают функциональные возможности для наших приложений.						
AngularJS также позволяет нам определить свои собственные директивы.					
						
Все что начинается с ng это директивы(ng-app, ng-model, ng-init....)						
						
<div data-ng-app="" data-ng-init="costs=2; posts=5">
	<input type="number" data-ng-model="costs">
	<input  type="number" data-ng-model="posts">
	Total : {{costs * posts}}
</div>						
						
						
													Повторение HTML элементов 
ng-repeat  ---директива повторяет HTML элемент.Клонирует HTML элементы для каждого элемента в коллекции.Директива используется в массиве объектов:						
						
<div ng-app="" ng-init="names=['Jani','Hege','Kai']">
  <ul>
    <li ng-repeat="x in names">
      {{ x }}
    </li>
  </ul>
</div>

Или :

 <div ng-app="" ng-init="names=[
{name:'Jani',country:'Norway'},
{name:'Hege',country:'Sweden'},
{name:'Kai',country:'Denmark'}]">

<ul>
  <li ng-repeat="x in names">
    {{ x.name + ', ' + x.country }}
  </li>
</ul>

</div> 

											Директива ng-app 
ng-app - директива определяет корневой(root) элемент в AngularJS приложения.											
ng-app - директива will auto-bootstrap (автоматически инициализировать) приложение, когда веб-страница загружается.
											
											Директива ng-init 
ng-init - Директива определяет начальные значения для AngularJS приложения.
Как правило, мы не будем использовать ng-init. Мы будем использовать контроллер или модуль вместо этого.						
						
						
											Директива ng-model
ng-model - Директива  связывает значение управления HTML (input, select, textarea) к данным приложения.
ng-model директива также может:	
	Предоставить тип проверки для данных приложения (number, email, required)
	Предоставить статус для данных приложения (invalid, dirty, touched, error).
	Предоставить классы CSS для HTML-элементов.
	Соединять HTML элементы к HTML формам
					
						
											Создание новой директивы 
В дополнение ко всем директивам встроенные AngularJS, мы можем создавать свои собственные директивы.
Новые директивы создаются с помощью функции .directive						
Что бы вызвать новую директиву нужно добавить HTML элементу имя 
При названии директивы нужно использовать дефисы w3-test-directive,а при вызове директивы горбатый регистр  w3TestDirective


<body ng-app="myApp">
<w3-test-directive></w3-test-directive>

<script>
var app = angular.module("myApp", []);
app.directive("w3TestDirective", function() {
    return {
        template : "<h1>Made by a directive!</h1>"
    };
});
</script>
</body>
						
Мы можем вызвать директиву с помощью:
    Element name
    Attribute
    Class
    Comment
						
Например:						

								Element name: <w3-test-directive></w3-test-directive>
//Выше пример 
----------------------------------------------------------------------------------------------
						Attribute: <div w3-test-directive></div>

<div w3-test-directive></div>
<script>
var app = angular.module("myApp", []);
app.directive("w3TestDirective", function() {
    return {
        template : "<h1>Made by a directive!</h1>"
    };
});
</script>
---------------------------------------------------------------------------------------------									
							Class	<div class="w3-test-directive"></div>


						
<body ng-app="myApp">
<div class="w3-test-directive"></div>
<script>
var app = angular.module("myApp", []);
app.directive("w3TestDirective", function() {
    return {
        restrict : "C",  //Нужно добавить или не будет работать 
        template : "<h1>Made by a directive!</h1>"
    };
});
</script>
<p><strong>Note:</strong> You must add the value "C" to the restrict property to be able to invoke the directive from a class name.</p>						
----------------------------------------------------------------------------------------------						
							Comment   <!-- directive: w3-test-directive -->
						
<!DOCTYPE html>
<html>
<script src="http://ajax.googleapis.com/ajax/libs/angularjs/1.4.8/angular.min.js"></script>
<body ng-app="myApp">

<!-- directive: w3-test-directive -->

<script>
var app = angular.module("myApp", []);
app.directive("w3TestDirective", function() {
    return {
        restrict : "M",
        replace : true,
        template : "<h1>Made by a directive!</h1>"
    };
});
</script>

<p><strong>Note:</strong> We've added the <strong>replace</strong> property in this example, otherwise the comment would be invisible.</p>

<p><strong>Note:</strong> You must add the value "M" to the <strong>restrict</strong> property to be able to invoke the directive from a comment.</p>

</body>
</html>						
						
						
												Restrictions(Ограничения)
Мы можете ограничить директивы, которые будут вызываться только некоторыми из методов.
Например, при добавлении ограниченного свойство со значением "A", директива может быть вызвана только атрибутами:						
						
var app = angular.module("myApp", []);
app.directive("w3TestDirective", function() {
    return {
        restrict : "A",
        template : "<h1>Made by a directive!</h1>"
    };
});						
						
The legal restrict values are:
    E for Element name
    A for Attribute
    C for Class
    M for Comment
						
По умолчанию значение ЕА, а это означает, что оба, названия элементов и атрибутов имен может ссылаться на директиву.						
						
						
	
C помощью директивы ng-model мы можем связать значение input:	
						
						
 <div ng-app="myApp" ng-controller="myCtrl">
    Name: <input ng-model="name">
</div>

<script>
var app = angular.module('myApp', []);
app.controller('myCtrl', function($scope) {
    $scope.name = "John Doe";
});
</script>						
						
						
									Проверить на корректность email 									
ng-model - директива может обеспечить тип проверки для данных(number, e-mail, required) 

<form ng-app="" name="myForm">
    Email:
    <input type="email" name="myAddress" ng-model="text">
    <span ng-show="myForm.myAddress.$error.email">Not a valid e-mail address</span>
</form>
						
В приведенном выше примере, span будет отображаться только в случае,если выражение в ng-show возвратит true												
Если свойство ng-model не существует, AngularJS создаст.						
						
						
									Статус 
ng-model - может предоставить статус для данных приложения (invalid, dirty, touched, error):

<form ng-app="" name="myForm" ng-init="myText = 'post@myweb.com'">

Email:
<input type="email" name="myAddress" ng-model="myText" required>
<p>Edit the e-mail address, and try to change the status.</p>
<h1>Status</h1>
<p>Valid: {{myForm.myAddress.$valid}} (if true, the value meets all criteria).</p>
<p>Dirty: {{myForm.myAddress.$dirty}} (if true, the value has been changed).</p>
<p>Touched: {{myForm.myAddress.$touched}} (if true, the field has been in focus).</p>

</form>						
						
						
			
										CSS Classes
ng-model - данная директива предоставляет CSS класс для HTML элемента в зависимости от ихнего статуса:


 <style>
input.ng-invalid {
    background-color: lightblue;
}
</style>
<body>

<form ng-app="" name="myForm">
    Enter your name:
    <input name="myName" ng-model="myText" required>
</form>
						
						
Список классов:

ng-empty 
ng-not-empty
ng-touched
ng-untouched
ng-valid	-- если форма заполнена 
ng-invalid  -- если форма не заполнена
ng-dirty  	-- если форма была измененна
ng-pending  -- если форма в ожидании 
ng-pristine -- если форма не тронута
						
						
						
												HTML View(представление)
The HTML container where the AngularJS application is displayed, is called the view.
The view has access to the model, and there are several ways of displaying model data in the view.	
Мы можете использовать директиву ng-bind, которая связывает innerHTML элемента к указанному свойству модели 

<div data-ng-app="myApp" data-ng-controller="myCtrl">
	<input type="text" data-ng-model="name">
</div>

<script>
	var app = angular.module("myApp", []);
	
	app.controller("myCtrl", function($scope){
		$scope.name = "Alexey";
	});
</script>



Директива ng-model обеспечивает двустороннее связывание между моделью и представлением.

												Двустороннее связывание					

<div ng-app="myApp" ng-controller="myCtrl">
    Name: <input ng-model="firstname">
    <h1>{{firstname}}</h1>
</div>

<script>
var app = angular.module('myApp', []);
app.controller('myCtrl', function($scope) {
    $scope.firstname = "John";
    $scope.lastname = "Doe";
});
</script>


												AngularJS Controller
Приложения в AngularJS управляются контроллерами.
Благодаря привязке данных в AngularJS, вид(представление) будет отражать любые изменения, сделанные в контроллере.



<div data-ng-app="myApp" data-ng-controller="myCtrl">
<p data-ng-click="handleClick()">{{name}}</p>
</div>

<script>
var app = angular.module("myApp", []);

app.controller("myCtrl", function($scope){
	$scope.name = "Alexey";
	$scope.handleClick = function() {
		$scope.name = "Boo-Ga-ga";
	}
});


AngularJS контроллеры управляют данными AngularJS приложений. AngularJS контроллеры являются обычными объектами JavaScript.
AngularJS приложения управляются контроллерами. Директива ng-controller находит контроллер приложения.
Контроллер представляет собой объект JavaScript, созданный с помощью стандартного конструктора объекта JavaScript.


												Методы контролера 
<div ng-app="myApp" ng-controller="personCtrl">

First Name: <input type="text" ng-model="firstName"><br>
Last Name: <input type="text" ng-model="lastName"><br>
<br>
Full Name: {{fullName()}}

</div>

<script>
var app = angular.module('myApp', []);
app.controller('personCtrl', function($scope) {
    $scope.firstName = "John";
    $scope.lastName = "Doe";
    $scope.fullName = function() {
        return $scope.firstName + " " + $scope.lastName;
    };
});
</script> 												


												Контроллеры во внешних файлах
В больших приложениях это нормально хранить контролеры во внешних файлах.Нужно просто скопировать код между  <script> tags во внешних файл:												

<div ng-app="myApp" ng-controller="personCtrl">

First Name: <input type="text" ng-model="firstName"><br>
Last Name: <input type="text" ng-model="lastName"><br>
<br>
Full Name: {{fullName()}}

</div>

<script src="personController.js"></script> 


													Scope
The scope is the binding part between the HTML (view) and the JavaScript (controller).
The scope is an object with the available properties and methods.
The scope is available for both the view and the controller.

												Использование												
Когда мы делаем контроллер в AngularJS, мы передать объект $scope в качестве аргумента:												


<div ng-app="myApp" ng-controller="myCtrl">
	<h1>{{carname}}</h1>
</div>

<script>
	var app = angular.module('myApp', []);
	app.controller('myCtrl', function($scope) {
		$scope.carname = "Volvo";
	});
</script>


Когда мы добавляем свойство к обьекту $scope в контролере  представление(the view (HTML)) получает доступ к этим свойствам.
В представлении мы не используем префикс $scope мы просто ссылаемся на имя свойства как в примере с {{carname}}

Если мы расматриваем AngularJS приложения то они состоят из 
   
	View, which is the HTML.(Представление)
    Model, which is the data available for the current view.
    Controller, which is the JavaScript function that makes/changes/removes/controls the data.

Scope является объектом JavaScript со свойствами и методами, которые доступны как для просмотра и контроллера.

											Root Scope
Все приложения имеют $rootScope который является Scope созданным для HTML элемента который является частью директивы ng-app 
$rootScope доступен во всем приложении.
Если переменная имеет такое же имя, в $scope и $rootScope, то в данном  приложение будет использован один scope.
Например, Переменная с именем "цвет" существует в области видимости и контроллер, и в rootScope::


<body ng-app="myApp">

<p>The rootScope's favorite color:</p>
<h1>{{color}}</h1>

<div ng-controller="myCtrl">
    <p>The scope of the controller's favorite color:</p>
    <h1>{{color}}</h1>
</div>

<p>The rootScope's favorite color is still:</p>
<h1>{{color}}</h1>

<script>
var app = angular.module('myApp', []);
app.run(function($rootScope) {
    $rootScope.color = 'blue';
});
app.controller('myCtrl', function($scope) {
    $scope.color = "red";
});
</script>
</body>


													AngularJS Filters
Фильтры могут быть добавлены в AngularJS для форматирования данных.													
													
													
<div data-ng-app="myApp" >
		<div data-ng-controller="myCtrl">
			<p>Filters:</p>
			<ul>
				<li data-ng-repeat="x in masiv">{{(x.name | uppercase) + " " + x.country }}</li>
			</ul>
		</div>
	</div>
<script>

	var app = angular.module("myApp", []);
	
	var masiv = [{name: "Alexandra", country: "France"},
				{name: "Alexey", country: "Ukrane"},
				{name: "Bob", country: "USA"}];
	app.controller("myCtrl", function($scope) {
		$scope.masiv = masiv;
	});		
	
</script>													
													
//{(x.name | uppercase) - фильтр													
													
AngularJS provides filters to transform data:

    currency  --- Format a number to a currency format.
    date --- Format a date to a specified format.
    filter --- Select a subset of items from an array.
    json --- Format an object to a JSON string.
    limitTo --- Limits an array/string, into a specified number of elements/characters.
    lowercase --- Format a string to lower case.
    number --- Format a number to a string.
    orderBy --- Orders an array by an expression. Сортирует по алфавиту 
    uppercase --- Format a string to upper case.
													
													
											Добавление фильтров в выражения			
Фильтры могут быть добавлены к выражениям с помощью символа  |
		
<p>The name is {{ lastName | lowercase }}</p>													
													
													
											Добавление фильтров to Directives				
													
The orderBy filter sorts an array:

<div ng-app="myApp" ng-controller="namesCtrl">

<ul>
  <li ng-repeat="x in names | orderBy:'country'">
    {{ x.name + ', ' + x.country }}
  </li>
</ul>

</div> 													
---------------------------------------------------------------------------------------------------------													
												currency																
<h1>Price: {{ price | currency }}</h1>													
Данный фильтр используется для цен,автоматически добавляет знак $, используется только для numbers

Синтаксис:
{{ number | currency : symbol : fractionsize }}

Например:

<div ng-app="myApp" ng-controller="costCtrl">
	<p>Price = {{ price | currency : "Какой-то знак" : 3}}</p>
</div>
<script>
	var app = angular.module('myApp', []);
	app.controller('costCtrl', function($scope) {
		$scope.price = 9.99;
	});
</script>

В результате: Price = Какой-то знак9.99000   
---------------------------------------------------------------------------------------------------------												
												filter
Фильтр Фильтр выбирает подмножество массива.
Фильтр фильтр может быть использован только на массивах, и он возвращает массив, содержащий только элементы, совпадающие.										
		
<div ng-app="myApp" ng-controller="namesCtrl">
	<ul>
	  <li ng-repeat="x in names | filter : 'i'">
		{{ x }}
	  </li>
	</ul>
</div>

<script>
angular.module('myApp', []).controller('namesCtrl', function($scope) {
    $scope.names = [
        'Jani',
        'Carl',
        'Margareth',
        'Hege',
        'Joe',
        'Gustav',
        'Birgit',
        'Mary',
        'Kai'
    ];
});
</script>
<p>This example displays only the names containing the letter "i".</p>

Или такой пример: 


<div ng-app="myApp" ng-controller="namesCtrl">
	<p>Type a letter in the input field:</p>

	<p><input type="text" ng-model="test"></p>

	<ul>
	  <li ng-repeat="x in names | filter:test">
		{{ x }}
	  </li>
	</ul>
</div>

<script>
	angular.module('myApp', []).controller('namesCtrl', function($scope) {
		$scope.names = [
			'Jani',
			'Carl',
			'Margareth',
			'Hege',
			'Joe',
			'Gustav',
			'Birgit',
			'Mary',
			'Kai'
		];
	});
</script>


http://www.w3schools.com/angular/ng_filter_filter.asp		
---------------------------------------------------------------------------------------------------------	
												orderBy
 <div ng-app="myApp" ng-controller="namesCtrl">

<table border="1" width="100%">
  <tr>
    <th ng-click="orderByMe('name')">Name</th>
    <th ng-click="orderByMe('country')">Country</th>
  </tr>
  <tr ng-repeat="x in names | orderBy:myOrderBy">
    <td>{{x.name}}</td>
    <td>{{x.country}}</td>
  </tr>
</table>

</div>

<script>
angular.module('myApp', []).controller('namesCtrl', function($scope) {
  $scope.names = [
    {name:'Jani',country:'Norway'},
    {name:'Carl',country:'Sweden'},
    {name:'Margareth',country:'England'},
    {name:'Hege',country:'Norway'},
    {name:'Joe',country:'Denmark'},
    {name:'Gustav',country:'Sweden'},
    {name:'Birgit',country:'Denmark'},
    {name:'Mary',country:'England'},
    {name:'Kai',country:'Norway'}
  ];
  $scope.orderByMe = function(x) {
    $scope.myOrderBy = x;
  }
});
</script>

//Сортировка при клике по алфавиту 												
---------------------------------------------------------------------------------------------------------
										Можно также создавать свои фильтры:

<ul ng-app="myApp" ng-controller="namesCtrl">
    <li ng-repeat="x in names">
        {{x | myFormat}}
    </li>
</ul>

<script>
var app = angular.module('myApp', []);
app.filter('myFormat', function() {
    return function(x) {
        var i, c, txt = "";
        for (i = 0; i < x.length; i++) {
            c = x[i];
            if (i % 2 == 0) {
                c = c.toUpperCase();
            }
            txt += c;
        }
        return txt;
    };
});
app.controller('namesCtrl', function($scope) {
    $scope.names = ['Jani', 'Carl', 'Margareth', 'Hege', 'Joe', 'Gustav', 'Birgit', 'Mary', 'Kai'];
});
</script>
										
---------------------------------------------------------------------------------------------------------													
													
									
												AngularJS Services
В AngularJS, Services является функцией, или объект, который доступен приложение AngularJS.
AngularJS имеет около 30 встроенных служб. Одним из них является услуга location.									
The $location service has methods which return information about the location of the current web page:
													
var app = angular.module('myApp', []);
app.controller('customersCtrl', function($scope, $location) {
    $scope.myUrl = $location.absUrl();
});													
													
//Cлужба $location передается к контроллеру в качестве аргумента. Для того чтобы воспользоваться услугой в контроллере, он должен быть определен как зависимость.													
													
													Why use Services?
Можно конечно использовать window.location вместо $location услуги AngularJS, но там есть ряд ограничений для AngularJS приложений и для более 
лучшего управления AngularJS приложением лучше использовать его функциями/обьектами/услугами...													
													

--------------------------------------------------------------------------------------------------------------------------------													
													The $http Service
Услуга $ HTTP является одним из наиболее распространенных используемых услуг в AngularJS приложениях. 
Услуга делает запрос на сервер, и позволяет нашим приложениям обрабатывать ответ.

<div ng-app="myApp" ng-controller="myCtrl"> 
	<p>Today's welcome message is:</p>
	<h1>{{myWelcome}}</h1>
</div>

<p>The $http service requests a page on the server, and the response is set as the value of the "myWelcome" variable.</p>

<script>
	var app = angular.module('myApp', []);
	app.controller('myCtrl', function($scope, $http) {
	  $http.get("welcome.htm").then(function (response) {
		  $scope.myWelcome = response.data;
	  });
});
</script>

http://www.w3schools.com/angular/angular_http.asp
--------------------------------------------------------------------------------------------------------------------------------
													$timeout
//The $timeout service is AngularJS' version of the window.setTimeout function.													
	
<div ng-app="myApp" ng-controller="myCtrl"> 
	<p>This header will change after two seconds:</p>
	<h1>{{myHeader}}</h1>
</div>

<p>The $timeout service runs a function after a sepecified number of milliseconds.</p>

<script>
var app = angular.module('myApp', []);
app.controller('myCtrl', function($scope, $timeout) {
  $scope.myHeader = "Hello World!";
  $timeout(function () {
      $scope.myHeader = "How are you today?";
  }, 2000);
});
</script>

//через 2 сек поменяет название 
--------------------------------------------------------------------------------------------------------------------------------
													$interval
//The $interval service is AngularJS' version of the window.setInterval function.
	
<div ng-app="myApp" ng-controller="myCtrl"> 
	<p>The time is:</p>
	<h1>{{theTime}}</h1>
</div>

<p>The $interval service runs a function every specified millisecond.</p>

<script>
var app = angular.module('myApp', []);
app.controller('myCtrl', function($scope, $interval) {
  $scope.theTime = new Date().toLocaleTimeString();
  $interval(function () {
      $scope.theTime = new Date().toLocaleTimeString();
  }, 1000);
});
</script>	

--------------------------------------------------------------------------------------------------------------------------------
												Create Your Own Service

<div ng-app="myApp" ng-controller="myCtrl">
	<p>The hexadecimal value of 255 is:</p>
	<h1>{{hex}}</h1>
</div>

<p>A custom service whith a method that converts a given number into a hexadecimal number.</p>

<script>
	var app = angular.module('myApp', []);

	app.service('hexafy', function() {
		this.myFunc = function (x) {
			return x.toString(16);
		}
	});
	app.controller('myCtrl', function($scope, hexafy) {
	  $scope.hex = hexafy.myFunc(240);
	});
</script>
												
--------------------------------------------------------------------------------------------------------------------------------
													Service Inside a Filter
После того, как мы создали услугу, и подключили его к нашему приложению, мы можете воспользоваться услугой в любом контроллере, директива, фильтр, или даже внутри других услуг.
Чтобы воспользоваться услугой, внутри фильтра, добавьте его в качестве зависимости при определении фильтра:

<div ng-app="myApp" ng-controller="myCtrl">
	<p>Use a filter when displayin the array [255, 251, 200]:</p>

	<ul>
	  <li ng-repeat="x in counts">{{x | myFormat}}</li>
	</ul>

	<p>This filter uses a service that converts numbers into hexadecimal values.</p>
</div>

<script>
	var app = angular.module('myApp', []);
	app.service('hexafy', function() {
		this.myFunc = function (x) {
			return x.toString(16);
		}
	});
	app.filter('myFormat',['hexafy', function(hexafy) {
		return function(x) {
			return hexafy.myFunc(x);
		};
	}]);
	app.controller('myCtrl', function($scope) {
		$scope.counts = [255, 251, 200];
	});
</script>
--------------------------------------------------------------------------------------------------------------------------------


													AngularJS AJAX - $http

$ HTTP является AngularJS сервис для считывания данных с удаленных серверов.
Служба $http AngularJS  делает запрос на сервер и возвращает ответ.													


<div ng-app="myApp" ng-controller="myCtrl">

<p>Today's welcome message is:</p>
<h1>{{myWelcome}}</h1>

</div>

<script>
var app = angular.module('myApp', []);
app.controller('myCtrl', function($scope, $http) {
    $http.get("welcome.htm")
    .then(function(response) {
        $scope.myWelcome = response.data;
    });
});
</script>


Методы: 

.delete()
.get()
.head()
.jsonp()
.patch()
.post()
.put()


Свойства:
Ответ от сервера является объектом с этими свойствами:


.config --- the object used to generate the request.
.data --- a string, or an object, carrying the response from the server.
.headers --- a function to use to get header information.
.status --- a number defining the HTTP status.
.statusText --- a string defining the HTTP status.

Например: 

<div ng-app="myApp" ng-controller="myCtrl"> 

<p>Data : {{content}}</p>
<p>Status : {{statuscode}}</p>
<p>StatusText : {{statustext}}</p>

</div>

<p>The response object has many properties. This example demonstrate the value of the data, status, and statusText properties.</p>

<script>
var app = angular.module('myApp', []);
app.controller('myCtrl', function($scope, $http) {
  $http.get("welcome.htm")
  .then(function(response) {
      $scope.content = response.data;
      $scope.statuscode = response.status;
      $scope.statustext = response.statusText;            
  });
});
</script>



Для обработки ошибок, добавьте еще одну функции к .then методу:

<div data-ng-app="myApp" data-ng-controller="myCtrl">
		<ul>
			<li data-ng-repeat="x in name">{{x.name }}</li>
		</ul>
		<p>Status: {{error}} </p>
	</div>
	<script>
		var app = angular.module("myApp", []);
		
		app.controller("myCtrl", function($scope, $http) {
			$http.get("generated.jso").then(function(response){
				$scope.name = response.data;		
			},
			function(response){
					$scope.error = "Something went wrong!";
				});
		});
	</script>



														Таблицы 
Для отображения таблицы индекса(нумерации), добавьте <td> with $index:  

<table>
  <tr ng-repeat="x in names">
    <td>{{ $index + 1 }}</td>
    <td>{{ x.Name }}</td>
    <td>{{ x.Country }}</td>
  </tr>
</table> 

											Добавление разных цветов 
<table>
	<tr data-ng-repeat="x in name">
		<td> {{$index + 1}}</td>
		<td data-ng-if="$odd" style="background-color: red">{{x.name}}</td>
		<td data-ng-if="$even">{{x.name}}</td>
		<td data-ng-if="$odd" style="background-color: blue">{{x.phone}}</td>
		<td data-ng-if="$even">{{x.phone}}</td>
	</tr>
</table>											


												Select
AngularJS позволяет создавать выпадающие списки на основе элементов в массиве или объекта.		
Если мы хотим создать выпадающий список,основанный на объекте или массив в AngularJS,мы должны использовать директиву ng-options:												
												
<div ng-app="myApp" ng-controller="myCtrl">
	<select ng-model="selectedName" ng-options="x for x in names"></select>
</div>

<script>
	var app = angular.module('myApp', []);
	app.controller('myCtrl', function($scope) {
		$scope.names = ["Emil", "Tobias", "Linus"];
	});
</script>												


										ng-options vs ng-repeat
You can also use the ng-repeat directive to make the same dropdown list:

<select>
	<option ng-repeat="x in names">{{x}}</option>
</select>


Поскольку директива ng-repeat повторяет блок HTML кода для каждого элемента в массиве, он может быть использован для создания вариантов в раскрывающемся списке, 
но директива ng-options была сделана специально для заполнения выпадающих списоков с вариантами, и имеет по крайней мере одно важное преимущество:
Выпадающие списки, сделанные с ng-options позволяет что бы выбранное значение было объектом, в то время как выпадающие списки, сделанные из ng-repeat должены быть строкой.

Лучше использовать ng-options так как потом можно обращатся к обьектам, а используя ng-repeat мы этого сделать не сможем так как там толькос строка,например :


<div ng-app="myApp" ng-controller="myCtrl">
	<p>Select a car:</p>
	<select ng-model="selectedCar">
	<option ng-repeat="x in cars" value="{{x.model}}">{{x.model}}</option>
	</select>
	<h1>You selected: {{selectedCar}}</h1>
</div>

<script>
	var app = angular.module('myApp', []);
	app.controller('myCtrl', function($scope) {
		$scope.cars = [
			{model : "Ford Mustang", color : "red"},
			{model : "Fiat 500", color : "white"},
			{model : "Volvo XC90", color : "black"}
		];
	});
</script>


Используя ng-options значение может быть обьектом к которому мы потом легко сможем обращатся:

<div ng-app="myApp" ng-controller="myCtrl">
	<p>Select a car:</p>
	<select ng-model="selectedCar" ng-options="x.model for x in cars">
	</select>
	<h1>You selected: {{selectedCar.model}}</h1> //Общашение к обьекту легко и просто с ng-repeat мы так не сможем там строка
	<p>Its color is: {{selectedCar.color}}</p>
</div>

<script>
	var app = angular.module('myApp', []);
	app.controller('myCtrl', function($scope) {
		$scope.cars = [
			{model : "Ford Mustang", color : "red"},
			{model : "Fiat 500", color : "white"},
			{model : "Volvo XC90", color : "black"}
		];
	});
</script>



											Достаем данные из обьекта(до этого обьекты были в массиве)
<div ng-app="myApp" ng-controller="myCtrl">
	<p>Select a car:</p>
	<select ng-model="selectedCar" ng-options="x for (x, y) in cars">
	</select>
	<h1>You selected: {{selectedCar}}</h1>
</div>
<p>This example demonstrates the use of an object as the data source when creating a dropdown list.</p>
<script>
	var app = angular.module('myApp', []);
	app.controller('myCtrl', function($scope) {
		$scope.cars = {
			car01 : "Ford",
			car02 : "Fiat",
			car03 : "Volvo"
		}
	});
</script>

/*
	ng-options="x for (x, y) in cars" 
	х - это ключ(car01,car02 ...)
	у - это значение (Ford,Fiat...)
*/

													Обьект в обьекте 
<div ng-app="myApp" ng-controller="myCtrl">

	<p>Select a car:</p>

	<select ng-model="selectedCar" ng-options="x for (x, y) in cars">
	</select>

	<h1>You selected: {{selectedCar.brand}}</h1>
	<h2>Model: {{selectedCar.model}}</h2>
	<h3>Color: {{selectedCar.color}}</h3>

	<p>Note that the selected value represents an object.</p>
</div>

<script>
	var app = angular.module('myApp', []);
	app.controller('myCtrl', function($scope) {
		$scope.cars = {
			car01 : {brand : "Ford", model : "Mustang", color : "red"},
			car02 : {brand : "Fiat", model : "500", color : "white"},
			car03 : {brand : "Volvo", model : "XC90", color : "black"}
		}
	});
</script>


Также можно что бы в выпадающем списке выводило значение(а не ключ) например:

<div ng-app="myApp" ng-controller="myCtrl">
	<p>Select a car:</p>

	<select ng-model="selectedCar" ng-options="y.brand for (x, y) in cars">
	</select>

	<h1>You selected: {{selectedCar.brand}}</h1>
	<h2>Model: {{selectedCar.model}}</h2>
	<h3>Color: {{selectedCar.color}}</h3>

	<p>The visible text inside the dropdown list can also be a property of the value object.</p>
</div>

<script>
	var app = angular.module('myApp', []);
	app.controller('myCtrl', function($scope) {
		$scope.cars = {
			car01 : {brand : "Ford", model : "Mustang", color : "red"},
			car02 : {brand : "Fiat", model : "500", color : "white"},
			car03 : {brand : "Volvo", model : "XC90", color : "black"}
		}
	});
</script>

//Теперь в выпадающем списке вместо ключей(car01,car02,car03) ,будет значение бренда (Ford,Fiat,Volvo)

										

																AngularJS SQL
AngularJS идеально подходит для отображения данных из базы данных. Просто убедитесь, что данные в формате JSON.
Извлечение данных из PHP сервера MySQL:

<div ng-app="myApp" ng-controller="customersCtrl"> 
	<table>
	  <tr ng-repeat="x in names">
		<td>{{ x.Name }}</td>
		<td>{{ x.Country }}</td>
	  </tr>
	</table>
</div>
 
<script>
	var app = angular.module('myApp', []);
	app.controller('customersCtrl', function($scope, $http) {
	   $http.get("http://www.w3schools.com/angular/customers_mysql.php")
	   .then(function (response) {$scope.names = response.data.records;});
	});
</script>		

														

Извлечение данных из ASP.NET Server Running SQL:

<div ng-app="myApp" ng-controller="customersCtrl">
	<table>
	  <tr ng-repeat="x in names">
		<td>{{ x.Name }}</td>
		<td>{{ x.Country }}</td>
	  </tr>
	</table>
</div>

<script>
	var app = angular.module('myApp', []);
	app.controller('customersCtrl', function($scope, $http) {
		$http.get("http://www.w3schools.com/angular/customers_sql.aspx")
		.then(function (response) {$scope.names = response.data.records;});
	});
</script>
	


Cписок серверного кода, используемого для извлечения данных SQL:
	Using PHP and MySQL. Returning JSON.
	Using PHP and MS Access. Returning JSON.
	Using ASP.NET, VB, and MS Access. Returning JSON.
	Using ASP.NET, Razor, and SQL Lite. Returning JSON.


												Cross-Site HTTP Requests(запросы на другие серверы)
Запросы на получение данных от другого сервера , называются Cross-Site HTTP Requests.
запросы Cross-Site являются общими в Интернете. Многие страницы загружаются CSS, изображения и скрипты с разных серверов.
В современных браузерах, Cross-Site HTTP Requests из сценариев ограничены по соображениям безопасности.
Следующая строка, в наших примерах PHP, была добавлена, чтобы разрешить доступ:

header("Access-Control-Allow-Origin: *");


1. Server Code PHP and MySQL:

<?php
header("Access-Control-Allow-Origin: *");
header("Content-Type: application/json; charset=UTF-8");

$conn = new mysqli("myServer", "myUser", "myPassword", "Northwind");

$result = $conn->query("SELECT CompanyName, City, Country FROM Customers");

$outp = "";
while($rs = $result->fetch_array(MYSQLI_ASSOC)) {
    if ($outp != "") {$outp .= ",";}
    $outp .= '{"Name":"'  . $rs["CompanyName"] . '",';
    $outp .= '"City":"'   . $rs["City"]        . '",';
    $outp .= '"Country":"'. $rs["Country"]     . '"}';
}
$outp ='{"records":['.$outp.']}';
$conn->close();

echo($outp);
?>


2. Server Code PHP and MS Access:


<?php
header("Access-Control-Allow-Origin: *");
header("Content-Type: application/json; charset=ISO-8859-1");

$conn = new COM("ADODB.Connection");
$conn->open("PROVIDER=Microsoft.Jet.OLEDB.4.0;Data Source=Northwind.mdb");

$rs = $conn->execute("SELECT CompanyName, City, Country FROM Customers");

$outp = "";
while (!$rs->EOF) {
    if ($outp != "") {$outp .= ",";}
    $outp .= '{"Name":"'  . $rs["CompanyName"] . '",';
    $outp .= '"City":"'   . $rs["City"]        . '",';
    $outp .= '"Country":"'. $rs["Country"]     . '"}';
    $rs->MoveNext();
}
$outp ='{"records":['.$outp.']}';

$conn->close();

echo ($outp);
?>



3. Server Code ASP.NET, VB and MS Access:

<%@ Import Namespace="System.IO"%>
<%@ Import Namespace="System.Data"%>
<%@ Import Namespace="System.Data.OleDb"%>
<%
Response.AppendHeader("Access-Control-Allow-Origin", "*")
Response.AppendHeader("Content-type", "application/json")
Dim conn As OleDbConnection
Dim objAdapter As OleDbDataAdapter
Dim objTable As DataTable
Dim objRow As DataRow
Dim objDataSet As New DataSet()
Dim outp
Dim c
conn = New OledbConnection("Provider=Microsoft.Jet.OLEDB.4.0;data source=Northwind.mdb")
objAdapter = New OledbDataAdapter("SELECT CompanyName, City, Country FROM Customers", conn)
objAdapter.Fill(objDataSet, "myTable")
objTable=objDataSet.Tables("myTable")

outp = ""
c = chr(34)
for each x in objTable.Rows
if outp <> "" then outp = outp & ","
outp = outp & "{" & c & "Name"    & c & ":" & c & x("CompanyName") & c & ","
outp = outp &       c & "City"    & c & ":" & c & x("City")        & c & ","
outp = outp &       c & "Country" & c & ":" & c & x("Country")     & c & "}"
next

outp ="{" & c & "records" & c & ":[" & outp & "]}"
response.write(outp)
conn.close
%> 


4. Server Code ASP.NET, Razor C# and SQL Lite:

@{
Response.AppendHeader("Access-Control-Allow-Origin", "*")
Response.AppendHeader("Content-type", "application/json")
var db = Database.Open("Northwind");
var query = db.Query("SELECT CompanyName, City, Country FROM Customers");
var outp =""
var c = chr(34)
}
@foreach(var row in query)
{
if outp <> "" then outp = outp + ","
outp = outp + "{" + c + "Name"    + c + ":" + c + @row.CompanyName + c + ","
outp = outp +       c + "City"    + c + ":" + c + @row.City        + c + ","
outp = outp +       c + "Country" + c + ":" + c + @row.Country     + c + "}"
}
outp ="{" + c + "records" + c + ":[" + outp + "]}"
@outp 




														AngularJS HTML DOM	
													The ng-disabled Directive	
The ng-disabled directive binds AngularJS application data to the disabled attribute of HTML elements.


<div ng-app="" ng-init="mySwitch=true">
	<p>
	<button ng-disabled="mySwitch">Click Me!</button>
	</p>
	
	<p>
	<input type="checkbox" ng-model="mySwitch"/>Button
	</p>
	
	<p>
	{{ mySwitch }}
	</p>
</div> 

	

				The ng-show Directive
The ng-show directive shows or hides an HTML element.			

<div ng-app="">
	<p ng-show="true">I am visible.</p>
	<p ng-show="false">I am not visible.</p>
</div> 
																
Можно также использовать выражение которые определяют true или false в этой директиве:

<div ng-app="" ng-init="hour=13">
	<p ng-show="hour > 12">I am visible.</p>
</div> 																
																
																
					The ng-hide Directive
The ng-hide directive hides or shows an HTML element.																
																
<div ng-app="">
	<p ng-hide="true">I am not visible.</p>
	<p ng-hide="false">I am visible.</p>
</div> 																
																
																
														AngularJS Events
You can add AngularJS event listeners to your HTML elements by using one or more of these directives:

ng-blur  --- при выходе из фокуса
ng-change --- при изменении
ng-click
ng-copy  --- при копировании
ng-cut  --- при вырезании
ng-dblclick
ng-focus
ng-keydown 
ng-keypress
ng-keyup
ng-mousedown
ng-mouseenter
ng-mouseleave
ng-mousemove
ng-mouseover
ng-mouseup
ng-paste  --- при Копи Пасте (когда вставляем что-то)
																

AngularJS событие не будет перезаписывать событие HTML, оба события будут выполнены																

Например: 

<div ng-app="myApp" ng-controller="myCtrl">
	<button ng-click="myFunction()">Click me!</button>
	<p>{{ count }}</p>
</div>
<script>
	var app = angular.module('myApp', []);
	app.controller('myCtrl', function($scope) {
		$scope.count = 0;
		$scope.myFunction = function() {
			$scope.count++;
		}
	});
</script> 


												Toggle, True/False
<div ng-app="myApp" ng-controller="myCtrl">
	<button ng-click="myFunc()">Click Me!</button>
	<div ng-show="showMe">
		<h1>Menu:</h1>
		<div>Pizza</div>
		<div>Pasta</div>
		<div>Pesce</div>
	</div>
</div>
<script>
	var app = angular.module('myApp', []);
	app.controller('myCtrl', function($scope) {
		$scope.showMe = false;
		$scope.myFunc = function() {
			$scope.showMe = !$scope.showMe;
		}
	});
</script>												

												
												$event Object

Объект $event содержит объект события браузера:

<div ng-app="myApp" ng-controller="myCtrl">
	<h1 ng-mousemove="myFunc($event)">Mouse Over Me!</h1>
	<p>Coordinates: {{x + ', ' + y}}</p>
</div>
<script>
	var app = angular.module('myApp', []);
	app.controller('myCtrl', function($scope) {
		$scope.myFunc = function(myE) {
			$scope.x = myE.clientX;
			$scope.y = myE.clientY;
		}
	});
</script> 



												AngularJS Forms
Формы в AngularJS обеспечивают привязку данных и проверки элементов управления вводом.

Input Controls. Input controls are the HTML input elements:

    input elements
    select elements
    button elements
    textarea elements


Data-Binding(Привязка данных):


<input type="text" ng-model="firstname">

Директива ng-model связывает контроллер ввода с остальной частью вашего приложения.


													Checkbox		
<div ng-app="">
  <form>
    Check to show a header:
    <input type="checkbox" ng-model="myVar">
  </form>
  <h1 ng-show="myVar">My Header</h1>
</div>
<p>The header's ng-show attribute is set to true when the checkbox is checked.</p>

//Имитация toogle простая и удобная,по умолчанию checkbox= false ,а при клике true 

						
												Radiobuttons	
Radio buttons with the same ng-model can have different values, but only the selected one will be used.

<form>
  Pick a topic:
  <input type="radio" ng-model="myVar" value="dogs">Dogs
  <input type="radio" ng-model="myVar" value="tuts">Tutorials
  <input type="radio" ng-model="myVar" value="cars">Cars
</form>

<div ng-switch="myVar">
  <div ng-switch-when="dogs">
     <h1>Dogs</h1>
     <p>Welcome to a world of dogs.</p>
  </div>
  <div ng-switch-when="tuts">
     <h1>Tutorials</h1>
     <p>Learn from examples.</p>
  </div>
  <div ng-switch-when="cars">
     <h1>Cars</h1>
     <p>Read about cars.</p>
  </div>
</div>

<p>The ng-switch directive hides and shows HTML sections depending on the value of the radio buttons.</p>


												Selectbox
												
<div data-ng-app="myApp" data-ng-controller="myCtrl">

	<select data-ng-options="x.value as x.name for x in names" data-ng-model="result"></select>
	
	<div data-ng-switch="result">
		<div data-ng-switch-when="3">//if value = 3 thi text will be displayed
			<h1>1</h1>
			<p>WWWWWWWWWWWwwwwwwwwwwwooorrddss</p>
		</div> 
	</div>
	
</div>
<script>

	var app = angular.module("myApp", []);
	 
	var names = [
		{name:'Jani',value: 1,country:'Norway'},
		{name:'Carl',value: 2,country:'Sweden'},
		{name:'Margareth',value: 3,country:'England'},
		{name:'Hege',value: 4,country:'Norway'},
		{name:'Joe',value: 5,country:'Denmark'},
		{name:'Gustav',value: 6,country:'Sweden'},
		{name:'Birgit',value: 7,country:'Denmark'},
		{name:'Mary',value: 8,country:'England'},
		{name:'Kai',value: 9,country:'Norway'}
	];
	
	
	
	app.controller("myCtrl", function($scope){
		$scope.name;
		$scope.names = names;
	});

</script>

														AngularJS Form Validation
AngularJS может проверять входные данные.AngularJS предлагает форму проверки на стороне клиента.
AngularJS следит за состоянием формы и полей ввода (input, textarea, select), и позволяет уведомлять пользователя о текущем состоянии.
AngularJS также содержит информацию о том, были ли они touched, or modified, или нет.
Вы можете использовать стандартные атрибуты HTML5 для проверки вводимых данных, или вы можете сделать свои собственные функции проверки.
Валидация на стороне клиента не может в одиночку обезопасить ввода данных пользователем. Проверка на стороне сервера также необходимо.


Используйте атрибут HTML5, "required" для указания того, что поле ввода должно быть заполнено:

<form name="myForm">
	<input name="myInput" ng-model="myInput" required>
</form>

<p>The input's valid state is:</p>
<h1>{{myForm.myInput.$valid}}</h1>


Тоже самое с email:

<form name="myForm">
	<input name="myInput" ng-model="myInput" type="email">
</form>

<p>The input's valid state is:</p>
<h1>{{myForm.myInput.$valid}}</h1>




														Form State and Input State

AngularJS is constantly updating the state of both the form and the input fields.

Input fields have the following states:

$untouched --- The field has not been touched yet
$touched --- The field has been touched
$pristine --- The field has not been modified yet
$dirty --- The field has been modified
$invalid --- The field content is not valid
$valid --- The field content is valid

They are all properties of the input field, and are either true or false.

Forms have the following states:

$pristine --- No fields have been modified yet
$dirty --- One or more have been modified
$invalid --- The form content is not valid
$valid --- The form content is valid
$submitted --- The form is submitted

They are all properties of the form, and are either true or false.


Например,показать ошибку если поле было затронуто либо непрошло проверку:

<input name="myName" ng-model="myName" required>
<span ng-show="myForm.myName.$touched && myForm.myName.$invalid">The name is required.</span>


														CSS Classes
AngularJS adds CSS classes to forms and input fields depending on their states.
The following classes are added to, or removed from, input fields:

ng-untouched --- The field has not been touched yet
ng-touched --- The field has been touched
ng-pristine --- The field has not been  modified yet
ng-dirty --- The field has been modified
ng-valid --- The field content is valid
ng-invalid --- The field content is not valid
ng-valid-key --- One key for each validation. Example: ng-valid-required, useful when there are more than one thing that must be validated
ng-invalid-key --- Example: ng-invalid-required либо например ng-invalid-email

The following classes are added to, or removed from, forms:

ng-pristine --- No fields has not been modified yet
ng-dirty --- One or more fields has been modified
ng-valid --- The form content is valid
ng-invalid --- The form content is not valid
ng-valid-key --- One key for each validation. Example: ng-valid-required, useful when there are more than one thing that must be validated
ng-invalid-key --- Example: ng-invalid-required

The classes are removed if the value they represent is false.

Например: 


<style>
	input.ng-invalid {
		background-color: pink;
	}
	
	input.ng-valid {
		background-color: lightgreen;
	}
</style>


Либо пример стилизации формы:


<style>
	form.ng-pristine {
		background-color: lightblue;
	}
	
	form.ng-dirty {
		background-color: pink;
	}
</style>


												Создание собственной валидации
<p>Try writing in the input field:</p>

<form name="myForm">
	<input name="myInput" ng-model="myInput" required my-directive>
</form>

<p>The input's valid state is:</p>
<h1>{{myForm.myInput.$valid}}</h1>

<script>
	var app = angular.module('myApp', []);
	app.directive('myDirective', function() {
		return {
			require: 'ngModel',
			link: function(scope, element, attr, mCtrl) {
				function myValidation(value) {
					if (value.indexOf("e") > -1) {
						mCtrl.$setValidity('charE', true);
					} else {
						mCtrl.$setValidity('charE', false);
					}
					return value;
				}
				mCtrl.$parsers.push(myValidation);
			}
		};
	});
</script>
<p>The input field must contain the character "e" to be consider valid.</p>

/*
	In HTML, the new directive will be referred to by using the attribute my-directive.

	In the JavaScript we start by adding a new directive named myDirective.

	Remember, when naming a directive, you must use a camel case name, myDirective, but when invoking it, you must use - separated name, my-directive.

	Then, return an object where you specify that we require  ngModel, which is the ngModelController.

	Make a linking function which takes some arguments, where the fourth argument, mCtrl, is the ngModelController,

	Then specify a function, in this case named myValidation, which takes one argument, this argument is the value of the input element.

	Test if the value contains the letter "e", and set the validity of the model controller to either true or false.

	At last, mCtrl.$parsers.push(myValidation); will add the myValidation function to an array of other functions, which will be executed every time the input value changes.	
*/


или такой пример :

<form  ng-app="myApp"  ng-controller="validateCtrl"
name="myForm" novalidate>//The HTML form attribute novalidate is used to disable default browser validation.

	<p>Username:<br>
	  <input type="text" name="user" ng-model="user" required>
	  <span style="color:red" ng-show="myForm.user.$dirty && myForm.user.$invalid">
	  <span ng-show="myForm.user.$error.required">Username is required.</span>
	  </span>
	</p>

	<p>Email:<br>
	  <input type="email" name="email" ng-model="email" required>
	  <span style="color:red" ng-show="myForm.email.$dirty && myForm.email.$invalid">
	  <span ng-show="myForm.email.$error.required">Email is required.</span>
	  <span ng-show="myForm.email.$error.email">Invalid email address.</span>
	  </span>
	</p>

	<p>
	  <input type="submit"
	  ng-disabled="myForm.user.$dirty && myForm.user.$invalid ||
	  myForm.email.$dirty && myForm.email.$invalid">
	</p>

</form>

<script>
	var app = angular.module('myApp', []);
	app.controller('validateCtrl', function($scope) {
		$scope.user = 'John Doe';
		$scope.email = 'john.doe@gmail.com';
	});
</script>

												
														AngularJS API
AngularJS Global API представляет собой набор глобальных функций JavaScript для выполнения общих задач, таких как:
	Сравнение объектов
	Итерация объекты
	Преобразование данных												
The Global API functions доступны используя the angular object.	Например:

		API 						Description
angular.lowercase() ---	Converts a string to lowercase
angular.uppercase() ---	Converts a string to uppercase
angular.isString() 	---	Returns true if the reference is a string
angular.isNumber() 	---	Returns true if the reference is a number											

												
Пример:

<div ng-app="myApp" ng-controller="myCtrl">
	<p>{{ x1 }}</p>
	<p>{{ x2 }}</p>
</div>

<script>
	var app = angular.module('myApp', []);
	app.controller('myCtrl', function($scope) {
		$scope.x1 = "JOHN";
		$scope.x2 = angular.lowercase($scope.x1);
	});
</script>
										
												
													AngularJS Includes					
With AngularJS, you can include HTML content using the ng-include directive:												

<div data-ng-app="" ng-include="'forInclude.html'"></div>

												Include Cross Domains	
By default, the ng-include directive does not allow you to include files from other domains.
To include files from another domain, you can add a whitelist of legal files and/or domains in the config function of your application:												
												
<body ng-app="myApp">

	<div ng-include="'http://www.refsnesdata.no/angular_include.asp'"></div>

<script>
	var app = angular.module('myApp', [])
	app.config(function($sceDelegateProvider) {
		$sceDelegateProvider.resourceUrlWhitelist([
			'http://www.refsnesdata.no/**'
		]);
	});
</script>

</body>												
												
												
//НО нужно убедится что сервер предоставляет доступ 												
												
												
														AngularJS Animations
AngularJS provides animated transitions, with help from CSS.

<!DOCTYPE html>
<html>
<style>
div {
  transition: all linear 0.5s;
  background-color: lightblue;
  height: 100px;
  width: 100%;
  position: relative;
  top: 0;
  left: 0;
}

.ng-hide {
  height: 0;
  width: 0;
  background-color: transparent;
  top:-200px;
  left: 200px;
}

</style>
<script src="http://ajax.googleapis.com/ajax/libs/angularjs/1.4.8/angular.min.js"></script>
<script src="http://ajax.googleapis.com/ajax/libs/angularjs/1.4.8/angular-animate.js"></script>

<body ng-app="ngAnimate">

<h1>Hide the DIV: <input type="checkbox" ng-model="myCheck"></h1>

<div ng-hide="myCheck"></div>

</body>
</html>


												
												
1.To make your applications ready for animations, you must include the AngularJS Animate library:
<script src="http://ajax.googleapis.com/ajax/libs/angularjs/1.4.8/angular-animate.js"></script>

2.Then you must refer to the ngAnimate module in your application:
<body ng-app="ngAnimate">

3.Or if your application has a name, add ngAnimate as a dependency in your application module:
<body ng-app="myApp">

<h1>Hide the DIV: <input type="checkbox" ng-model="myCheck"></h1>

<div ng-hide="myCheck"></div>

<script>
	var app = angular.module('myApp', ['ngAnimate']);
</script>
												
											
											
											What Does ngAnimate Do?
The ngAnimate module adds and removes classes.
Модуль ngAnimate не анимирует HTML-элементы,но когда ngAnimate замечает определенные события,как hide или show HTML-элемента, 
элемент получает некоторые заранее определенные классы, которые могут быть использованы для производства анимации.
												
The directives in AngularJS who add/remove classes are:

ng-show
ng-hide
ng-class
ng-view
ng-include
ng-repeat
ng-if
ng-switch												
												
The ng-show and ng-hide directives adds or removes a ng-hide class value.

The other directives adds a ng-enter class value when they enter the DOM, and a ng-leave attribute when they are removed from the DOM.

The ng-repeat directive also adds a ng-move class value when the HTML element changes position.

In addition, during the animation, the HTML element will have a set of class values, which will be removed when the animation has finished. Example: the ng-hide directive will add these class values:

ng-animate
ng-hide-animate
ng-hide-add (if the element will be hidden)
ng-hide-remove (if the element will be showed)
ng-hide-add-active (if the element will be hidden)
ng-hide-remove-active (if the element will be showed)												
												
												
												CSS Transitions
<!DOCTYPE html>
<html>
<style>
	div {
	  transition: all linear 0.5s;
	  background-color: lightblue;
	  height: 100px;
	}

	.ng-hide {
	  height: 0;
	}

</style>
<script src="http://ajax.googleapis.com/ajax/libs/angularjs/1.4.8/angular.min.js"></script>
<script src="http://ajax.googleapis.com/ajax/libs/angularjs/1.4.8/angular-animate.js"></script>

<body ng-app="myApp">

	<h1>Hide the DIV: <input type="checkbox" ng-model="myCheck"></h1>

	<div ng-hide="myCheck"></div>

<script>
	var app = angular.module('myApp', ['ngAnimate']);
</script>

</body>
</html>

													

												CSS Animations
<!DOCTYPE html>
<html>
<style>
	@keyframes myChange {
	  from {
		  height: 100px;
	  } to {
		  height: 0;
	  }
	}

	div {
	  height: 100px;
	  background-color: lightblue;
	}

	div.ng-hide {
	  animation: 0.5s myChange;
	}
</style>
<script src="http://ajax.googleapis.com/ajax/libs/angularjs/1.4.8/angular.min.js"></script>
<script src="http://ajax.googleapis.com/ajax/libs/angularjs/1.4.8/angular-animate.js"></script>

<body ng-app="ngAnimate">

	Hide the DIV: <input type="checkbox" ng-model="myCheck">

	<div ng-hide="myCheck"></div>


</body>
</html>	
												
												
												
														AngularJS Routing
The ngRoute module helps your application to become a Single Page Application.

												What is Routing in AngularJS?
If you want to navigate to different pages in your application, but you also wants the application to be a SPA (Single Page Application), 
with no page reloading, you can use the ngRoute module.
The ngRoute module routes your application to different pages without reloading the entire application.
												
Например:

<!DOCTYPE html>
<html>
<script src="http://ajax.googleapis.com/ajax/libs/angularjs/1.4.8/angular.min.js"></script>
<script src="//ajax.googleapis.com/ajax/libs/angularjs/1.4.8/angular-route.js"></script>

<body ng-app="myApp">

	<p><a href="#/">Main</a></p>

	<a href="#red">Red</a>
	<a href="#green">Green</a>
	<a href="#blue">Blue</a>

	<div ng-view></div>

<script>
	var app = angular.module("myApp", ["ngRoute"]);
	app.config(function($routeProvider) {
		$routeProvider
		.when("/", {
			templateUrl : "main.htm"
		})
		.when("/red", {
			templateUrl : "red.htm"
		})
		.when("/green", {
			templateUrl : "green.htm"
		})
		.when("/blue", {
			templateUrl : "blue.htm"
		});
	});
</script>

<p>Click on the links to navigate to "red.htm", "green.htm", "blue.htm", or back to "main.htm"</p>
</body>
</html>												
												
Пример:												
http://www.w3schools.com/angular/tryit.asp?filename=try_ng_routing											
												
												
													What do I Need?
1.To make your applications ready for routing, you must include the AngularJS Route module:
<script src="http://ajax.googleapis.com/ajax/libs/angularjs/1.4.8/angular-route.js"></script>

2.Then you must add the ngRoute as a dependency in the application module::
var app = angular.module("myApp", ["ngRoute"]);

Now your application has access to the route module, which provides the $routeProvider.

3.Use the $routeProvider to configure different routes(маршруты) in your application:

app.config(function($routeProvider) {
  $routeProvider
  .when("/", {
    templateUrl : "main.htm"
  })
  .when("/red", {
    templateUrl : "red.htm"
  })
  .when("/green", {
    templateUrl : "green.htm"
  })
  .when("/blue", {
    templateUrl : "blue.htm"
  });
});												
												
												Where Does it Go?
Your application needs a container to put the content provided by the routing. 
This container is the ng-view directive.
There are three different ways to include the ng-view directive in your application:	
												
1. <div ng-view></div>
2. <ng-view></ng-view>
3. <div class="ng-view"></div>

												
Applications can only have one ng-view directive, and this will be the placeholder for all views provided by the route.

												
												$routeProvider
With the $routeProvider you can define what page to display when a user clicks a link.

Определите $routeProvider с помощью метода config вашего приложения. Работа зарегистрирована в методе конфигурации будет выполняться, когда приложение загружается.


												Controllers		
With the $routeProvider you can also define a controller for each "view".

												
<!DOCTYPE html>
<html>
<script src="http://ajax.googleapis.com/ajax/libs/angularjs/1.4.8/angular.min.js"></script>
<script src="//ajax.googleapis.com/ajax/libs/angularjs/1.4.8/angular-route.js"></script>

<body ng-app="myApp">

	<p><a href="#/">Main</a></p>

	<a href="#london">City 1</a>
	<a href="#paris">City 2</a>

	<p>Click on the links.</p>

	<p>Note that each "view" has its own controller which each gives the "msg" variable a value.</p>

	<div ng-view></div>

<script>
	var app = angular.module("myApp", ["ngRoute"]);
	app.config(function($routeProvider) {
		$routeProvider
		.when("/", {
			templateUrl : "main.htm",
		})
		.when("/london", {
			templateUrl : "london.htm",
			controller : "londonCtrl"
		})
		.when("/paris", {
			templateUrl : "paris.htm",
			controller : "parisCtrl"
		});
	});
	app.controller("londonCtrl", function ($scope) {
		$scope.msg = "I love London";
	});
	app.controller("parisCtrl", function ($scope) {
		$scope.msg = "I love Paris";
	});

</script>

</body>
</html>												
												
												
Вообщем смысл такой  в контролерах мы задаем все что нужно,а чтобы скажем вызвать переменную msg в файле london.html нужно ее вызвать при этом в этом файле не обязательно 
подключать angular, например:

<h1>London</h1>
<h3>London is the capital city of England.</h3>
<p>It is the most populous city in the United Kingdom, with a metropolitan area of over 13 million inhabitants.</p>
<p>{{msg}}</p>										
												
												
													Template
In the previous examples we have used the templateUrl property in the $routeProvider.when method.
You can also use the template property, which allows you to write HTML directly in the property value, and not refer to a page.												
												
<!DOCTYPE html>
<html>
<script src="http://ajax.googleapis.com/ajax/libs/angularjs/1.4.8/angular.min.js"></script>
<script src="//ajax.googleapis.com/ajax/libs/angularjs/1.4.8/angular-route.js"></script>

<body ng-app="myApp">

	<p><a href="#/">Main</a></p>

	<a href="#banana">Banana</a>
	<a href="#tomato">Tomato</a>

	<p>Click on the links to change the content.</p>

	<p>The HTML shown in the ng-view directive are written in the template property of the $routeProvider.when method.</p>

	<div ng-view></div>

<script>
	var app = angular.module("myApp", ["ngRoute"]);
	app.config(function($routeProvider) {
	    $routeProvider
	    .when("/", {
	        template : "<h1>Main</h1><p>Click on the links to change this content</p>"
	    })
	    .when("/banana", {
	        template : "<h1>Banana</h1><p>Bananas contain around 75% water.</p>"
	    })
	    .when("/tomato", {
	        template : "<h1>Tomato</h1><p>Tomatoes contain around 95% water.</p>"
	    });
	});
</script>

</body>
</html>												
												
												
													The otherwise method(Если ничего не выбранно)
In the previous examples we have used the when method of the $routeProvider.
You can also use the otherwise method, which is the default route when none of the others get a match.
	
<!DOCTYPE html>
<html>
<script src="http://ajax.googleapis.com/ajax/libs/angularjs/1.4.8/angular.min.js"></script>
<script src="//ajax.googleapis.com/ajax/libs/angularjs/1.4.8/angular-route.js"></script>

<body ng-app="myApp">

	<p><a href="#/">Main</a></p>

	<a href="#banana">Banana</a>
	<a href="#tomato">Tomato</a>

	<p>Click on the links to change the content.</p>

	<p>Use the "otherwise" method to define what to display when none of the links are clicked.</p>

	<div ng-view></div>

<script>
	var app = angular.module("myApp", ["ngRoute"]);
	app.config(function($routeProvider) {
	    $routeProvider
	    .when("/banana", {
	        template : "<h1>Banana</h1><p>Bananas contain around 75% water.</p>"
	    })
	    .when("/tomato", {
	        template : "<h1>Tomato</h1><p>Tomatoes contain around 95% water.</p>"
	    })
	    .otherwise({
	        template : "<h1>Nothing</h1><p>Nothing has been selected</p>"
	    });
	});
</script>

</body>
</html>
											

-------------------------------------------------------------------------------------------------------------------------------------------
														Метод splice 
Метод splice -  Пожалуй, самый комплексный метод для работы с массивом. Он объединяет в себе две разные функциональности: 
удаляет часть массива и добавляет новые элементы на место удаленных.


Пример: Удаление

arr = [ "a", "b", "c", "d", "e" ]
removed = arr.splice(1,2) //первая цифра это индекс с какого нужно удалять,а вторая сколько нужно удалять в данном случае 2 значение будет удаленно 
//начиная со 1 индекса

// removed = [ "b", "c"] (2 элемента с arr[1])
// arr = ["a", "d", "e"] (те что остались)

Пример: Добавление элементов

arr = [ "a", "b", "c", "d", "e" ]
// начиная с индекса 2 удалим 0 элементов 
// и добавим "b+"
arr.splice(2,0,"b+")
// arr = ["a", "b", "b+", "c", "d", "e"]
													
-------------------------------------------------------------------------------------------------------------------------------------------


-------------------------------------------------------------------------------------------------------------------------------------------												
														Метод forEach 
Используется для перебора массива.Он для каждого элемента массива вызывает функцию callback.
Этой функции он передаёт три параметра callback(item, i, arr):

item – очередной элемент массива.
i – его номер.
arr – массив, который перебирается.
Например:

var arr = ["Яблоко", "Апельсин", "Груша"];

arr.forEach(function(item, i, arr) {
  alert( i + ": " + item + " (массив:" + arr + ")" );
});														

Метод forEach ничего не возвращает, его используют только для перебора, как более «элегантный» вариант, чем обычный цикл for.

В Angular эта функция работает немного по другому:

angular.forEach(data, function(item){
	if(item.title.toLowerCase().indexOf(dataSearchToLowerCase) != -1) {
		result.push(item);
	}
});
return result;
 
-------------------------------------------------------------------------------------------------------------------------------------------												
												
												
												
										Убрать обработчик события(onclick,onmouseover....)
Если обработчик надоел – его всегда можно убрать назначением elem.onclick = null.Например:

function action() {
	for(var i = 1; i < 3; i++)  {
		alert(i);
	}
}

var click = document.querySelector("div");

click.onclick = action;	
click.onclick = null;										
												
										Доступ к элементу через this

Внутри обработчика события this ссылается на текущий элемент, то есть на тот, на котором он сработал.
Это можно использовать, чтобы получить свойства или изменить элемент.
В коде ниже button выводит свое содержимое, используя this.innerHTML:

<button onclick="alert(this.innerHTML)">Нажми меня</button>		
												
												
//правильный код с this в два конца html/js:

<div onclick="action(this)" class="red" id="ff" >Some text</div>

function action(x) {
	alert(x.innerHTML);
}
												
											Частые ошибки

Если вы только начинаете работать с событиями – обратите внимание на следующие особенности.
Функция должна быть присвоена как sayThanks, а не sayThanks().

button.onclick = sayThanks;

Если добавить скобки, то sayThanks() – будет уже результат выполнения функции (а так как в ней нет return, то в onclick попадёт undefined). Нам же нужна именно функция.
…А вот в разметке как раз скобки нужны:

<input type="button" id="button" onclick="sayThanks()" />	
												
												
												
Фундаментальный недостаток описанных выше способов назначения обработчика – невозможность повесить несколько обработчиков на одно событие.
Например, одна часть кода хочет при клике на кнопку делать ее подсвеченной, а другая – выдавать сообщение. Нужно в разных местах два обработчика повесить.
При этом новый обработчик будет затирать предыдущий. Например, следующий код на самом деле назначает один обработчик – последний:

input.onclick = function() { alert(1); }
// ...
input.onclick = function() { alert(2); } // заменит предыдущий обработчик												
												
	
											addEventListener и removeEventListener

Методы addEventListener и removeEventListener являются современным способом назначить или удалить обработчик, и при этом позволяют использовать 
сколько угодно любых обработчиков.Назначение обработчика осуществляется вызовом addEventListener с тремя аргументами:

element.addEventListener(event, handler[, phase]);

event	--- Имя события, например click
handler	--- Ссылка на функцию, которую надо поставить обработчиком.
phase	--- Необязательный аргумент, «фаза», на которой обработчик должен сработать. Этот аргумент редко нужен

Удаление обработчика осуществляется вызовом removeEventListener:

	// передать те же аргументы, что были у addEventListener
	element.removeEventListener(event, handler[, phase]);

Удаление требует именно ту же функцию.Для удаления нужно передать именно ту функцию-обработчик которая была назначена.

Вот так removeEventListener не сработает:

	elem.addEventListener( "click" , function() {alert('Спасибо!')});
	// ....
	elem.removeEventListener( "click", function() {alert('Спасибо!')});

В removeEventListener передана не та же функция, а другая, с одинаковым кодом, но это не важно.

Вот так правильно:

	function handler() {
	  alert( 'Спасибо!' );
	}

	input.addEventListener("click", handler);
	// ....
	input.removeEventListener("click", handler);


Обратим внимание – если функцию не сохранить где-либо, а просто передать в addEventListener, как в предыдущем коде, то потом получить её обратно, 
чтобы снять обработчик, будет невозможно. Нет метода, который позволяет считать обработчики событий, назначенные через addEventListener.


Метод addEventListener позволяет добавлять несколько обработчиков на одно событие одного элемента, например:

<input id="elem" type="button" value="Нажми меня"/>

<script>
	  function handler1() {
		alert('Спасибо!');
	  };

	  function handler2() {
		alert('Спасибо ещё раз!');
	  }

	  elem.onclick = function() { alert("Привет"); };
	  elem.addEventListener("click", handler1); // Спасибо!
	  elem.addEventListener("click", handler2); // Спасибо ещё раз!
</script>

Как видно из примера выше, можно одновременно назначать обработчики и через DOM-свойство и через addEventListener. Однако, во избежание путаницы, рекомендуется выбрать один способ.


												addEventListener работает всегда, а DOM-свойство – нет

У специальных методов есть ещё одно преимущество перед DOM-свойствами.
Есть некоторые события, которые нельзя назначить через DOM-свойство, но можно через addEventListener.
Например, таково событие transitionend, то есть окончание CSS-анимации. В большинстве браузеров оно требует назначения через addEventListener.
Вы можете проверить это, запустив код в примере ниже. Как правило, сработает лишь второй обработчик, но не первый.


<style>
  button {
    transition: width 1s;
    width: 100px;
  }

  .wide {
    width: 300px;
  }
</style>

<button id="elem" onclick="this.classList.toggle('wide');">
  Нажми меня
</button>

<script>
  elem.ontransitionend = function() {
    alert( "ontransitionend" ); // не сработает
  };

  elem.addEventListener("transitionend", function() {
    alert( "addEventListener" ); // сработает по окончании анимации
  });
</script>



При работе с событиями в IE8- есть много отличий. Как правило, они формальны – некое свойство или метод называются по-другому. 
Начиная с версии 9, также работают и стандартные свойства и методы.В IE8- вместо addEventListener/removeEventListener используются свои методы.
Назначение обработчика осуществляется вызовом attachEvent:

Например:

function handler() {
  alert( 'Спасибо!' );
}
button.attachEvent("onclick", handler) // Назначение обработчика
  // ....
button.detachEvent("onclick", handler) // Удаление обработчика

Как видите, почти то же самое, только событие должно включать префикс on.
У обработчиков, назначенных с attachEvent, нет this.Обработчики, назначенные с attachEvent не получают this!
Это важная особенность и подводный камень старых IE
Чтобы ваш код работал в старом IE, нужно либо использовать DOM-свойства, то есть onclick, либо подключить полифилл для современных методов, 
например (https://gist.github.com/jonathantneal/3748027) 
или с сервиса http://polyfill.webservices.ft.com/v1/docs/features/ или какой-то другой



												Остановка setInterval()

var stopInt = setInterval(clickRight, 2000);		

function stop() {
	clearInterval(stopInt);
}


wrapper.addEventListener("mouseover", stop);
wrapper.addEventListener("mouseout", function() {stopInt = setInterval(clickRight, 2000);});

//При наведении мышки остановится,а после запустит 




																classList
classList, которое представляет из себя объект, доступный для чтения.																

el.classList = 
{
    length: number, 
    add: function() {},
    contains: function() {},
    item: function() {},
    remove: function() {},
    toggle: function() {}
}


el.classList.length;  --- узнать сколько классов есть у элемента
el.classList.add('myCssClass');  --- добавить класс к элементу
el.classList.remove('myCssClass');  --- удалить один из классов элемента
el.classList.contains('myCssClass'); // возвратит true/false        --- проверить, содержит ли элемент какой-либо класс	
el.classList.toggle('myCssClass');   --- преключить класс (добавить, если его нет, или удалить, если он есть)											
el.classList.item('myCssClass'); // возвратит индекс класса myCssClass   --- узнать индекс интересующего класса в наборе классов элемента												
												
В IE 7-9 classList не работает.Нужно  для этих браузеров установить полифил и заработает: https://github.com/eligrey/classList.js/blob/master/classList.js
												

												
															Размеры и прокрутка элементов
---------------------------------------------------------------------------------------------------------------------------------------------------------															
offsetParent, offsetLeft/Top  --- В offsetParent находится ссылка на родительский элемент в смысле отображения на странице.
Возвращает значение отступа от родительского элемента,грубо говоря он показует margin родительского элемента 												
Например: 	

<textarea rows="10" cols="40" id="main">Ситуации</textarea>

main.onclick = function(){
	console.log(this.offsetTop); 
}
/*
	Вернет значение 8 так как для textarea родительским элементом ялвяется body у которого по умолчанию стоит margin 8px 
*/	

Или такой пример :

<form style="position: relative; margin-top: 20px;">
	<textarea rows="10" cols="40" id="main" style="position: absolute; margin-top: 100px;">Ситуации</textarea>
</form>

main.onclick = function(){
	console.log(this.offsetTop);
}

//будет 100 так как отстут отступ от родительского = 100px 		
---------------------------------------------------------------------------------------------------------------------------------------------------------
												
---------------------------------------------------------------------------------------------------------------------------------------------------------
														offsetWidth/Height
Относится к самому элементу.Эти два свойства – самые простые. Они содержат «внешнюю» ширину/высоту элемента, то есть его полный размер, включая рамки border.
То есть полный размер нашего элемента.
offsetWidth - включает в себя сумму: width,border,padding,  и полоссы прокрутки если она есть.
offsetHeight - внешняя высота блока	

Координаты и размеры в JavaScript устанавливаются только для видимых элементов.
Для элементов с display:none или находящихся вне документа дерево рендеринга не строится. Для них метрики равны нулю									
---------------------------------------------------------------------------------------------------------------------------------------------------------	
											
---------------------------------------------------------------------------------------------------------------------------------------------------------
														clientTop/Left
Далее внутри элемента у нас рамки border. Для них есть свойства-метрики clientTop и clientLeft.

clientLeft - ширина левой рамки
clientTop  - ширина верхней рамки												
---------------------------------------------------------------------------------------------------------------------------------------------------------	
											
---------------------------------------------------------------------------------------------------------------------------------------------------------	
														clientWidth/Height			
Эти свойства – размер элемента внутри рамок border. Они включают в себя ширину содержимого width вместе с полями padding, но без прокрутки.
Грубо говоря это свойство определяем ширину/высоту что есть в самом элементе учитывая padding,но кроме полос прокруток.	
Если padding нет, то clientWidth/Height в точности равны размеру области содержимого, внутри рамок и полосы прокрутки.Так например clientWidth будет
равна 284px, а CSS width будет равно 300px с полосой прокрутки									
---------------------------------------------------------------------------------------------------------------------------------------------------------
												
---------------------------------------------------------------------------------------------------------------------------------------------------------
														scrollWidth/Height
Эти свойства – аналоги clientWidth/clientHeight, но с учетом прокрутки. Свойства clientWidth/clientHeight относятся только к видимой области элемента, 
а scrollWidth/scrollHeight добавляют к ней прокрученную (которую не видно) по горизонтали/вертикали.	

Эти свойства можно использовать, чтобы «распахнуть» элемент на всю ширину/высоту, таким кодом:

element.style.height = element.scrollHeight + 'px';											
---------------------------------------------------------------------------------------------------------------------------------------------------------	
											
---------------------------------------------------------------------------------------------------------------------------------------------------------
														scrollLeft/scrollTop
Свойства scrollLeft/scrollTop – ширина/высота невидимой, прокрученной в данный момент, части элемента слева и сверху.Изменение этих свойств заставляет браузер прокручивать элемент	
Грубо говоря scrollTop влияет где будет показыватся 0 -это будет вверху списка а остальное внизу,например:

<textarea rows="5" cols="40" id="main">Эти свойства – размер элемента внутри рамок border. Они включают в себя ширину содержимого width вместе с полями padding, но без прокрутки.</textarea>

main.onclick = function(){
	this.value += "Эти свойства – размер элемента внутри рамок border. Они включают в себя ширину содержимого width вместе с полями padding, но без прокрутки.";
	var na =this.scrollTop = this.scrollHeight;
	console.log(na);
	if(na > 300) {
		this.scrollTop = 0;
		this.onclick = function() {
			this.scrollTop +=10;
		}
	}
}

При если na будет больше 300 пикселей то скролится на верх,а затем при клике будет опускатся в низ по 10 пикселей 											
---------------------------------------------------------------------------------------------------------------------------------------------------------												
												
												
												
												HTML5 Web Storage - обзор веб-хранилища(клиентское хранилише)
В HTML5 вводится лучшая альтернатива файлам cookies, которая позволяет легко и просто сохранять информацию на компьютере посетителя. 
Эта информация может храниться на клиентском компьютере неограниченное время, не отправляется на веб-сервер (если только разработчик не сделает это сам), 
может быть большого объема и для работы с ней требуется всего лишь пара простых, эффективных объектов JavaScript.
Функциональность веб-хранилища HTML5 позволяет веб-странице сохранять данные на компьютере посетителя. Эта информация может быть кратковременной, 
которая удаляется после выключения браузера, или долговременной, которая остается доступной при последующих посещениях веб-страницы.
Сохраняемая в веб-хранилище информация в действительности сохраняется не в интернете, а на компьютере посетителя веб-страницы. Иными, словами,
веб-хранилище означает хранение данных не в интернете, а хранение данных из интернета.

Существуют два типа веб-хранилищ, которые так или иначе связаны с двумя объектами:

1.Использует объект localStorage для хранения данных для всего веб-сайта на постоянной основе. Это означает, что если веб-страница сохранит данные в локальном хранилище, 
эти данные будут доступны для пользователя, когда он возвратится на эту веб-страницу на следующий день, на следующей неделе или в следующем году.

2.Использует объект sessionStorage для временного хранения данных для одного окна или вкладки браузера. Эти данные доступны лишь до тех пор, пока пользователь не закроет окно или вкладку, 
после чего сеанс заканчивается и данные удаляются. Но данные сеанса сохраняются, если пользователь переходит на другой веб-сайт, 
а потом возвращается обратно при условии, что это происходит в том же окне браузера.


Хотя спецификация HTML5 не устанавливает никаких жестких правил в отношении максимального объема хранилища, большинство браузеров ограничивают его 5 Мбайт. 
В этот объем можно упаковать много данных, но его будет недостаточно, если вы хотите использовать локальное хранилище для оптимизации производительности 
и кэшировать в нем изображения или видео большого объема (и, по правде говоря, локальное хранилище не предназначено для таких целей).

http://professorweb.ru/my/html/html5/level5/5_1.php    --- Более подробно 


Синтаксис для сохранения фрагмента данных следующий:

localStorage[keyName] = data;


Например:

 <fieldset>
      <legend>Веб-хранилище</legend>
      <label for="localData">Этот текст сохранится в локальном хранилище:</label>
      <input id="localData"><br>
      <label for="sessionData">Этот текст сохранится в хранилище данных сессии:</label>
      <input id="sessionData">
  </fieldset>
  <div>
      <button onclick="saveData()">Сохранить</button>
      <button onclick="loadData()">Загрузить</button>
  </div>


function saveData() {
    // Получаем значения текстовых полей
    var localData = document.getElementById("localData").value;
    var sessionData = document.getElementById("sessionData").value;

    // Сохраняем текст, введенный в текстовом поле, в локальном хранилище
    localStorage["localData"] = localData;
    
    // Сохраняем текст, введенный в текстовом поле, в хранилище сессий
    sessionStorage["sessionData"] = sessionData;
}

function loadData() {
    // Загружаем сохраненные данные из хранилищ
    var localData = localStorage["localData"];    
    var sessionData = sessionStorage["sessionData"];

    // Отображаем эти данные в текстовых полях
    if (localData != null) {
        document.getElementById("localData").value = localData;
    }
    if (sessionData != null) {
        document.getElementById("sessionData").value = sessionData;
    }
}


Веб-хранилище не работает без веб-сервера.В разных браузерах по разному но мы избавимся от многих хлопот, если поместите тестируемую страницу на тестовый сервер, 
чтобы избежать всех этих неопределенностей.

															
																Удаление элементов

Для удаления отдельного ненужного элемента используется метод removeItem(), которому передается соответствующий ключ																
																
localStorage.removeItem("localData");																
																
А если же требуется удалить все локальные данные, сохраненные веб-сайтом, используется более радикальный метод clear():

localStorage.clear();
																
																
															Поиск всех сохраненных элементов
Чтобы извлечь отдельный элемент данных из веб-хранилища, нам нужно знать его ключ. Но есть еще один ловкий прием. Посредством метода key() можно извлечь все элементы, 
хранящиеся в локальном хранилище или в хранилище сеансов (для текущего веб-сайта), даже если нам не известны их ключи. Этот метод полезен при отладке или когда нужно просто просмотреть, 
какие данные сохраняют другие страницы веб-сайта и под какими ключами. Например:

<button onclick="findAllItems()">Содержимое локального хранилища</button>
<ul id="itemList"></ul>	
																
function findAllItems() {
  // Получаем элемент <ul> для списка элементов данных
  var itemList = document.getElementById("itemList");
  
  // Очищаем список
  itemList.innerHTML = "";

  // Перебираем все элементы данных в цикле
  for (var i=0; i<localStorage.length; i++) {
	// Получаем ключ текущего элемента
    var key = localStorage.key(i);
	
	// Получаем сам элемент, хранящийся под этим ключом
    var item = localStorage[key];

    // Заполняем список
    var newItem = document.createElement("li");
    newItem.innerHTML = key + ": " + item;
    itemList.appendChild(newItem);
  }
}

// Сохранить какие-нибудь данные для примера
window.onload = function() {
	localStorage.username = "Alexandr";
	localStorage.password = "12345";
	localStorage.work = "programmer";
	localStorage.lang = "C#";
}																
																
																
																
															Сохранение чисел и дат
До сих пор в наших исследованиях веб-хранилища мы обходили стороной один важный аспект. 
А именно — все данные, сохраняемые посредством объектов localStorage и sessionStorage, автоматически преобразуются в текст.
Со значениями, которые и так являются текстовыми (например, имя пользователя, вводимое в текстовое поле), это обстоятельство не представляет никаких проблем. Но числа не такие сговорчивые.
	
Например: 

var today = new Date();																
																
																
Этот код сохраняет не объект даты, а текстовую строку, например Sat Jun 09 2013 13:30:46. К сожалению, не существует легкого способа для преобразования этого текста обратно в объект даты при 
извлечении его из хранилища. А если у нас нет объекта даты, мы не сможем манипулировать этой датой, как и ее исходным объектом, например вызывать его методы и выполнять вычисления.																
Чтобы решить эту проблему, разработчик должен явно преобразовать дату в текст, а потом преобразовать извлеченный из хранилища текст обратно в правильный объект даты:

window.onload = function() {
	// Сохранить какие-нибудь данные
	localStorage.mynumber = 5;
	
	// Получить число при считывании
	var x = Number(localStorage.mynumber);
	
	// Проверяем (если не использовать приведение к типу Number,
	// результатом будет строка "520")
	alert(x + 20);
	
	// Создаем новый объект даты
	var today = new Date();
	
	// Преобразуем дату в тестовую строку в формате ГГГГ/ММ/ДД 
	// и сохраняем эту строку
	sessionStorage.session_started = today.getFullYear() + 
	         "/" + today.getMonth() + "/" + today.getDate();
	
	// Теперь извлекаем из хранилища строку даты и с ее помощью 
	// создаем новый объект Date.
	// Это возможно благодаря распознаваемому формату текста даты
	today = new Date(sessionStorage.session_started);
	
	alert(today.getFullYear());
}																
																
																
																
															Сохранение объектов
Чтобы сохранить пользовательский объект в веб-хранилище, нам нужно преобразовать его в текст.Облегченный формат JSON преобразует структурированные данные — наподобие всех значений, 
обернутых в объект в текст. Но лучшее в JSON то, что его поддержка встроена в браузеры. Это означает, что мы можем преобразовать в текст любой объект JavaScript 
вместе с его данными простым вызовом метода JSON.stringify(), а метод JSON.parse() преобразует этот текст обратно в объект. Например:
	
// Определяем тип данных UserInfo
function UserInfo(name, family, age, login) {
	this.name = name;
	this.family = family;
	this.age = age;
	this.login = login;
}

window.onload = function() {
	// Создаем объект UserInfo
	var user = new UserInfo("Иван", "Петров", 28, "ivan85_krevedko");
	
	// Сохраняем этот объект в формате JSON
	sessionStorage.userinfo = JSON.stringify(user);
	
	// Для проверки
	user = null;
	
	// Преобразуем JSON-текст в соответствующий объект
	user = JSON.parse(sessionStorage.userinfo);
	
	alert("Привет " + user.name + " " + user.family);
}																
																
																
															Реагирование на изменения в хранилище
Кроме рассмотренных применений, веб-хранилище предоставляет способ для общения между разными окнами браузера. Это возможно благодаря тому, что каждое изменение локального хранилища 
или хранилища сеансов активирует событие window.onstorage во всех других окнах, в которых просматривается та же страница или другая страница того же самого сайта.

Таким образом, изменение локального хранилища для страницы www.professorweb.ru/index.html активирует событие onstorage в окне браузера для страницы www.professorweb.ru/about.html. 
(Конечно же, страницы должны просматриваться в том же браузере и на том же компьютере, но вы это уже и так знали, не так ли?)
Событие onstorage активируется при добавлении объекта в хранилище, изменении объекта, находящегося в хранилище, удалении объекта из хранилища или полной очистке хранилища. 
Событие не активируется, если код выполняет операцию с хранилищем, которая не имеет никакого эффекта (например, сохранение значения, которое уже находится в хранилище, 
или очистка пустого хранилища).
Рассмотрим пример страницы показанной на рисунке ниже. Здесь в хранилище можно добавить любое значение с любым ключом, заполнив соответствующие текстовые поля и нажав кнопку "Добавить". 
Добавленное значение отображается на другой, уже открытой странице.
	
																
																
<form>
	<label>Local Storage</label>
	<input type="text" id="key">
	
	<label>Local Storage</label>
	<input type="text" id="item">
	
	<button type="button" id="save">Save</input>
</form>																
																
																
																
function addValue() {
// Получаем значения из обоих текстовых полей
var key = document.getElementById("key").value;
var item = document.getElementById("item").value;

// Сохраняем элемент в локальном хранилище.
// Если ключ уже существует, новый элемент заменяет старый
localStorage[key] = item;
}															
															

var save = document.getElementById("save");
save.onclick = addValue;



Вторая страница тоже не представляет ничего сложного. При загрузке страницы событию window.onstorage присваивается функция с помощью следующего кода:

window.onload = function() {
     // Подключаем событие onstorage к функции storageChanged
     window.addEventListener("storage", storageChanged, false);
};

function storageChanged(e) {
    var message = document.getElementById("updateMessage");
    message.innerHTML = "Обновление локального хранилища.";
    message.innerHTML += "<br>Ключ: " + e.key;
    message.innerHTML += "<br>Старое значение: " + e.oldValue;
    message.innerHTML += "<br>Новое значение: " + e.newValue;
    message.innerHTML += "<br>URL: " + e.url;
}



--------------------------------------------------------------------------------------------------------------------------------------
													confirm
Синтаксис:

result = confirm(question);

confirm выводит окно с вопросом question с двумя кнопками: OK и CANCEL.

Результатом будет true при нажатии OK и false – при CANCEL(Esc).

Например:

var isAdmin = confirm("Вы - администратор?");

alert( isAdmin );													
--------------------------------------------------------------------------------------------------------------------------------------




															Оператор вопросительный знак „?“

Иногда нужно в зависимости от условия присвоить переменную. Например:

var access;
var age = prompt('Сколько вам лет?', '');

if (age > 14) {
  access = true;
} else {
  access = false;
}

alert(access);

Оператор вопросительный знак '?' позволяет делать это короче и проще.Он состоит из трех частей:

условие ? значение1 : значение2

Проверяется условие, затем если оно верно – возвращается значение1, если неверно – значение2, например:

access = (age > 14) ? true : false;

Но когда скобки есть – код лучше читается. Так что рекомендуется их писать.

															Несколько операторов „?“

Последовательность операторов '?' позволяет вернуть значение в зависимости не от одного условия, а от нескольких.

Например:

var age = prompt('возраст?', 18);

var message = (age < 3) ? 'Здравствуй, малыш!' :
  (age < 18) ? 'Привет!' :
  (age < 100) ? 'Здравствуйте!' :
  'Какой необычный возраст!';

alert( message );


---------------------------------------------------------------------------------------------------------------------------------------------------
															isFinite(n)
Функция isFinite(n) преобразует аргумент к числу и возвращает true, если это не NaN/Infinity/-Infinity:

alert( isFinite(1) ); // true
alert( isFinite(Infinity) ); // false
alert( isFinite(NaN) ); // false															

---------------------------------------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------------------------------------
												Мягкое преобразование: parseInt и parseFloat
В мире HTML/CSS многие значения не являются в точности числами. Например, метрики CSS: 10pt или -12px.

Оператор '+' для таких значений возвратит NaN:
alert(+"12px") // NaN

Для удобного чтения таких значений существует функция parseInt:
alert( parseInt('12px') ); // 12	

Функция parseInt и ее аналог parseFloat преобразуют строку символ за символом, пока это возможно.

При возникновении ошибки возвращается число, которое получилось. Функция parseInt читает из строки целое число, а parseFloat – дробное.

alert( parseInt('12px') ) // 12, ошибка на символе 'p'
alert( parseFloat('12.3.4') ) // 12.3, ошибка на второй точке

Конечно, существуют ситуации, когда parseInt/parseFloat возвращают NaN. Это происходит при ошибке на первом же символе:

alert( parseInt('a123') ); // NaN

Функция parseInt также позволяет указать систему счисления, то есть считывать числа, заданные в шестнадцатиричной и других системах счисления:

alert( parseInt('FF', 16) ); // 255											
---------------------------------------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------------------------------------
												Функция для проверки на число
function isNumeric(n) {
  return !isNaN(parseFloat(n)) && isFinite(n);
}

Разберёмся, как она работает. Начнём справа.

Функция isFinite(n) преобразует аргумент к числу и возвращает true, если это не Infinity/-Infinity/NaN.

Таким образом, правая часть отсеет заведомо не-числа, но оставит такие значения как true/false/null и пустую строку '', т.к. они корректно преобразуются в числа.

Для их проверки нужна левая часть. Вызов parseFloat(true/false/null/'') вернёт NaN для этих значений.

Так устроена функция parseFloat: она преобразует аргумент к строке, т.е. true/false/null становятся "true"/"false"/"null", а затем считывает из неё число, при этом пустая строка даёт NaN.

В результате отсеивается всё, кроме строк-чисел и обычных чисел.			

//Если использовать isNaN() то пустая строка, null, false, true будет считатся числом									
---------------------------------------------------------------------------------------------------------------------------------------------------




																	Округление

Одна из самых частых операций с числом – округление. В JavaScript существуют целых 3 функции для этого.

Math.floor ---   Округляет вниз
Math.ceil ---    Округляет вверх
Math.round ---    Округляет до ближайшего целого

alert( Math.floor(3.1) );  // 3
alert( Math.ceil(3.1) );   // 4
alert( Math.round(3.1) );  // 3


Округление битовыми операторами
Битовые операторы делают любое число 32-битным целым, обрезая десятичную часть.
В результате побитовая операция, которая не изменяет число, например, двойное битовое НЕ – округляет его:

alert( ~~12.3 ); // 12

Любая побитовая операция такого рода подойдет, например XOR (исключающее ИЛИ, "^") с нулем:

alert( 12.3 ^ 0 ); // 12
alert( 1.2 + 1.3 ^ 0 ); // 2, приоритет ^ меньше, чем +

Округление до заданной точности

Для округления до нужной цифры после запятой можно умножить и поделить на 10 с нужным количеством нулей. Например, округлим 3.456 до 2-го знака после запятой:

var n = 3.456;
alert( Math.round(n * 100) / 100 ); // 3.456 -> 345.6 -> 346 -> 3.46

Таким образом можно округлять число и вверх и вниз.

Существует также специальный метод num.toFixed(precision), который округляет число num до точности precision и возвращает результат в виде строки:

var n = 12.34;
alert( n.toFixed(1) ); // "12.3"

Округление идёт до ближайшего значения, аналогично Math.round

															Метод toFixed не эквивалентен Math.round!

Например, произведём округление до одного знака после запятой с использованием двух способов: toFixed и Math.round с умножением и делением:

var price = 6.35;

alert( price.toFixed(1) ); // 6.3
alert( Math.round(price * 10) / 10 ); // 6.4

Как видно, результат разный! Вариант округления через Math.round получился более корректным, так как по общепринятым правилам 5 округляется вверх. 
А toFixed может округлить его как вверх, так и вниз

--------------------------------------------------------------------------------------------------------------------------------------------------
																	concat		
Метод arr.concat(value1, value2, … valueN) создаёт новый массив, в который копируются элементы из arr, а также value1, value2, ... valueN.

Например:

var arr = [1, 2];
var newArr = arr.concat(3, 4);

alert( newArr ); // 1,2,3,4

У concat есть одна забавная особенность.

Если аргумент concat – массив, то concat добавляет элементы из него.

Например:

var arr = [1, 2];

var newArr = arr.concat([3, 4], 5); // то же самое, что arr.concat(3,4,5)

alert( newArr ); // 1,2,3,4,5
--------------------------------------------------------------------------------------------------------------------------------------------------
																	


														Доступ к «лишним» аргументам

Как получить значения аргументов, которых нет в списке параметров? Доступ к ним осуществляется через «псевдо-массив» arguments.
Он содержит список аргументов по номерам: arguments[0], arguments[1]…, а также свойство length.
Например, выведем список всех аргументов:

function sayHi() {
  for (var i = 0; i < arguments.length; i++) {
    alert( "Привет, " + arguments[i] );
  }
}

sayHi("Винни", "Пятачок"); // 'Привет, Винни', 'Привет, Пятачок'


arguments – это не массив  .Частая ошибка новичков – попытка применить методы Array к arguments. Это невозможно:

function sayHi() {
  var a = arguments.shift(); // ошибка! нет такого метода!
}

sayHi(1);

Дело в том, что arguments – это не массив Array.
В действительности, это обычный объект, просто ключи числовые и есть length. На этом сходство заканчивается. Никаких особых методов у него нет, и методы массивов он тоже не поддерживает.
Впрочем, никто не мешает сделать обычный массив из arguments, например так:

var args = [];
for (var i = 0; i < arguments.length; i++) {
  args[i] = arguments[i];
}




											console.time(метка) и console.timeEnd(метка)

Для измерения с одновременным выводом результатов в консоли есть методы:

    console.time(метка) – включить внутренний хронометр браузера с меткой.
    console.timeEnd(метка) – выключить внутренний хронометр браузера с меткой и вывести результат.

Параметр "метка" используется для идентификации таймера, чтобы можно было делать много замеров одновременно и даже вкладывать измерения друг в друга.
В коде ниже таймеры walkIn, walkLength – конкретные тесты, а таймер «All Benchmarks» – время «на всё про всё»:

var arr = [];
for (var i = 0; i < 1000; i++) arr[i] = 0;

function walkIn(arr) {
  for (var key in arr) arr[key]++;
}

function walkLength(arr) {
  for (var i = 0; i < arr.length; i++) arr[i]++;
}

function bench(f) {
  for (var i = 0; i < 10000; i++) f(arr);
}

console.time("All Benchmarks");

console.time("walkIn");
bench(walkIn);
console.timeEnd("walkIn");

console.time("walkLength");
bench(walkLength);
console.timeEnd("walkLength");

console.timeEnd("All Benchmarks");









































												
												
												
												
												








	
						
						
											   
											   
											   
											   
											   
											   Литература:
http://www.w3schools.com/angular/angular_intro.asp  --- тут я обучаюсь





















